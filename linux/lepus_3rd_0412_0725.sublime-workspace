{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"model",
				"model_id"
			],
			[
				"mod",
				"model_id"
			]
		]
	},
	"buffers":
	[
		{
			"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c",
			"settings":
			{
				"buffer_size": 12868,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/wl_android.c",
			"settings":
			{
				"buffer_size": 82846,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c",
			"settings":
			{
				"buffer_size": 53970,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/arch/arm/configs/s5p4418_lepus_android_lollipop_defconfig",
			"settings":
			{
				"buffer_size": 83895,
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/drivers/net/can/mcp251x.c",
			"settings":
			{
				"buffer_size": 32549,
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/net/core/dev.c",
			"settings":
			{
				"buffer_size": 164046,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/bcmsdh_linux.c",
			"settings":
			{
				"buffer_size": 13305,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_pcie_linux.c",
			"settings":
			{
				"buffer_size": 34145,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_sdio.c",
			"settings":
			{
				"buffer_size": 275453,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_wlfc.c",
			"settings":
			{
				"buffer_size": 105914,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/wl_cfg80211.c",
			"settings":
			{
				"buffer_size": 442445,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_gpio.c",
			"settings":
			{
				"buffer_size": 8451,
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/bcmsdh.c",
			"settings":
			{
				"buffer_size": 17854,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/wl_iw.c",
			"settings":
			{
				"buffer_size": 100008,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/*\n * Broadcom Dongle Host Driver (DHD), Linux-specific network interface\n * Basically selected code segments from usb-cdc.c and usb-rndis.c\n *\n * $Copyright Open Broadcom Corporation$\n *\n * $Id: dhd_linux.c 505753 2014-10-01 01:40:15Z $\n */\n\n#include <typedefs.h>\n#include <linuxver.h>\n#include <osl.h>\n#ifdef SHOW_LOGTRACE\n#include <linux/syscalls.h>\n#include <event_log.h>\n#endif /* SHOW_LOGTRACE */\n\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/etherdevice.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/ethtool.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/ip.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <net/addrconf.h>\n#ifdef ENABLE_ADAPTIVE_SCHED\n#include <linux/cpufreq.h>\n#endif /* ENABLE_ADAPTIVE_SCHED */\n\n#include <asm/uaccess.h>\n#include <asm/unaligned.h>\n\n#include <epivers.h>\n#include <bcmutils.h>\n#include <bcmendian.h>\n#include <bcmdevs.h>\n\n#include <proto/ethernet.h>\n#include <proto/bcmevent.h>\n#include <proto/vlan.h>\n#ifdef DHD_L2_FILTER\n#include <proto/bcmicmp.h>\n#endif\n#include <proto/802.3.h>\n\n#include <dngl_stats.h>\n#include <dhd_linux_wq.h>\n#include <dhd.h>\n#include <dhd_linux.h>\n#ifdef PCIE_FULL_DONGLE\n#include <dhd_flowring.h>\n#endif\n#include <dhd_bus.h>\n#include <dhd_proto.h>\n#include <dhd_config.h>\n#ifdef WL_ESCAN\n#include <wl_escan.h>\n#endif\n#include <dhd_dbg.h>\n#ifdef CONFIG_HAS_WAKELOCK\n#include <linux/wakelock.h>\n#endif\n#ifdef WL_CFG80211\n#include <wl_cfg80211.h>\n#endif\n#ifdef P2PONEINT\n#include <wl_cfgp2p.h>\n#endif\n#ifdef PNO_SUPPORT\n#include <dhd_pno.h>\n#endif\n#ifdef WLBTAMP\n#include <proto/802.11_bta.h>\n#include <proto/bt_amp_hci.h>\n#include <dhd_bta.h>\n#endif\n\n#ifdef CONFIG_COMPAT\n#include <linux/compat.h>\n#endif\n\n#ifdef DHD_WMF\n#include <dhd_wmf_linux.h>\n#endif /* DHD_WMF */\n\n#ifdef AMPDU_VO_ENABLE\n#include <proto/802.1d.h>\n#endif /* AMPDU_VO_ENABLE */\n#ifdef DHDTCPACK_SUPPRESS\n#include <dhd_ip.h>\n#endif /* DHDTCPACK_SUPPRESS */\n\n#if defined(DHD_TCP_WINSIZE_ADJUST)\n#include <linux/tcp.h>\n#include <net/tcp.h>\n#endif /* DHD_TCP_WINSIZE_ADJUST */\n\n#include <mach/platform.h>\n#include <mach/devices.h>\n#include <mach/soc.h>\n\n#ifdef WLMEDIA_HTSF\n#include <linux/time.h>\n#include <htsf.h>\n\n\n\n#define HTSF_MINLEN 200    /* min. packet length to timestamp */\n#define HTSF_BUS_DELAY 150 /* assume a fix propagation in us  */\n#define TSMAX  1000        /* max no. of timing record kept   */\n#define NUMBIN 34\n\nstatic uint32 tsidx = 0;\nstatic uint32 htsf_seqnum = 0;\nuint32 tsfsync;\nstruct timeval tsync;\nstatic uint32 tsport = 5010;\n\ntypedef struct histo_ {\n\tuint32 bin[NUMBIN];\n} histo_t;\n\n#if !ISPOWEROF2(DHD_SDALIGN)\n#error DHD_SDALIGN is not a power of 2!\n#endif\n\nstatic histo_t vi_d1, vi_d2, vi_d3, vi_d4;\n#endif /* WLMEDIA_HTSF */\n\n#if defined(DHD_TCP_WINSIZE_ADJUST)\n#define MIN_TCP_WIN_SIZE 18000\n#define WIN_SIZE_SCALE_FACTOR 2\n#define MAX_TARGET_PORTS 5\n\nstatic uint target_ports[MAX_TARGET_PORTS] = {20, 0, 0, 0, 0};\nstatic uint dhd_use_tcp_window_size_adjust = FALSE;\nstatic void dhd_adjust_tcp_winsize(int op_mode, struct sk_buff *skb);\n#endif /* DHD_TCP_WINSIZE_ADJUST */\n\n\n#if defined(SOFTAP)\nextern bool ap_cfg_running;\nextern bool ap_fw_loaded;\n#endif\n\n\n#ifdef ENABLE_ADAPTIVE_SCHED\n#define DEFAULT_CPUFREQ_THRESH\t\t1000000\t/* threshold frequency : 1000000 = 1GHz */\n#ifndef CUSTOM_CPUFREQ_THRESH\n#define CUSTOM_CPUFREQ_THRESH\tDEFAULT_CPUFREQ_THRESH\n#endif /* CUSTOM_CPUFREQ_THRESH */\n#endif /* ENABLE_ADAPTIVE_SCHED */\n\n/* enable HOSTIP cache update from the host side when an eth0:N is up */\n#define AOE_IP_ALIAS_SUPPORT 1\n\n#ifdef BCM_FD_AGGR\n#include <bcm_rpc.h>\n#include <bcm_rpc_tp.h>\n#endif\n#ifdef PROP_TXSTATUS\n#include <wlfc_proto.h>\n#include <dhd_wlfc.h>\n#endif\n\n#include <wl_android.h>\n\n#if defined(CUSTOMER_HW20) && defined(WLANAUDIO)\n#include <sdaudio.h>\n#endif /* CUSTOMER_HW20 && WLANAUDIO */\n\n/* Maximum STA per radio */\n#define DHD_MAX_STA     32\n\n\nconst uint8 wme_fifo2ac[] = { 0, 1, 2, 3, 1, 1 };\nconst uint8 prio2fifo[8] = { 1, 0, 0, 1, 2, 2, 3, 3 };\n#define WME_PRIO2AC(prio)  wme_fifo2ac[prio2fifo[(prio)]]\n\n#ifdef ARP_OFFLOAD_SUPPORT\nvoid aoe_update_host_ipv4_table(dhd_pub_t *dhd_pub, u32 ipa, bool add, int idx);\nstatic int dhd_inetaddr_notifier_call(struct notifier_block *this,\n\tunsigned long event, void *ptr);\nstatic struct notifier_block dhd_inetaddr_notifier = {\n\t.notifier_call = dhd_inetaddr_notifier_call\n};\n/* to make sure we won't register the same notifier twice, otherwise a loop is likely to be\n * created in kernel notifier link list (with 'next' pointing to itself)\n */\nstatic bool dhd_inetaddr_notifier_registered = FALSE;\n#endif /* ARP_OFFLOAD_SUPPORT */\n\n#ifdef CONFIG_IPV6\nstatic int dhd_inet6addr_notifier_call(struct notifier_block *this,\n\tunsigned long event, void *ptr);\nstatic struct notifier_block dhd_inet6addr_notifier = {\n\t.notifier_call = dhd_inet6addr_notifier_call\n};\n/* to make sure we won't register the same notifier twice, otherwise a loop is likely to be\n * created in kernel notifier link list (with 'next' pointing to itself)\n */\nstatic bool dhd_inet6addr_notifier_registered = FALSE;\n#endif\n\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP)\n#include <linux/suspend.h>\nvolatile bool dhd_mmc_suspend = FALSE;\nDECLARE_WAIT_QUEUE_HEAD(dhd_dpc_wait);\n#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP) */\n\n#if defined(OOB_INTR_ONLY) || defined(FORCE_WOWLAN)\nextern void dhd_enable_oob_intr(struct dhd_bus *bus, bool enable);\n#endif \n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && (1)\nstatic void dhd_hang_process(void *dhd_info, void *event_data, u8 event);\n#endif \n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))\nMODULE_LICENSE(\"GPL v2\");\n#endif /* LinuxVer */\n\n#include <dhd_bus.h>\n\n#ifdef BCM_FD_AGGR\n#define DBUS_RX_BUFFER_SIZE_DHD(net)\t(BCM_RPC_TP_DNGL_AGG_MAX_BYTE)\n#else\n#ifndef PROP_TXSTATUS\n#define DBUS_RX_BUFFER_SIZE_DHD(net)\t(net->mtu + net->hard_header_len + dhd->pub.hdrlen)\n#else\n#define DBUS_RX_BUFFER_SIZE_DHD(net)\t(net->mtu + net->hard_header_len + dhd->pub.hdrlen + 128)\n#endif\n#endif /* BCM_FD_AGGR */\n\n#ifdef PROP_TXSTATUS\nextern bool dhd_wlfc_skip_fc(void);\nextern void dhd_wlfc_plat_init(void *dhd);\nextern void dhd_wlfc_plat_deinit(void *dhd);\n#endif /* PROP_TXSTATUS */\n\n#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 15)\nconst char *\nprint_tainted()\n{\n\treturn \"\";\n}\n#endif\t/* LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 15) */\n\n/* Linux wireless extension support */\n#if defined(WL_WIRELESS_EXT)\n#include <wl_iw.h>\nextern wl_iw_extra_params_t  g_wl_iw_params;\n#endif /* defined(WL_WIRELESS_EXT) */\n\n#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)\n#include <linux/earlysuspend.h>\n#endif /* defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND) */\n\nextern int dhd_get_suspend_bcn_li_dtim(dhd_pub_t *dhd);\n\n#ifdef PKT_FILTER_SUPPORT\nextern void dhd_pktfilter_offload_set(dhd_pub_t * dhd, char *arg);\nextern void dhd_pktfilter_offload_enable(dhd_pub_t * dhd, char *arg, int enable, int master_mode);\nextern void dhd_pktfilter_offload_delete(dhd_pub_t *dhd, int id);\n#endif\n\n\n#ifdef READ_MACADDR\nextern int dhd_read_macaddr(struct dhd_info *dhd);\n#else\nstatic inline int dhd_read_macaddr(struct dhd_info *dhd) { return 0; }\n#endif\n#ifdef WRITE_MACADDR\nextern int dhd_write_macaddr(struct ether_addr *mac);\n#else\nstatic inline int dhd_write_macaddr(struct ether_addr *mac) { return 0; }\n#endif\n\n\n#if defined(SOFTAP_TPUT_ENHANCE)\nextern void dhd_bus_setidletime(dhd_pub_t *dhdp, int idle_time);\nextern void dhd_bus_getidletime(dhd_pub_t *dhdp, int* idle_time);\n#endif /* SOFTAP_TPUT_ENHANCE */\n\n\n#ifdef SET_RPS_CPUS\nint custom_rps_map_set(struct netdev_rx_queue *queue, char *buf, size_t len);\nvoid custom_rps_map_clear(struct netdev_rx_queue *queue);\n#ifdef CONFIG_MACH_UNIVERSAL5433\n#define RPS_CPUS_MASK \"10\"\n#else\n#define RPS_CPUS_MASK \"6\"\n#endif /* CONFIG_MACH_UNIVERSAL5433 */\n#endif /* SET_RPS_CPUS */\n\nstatic int dhd_reboot_callback(struct notifier_block *this, unsigned long code, void *unused);\nstatic struct notifier_block dhd_reboot_notifier = {\n\t\t.notifier_call = dhd_reboot_callback,\n\t\t.priority = 1,\n};\n\n\ntypedef struct dhd_if_event {\n\tstruct list_head\tlist;\n\twl_event_data_if_t\tevent;\n\tchar\t\t\tname[IFNAMSIZ+1];\n\tuint8\t\t\tmac[ETHER_ADDR_LEN];\n} dhd_if_event_t;\n\n/* Interface control information */\ntypedef struct dhd_if {\n\tstruct dhd_info *info;\t\t\t/* back pointer to dhd_info */\n\t/* OS/stack specifics */\n\tstruct net_device *net;\n\tint\t\t\t\tidx;\t\t\t/* iface idx in dongle */\n\tuint\t\t\tsubunit;\t\t/* subunit */\n\tuint8\t\t\tmac_addr[ETHER_ADDR_LEN];\t/* assigned MAC address */\n\tbool\t\t\tset_macaddress;\n\tbool\t\t\tset_multicast;\n\tuint8\t\t\tbssidx;\t\t\t/* bsscfg index for the interface */\n\tbool\t\t\tattached;\t\t/* Delayed attachment when unset */\n\tbool\t\t\ttxflowcontrol;\t/* Per interface flow control indicator */\n\tchar\t\t\tname[IFNAMSIZ+1]; /* linux interface name */\n\tstruct net_device_stats stats;\n#ifdef DHD_WMF\n\tdhd_wmf_t\t\twmf;\t\t/* per bsscfg wmf setting */\n#endif /* DHD_WMF */\n#ifdef PCIE_FULL_DONGLE\n\tstruct list_head sta_list;\t\t/* sll of associated stations */\n#if !defined(BCM_GMAC3)\n\tspinlock_t\tsta_list_lock;\t\t/* lock for manipulating sll */\n#endif /* ! BCM_GMAC3 */\n#endif /* PCIE_FULL_DONGLE */\n\tuint32  ap_isolate;\t\t\t/* ap-isolation settings */\n} dhd_if_t;\n\n#ifdef WLMEDIA_HTSF\ntypedef struct {\n\tuint32 low;\n\tuint32 high;\n} tsf_t;\n\ntypedef struct {\n\tuint32 last_cycle;\n\tuint32 last_sec;\n\tuint32 last_tsf;\n\tuint32 coef;     /* scaling factor */\n\tuint32 coefdec1; /* first decimal  */\n\tuint32 coefdec2; /* second decimal */\n} htsf_t;\n\ntypedef struct {\n\tuint32 t1;\n\tuint32 t2;\n\tuint32 t3;\n\tuint32 t4;\n} tstamp_t;\n\nstatic tstamp_t ts[TSMAX];\nstatic tstamp_t maxdelayts;\nstatic uint32 maxdelay = 0, tspktcnt = 0, maxdelaypktno = 0;\n\n#endif  /* WLMEDIA_HTSF */\n\nstruct ipv6_work_info_t {\n\tuint8\t\t\tif_idx;\n\tchar\t\t\tipv6_addr[16];\n\tunsigned long\t\tevent;\n};\n\n#if defined(CUSTOMER_HW20) && defined(WLANAUDIO)\n#define MAX_WLANAUDIO_BLACKLIST 4\n\nstruct wlanaudio_blacklist {\n\tbool is_blacklist;\n\tuint32 cnt;\n\tulong txfail_jiffies;\n\tstruct ether_addr blacklist_addr;\n};\n#endif /* CUSTOMER_HW20 && WLANAUDIO */\n\n/* When Perimeter locks are deployed, any blocking calls must be preceeded\n * with a PERIM UNLOCK and followed by a PERIM LOCK.\n * Examples of blocking calls are: schedule_timeout(), down_interruptible(),\n * wait_event_timeout().\n */\n\n/* Local private structure (extension of pub) */\ntypedef struct dhd_info {\n#if defined(WL_WIRELESS_EXT)\n\twl_iw_t\t\tiw;\t\t/* wireless extensions state (must be first) */\n#endif /* defined(WL_WIRELESS_EXT) */\n\tdhd_pub_t pub;\n\tdhd_if_t *iflist[DHD_MAX_IFS]; /* for supporting multiple interfaces */\n\n\tvoid *adapter;\t\t\t/* adapter information, interrupt, fw path etc. */\n\tchar fw_path[PATH_MAX];\t\t/* path to firmware image */\n\tchar nv_path[PATH_MAX];\t\t/* path to nvram vars file */\n\tchar conf_path[PATH_MAX];\t/* path to config vars file */\n\n\tstruct semaphore proto_sem;\n#ifdef PROP_TXSTATUS\n\tspinlock_t\twlfc_spinlock;\n\n#endif /* PROP_TXSTATUS */\n#ifdef WLMEDIA_HTSF\n\thtsf_t  htsf;\n#endif\n\twait_queue_head_t ioctl_resp_wait;\n\tuint32\tdefault_wd_interval;\n\n\tstruct timer_list timer;\n\tbool wd_timer_valid;\n\tstruct tasklet_struct tasklet;\n\tspinlock_t\tsdlock;\n\tspinlock_t\ttxqlock;\n\tspinlock_t\tdhd_lock;\n\n\tstruct semaphore sdsem;\n\ttsk_ctl_t\tthr_dpc_ctl;\n\ttsk_ctl_t\tthr_wdt_ctl;\n\n\ttsk_ctl_t\tthr_rxf_ctl;\n\tspinlock_t\trxf_lock;\n\tbool\t\trxthread_enabled;\n\n\t/* Wakelocks */\n#if defined(CONFIG_HAS_WAKELOCK) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))\n\tstruct wake_lock wl_wifi;   /* Wifi wakelock */\n\tstruct wake_lock wl_rxwake; /* Wifi rx wakelock */\n\tstruct wake_lock wl_ctrlwake; /* Wifi ctrl wakelock */\n\tstruct wake_lock wl_wdwake; /* Wifi wd wakelock */\n#ifdef BCMPCIE_OOB_HOST_WAKE\n\tstruct wake_lock wl_intrwake; /* Host wakeup wakelock */\n#endif /* BCMPCIE_OOB_HOST_WAKE */\n#endif /* CONFIG_HAS_WAKELOCK && LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27) */\n\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1\n\t/* net_device interface lock, prevent race conditions among net_dev interface\n\t * calls and wifi_on or wifi_off\n\t */\n\tstruct mutex dhd_net_if_mutex;\n\tstruct mutex dhd_suspend_mutex;\n#endif\n\tspinlock_t wakelock_spinlock;\n\tuint32 wakelock_counter;\n\tint wakelock_wd_counter;\n\tint wakelock_rx_timeout_enable;\n\tint wakelock_ctrl_timeout_enable;\n\tbool waive_wakelock;\n\tuint32 wakelock_before_waive;\n\n\t/* Thread to issue ioctl for multicast */\n\twait_queue_head_t ctrl_wait;\n\tatomic_t pend_8021x_cnt;\n\tdhd_attach_states_t dhd_state;\n#ifdef SHOW_LOGTRACE\n\tdhd_event_log_t event_data;\n#endif /* SHOW_LOGTRACE */\n\n#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)\n\tstruct early_suspend early_suspend;\n#endif /* CONFIG_HAS_EARLYSUSPEND && DHD_USE_EARLYSUSPEND */\n\n#ifdef ARP_OFFLOAD_SUPPORT\n\tu32 pend_ipaddr;\n#endif /* ARP_OFFLOAD_SUPPORT */\n#ifdef BCM_FD_AGGR\n\tvoid *rpc_th;\n\tvoid *rpc_osh;\n\tstruct timer_list rpcth_timer;\n\tbool rpcth_timer_active;\n\tbool fdaggr;\n#endif\n#ifdef DHDTCPACK_SUPPRESS\n\tspinlock_t\ttcpack_lock;\n#endif /* DHDTCPACK_SUPPRESS */\n\tvoid\t\t\t*dhd_deferred_wq;\n#ifdef DEBUG_CPU_FREQ\n\tstruct notifier_block freq_trans;\n\tint __percpu *new_freq;\n#endif\n\tunsigned int unit;\n\tstruct notifier_block pm_notifier;\n#if defined(CUSTOMER_HW20) && defined(WLANAUDIO)\n\tstruct wlanaudio_blacklist wlanaudio_blist[MAX_WLANAUDIO_BLACKLIST];\n\tbool is_wlanaudio_blist;\n#endif /* CUSTOMER_HW20 && WLANAUDIO */\n} dhd_info_t;\n\n#define DHDIF_FWDER(dhdif)      FALSE\n\n/* Flag to indicate if we should download firmware on driver load */\nuint dhd_download_fw_on_driverload = TRUE;\n\n/* Definitions to provide path to the firmware and nvram\n * example nvram_path[MOD_PARAM_PATHLEN]=\"/projects/wlan/nvram.txt\"\n */\nchar firmware_path[MOD_PARAM_PATHLEN];\nchar nvram_path[MOD_PARAM_PATHLEN];\nchar config_path[MOD_PARAM_PATHLEN];\n\n/* backup buffer for firmware and nvram path */\nchar fw_bak_path[MOD_PARAM_PATHLEN];\nchar nv_bak_path[MOD_PARAM_PATHLEN];\n\n/* information string to keep firmware, chio, cheip version info visiable from log */\nchar info_string[MOD_PARAM_INFOLEN];\nmodule_param_string(info_string, info_string, MOD_PARAM_INFOLEN, 0444);\nint op_mode = 0;\nint disable_proptx = 0;\nmodule_param(op_mode, int, 0644);\nextern int wl_control_wl_start(struct net_device *dev);\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(BCMLXSDMMC)\nstruct semaphore dhd_registration_sem;\n#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */\n\n/* deferred handlers */\nstatic void dhd_ifadd_event_handler(void *handle, void *event_info, u8 event);\nstatic void dhd_ifdel_event_handler(void *handle, void *event_info, u8 event);\nstatic void dhd_set_mac_addr_handler(void *handle, void *event_info, u8 event);\nstatic void dhd_set_mcast_list_handler(void *handle, void *event_info, u8 event);\n#ifdef CONFIG_IPV6\nstatic void dhd_inet6_work_handler(void *dhd_info, void *event_data, u8 event);\n#endif\n\n#ifdef WL_CFG80211\nextern void dhd_netdev_free(struct net_device *ndev);\n#endif /* WL_CFG80211 */\n\n/* Error bits */\nmodule_param(dhd_msg_level, int, 0);\n#if defined(WL_WIRELESS_EXT)\nmodule_param(iw_msg_level, int, 0);\n#endif\n#ifdef WL_CFG80211\nmodule_param(wl_dbg_level, int, 0);\n#endif\nmodule_param(android_msg_level, int, 0);\nmodule_param(config_msg_level, int, 0);\n\n#ifdef ARP_OFFLOAD_SUPPORT\n/* ARP offload enable */\nuint dhd_arp_enable = TRUE;\nmodule_param(dhd_arp_enable, uint, 0);\n\n/* ARP offload agent mode : Enable ARP Host Auto-Reply and ARP Peer Auto-Reply */\n\nuint dhd_arp_mode = ARP_OL_AGENT | ARP_OL_PEER_AUTO_REPLY;\n\nmodule_param(dhd_arp_mode, uint, 0);\n#endif /* ARP_OFFLOAD_SUPPORT */\n\n/* Disable Prop tx */\nmodule_param(disable_proptx, int, 0644);\n/* load firmware and/or nvram values from the filesystem */\nmodule_param_string(firmware_path, firmware_path, MOD_PARAM_PATHLEN, 0660);\nmodule_param_string(nvram_path, nvram_path, MOD_PARAM_PATHLEN, 0660);\nmodule_param_string(config_path, config_path, MOD_PARAM_PATHLEN, 0);\n\n/* Watchdog interval */\n\n/* extend watchdog expiration to 2 seconds when DPC is running */\n#define WATCHDOG_EXTEND_INTERVAL (2000)\n\nuint dhd_watchdog_ms = CUSTOM_DHD_WATCHDOG_MS;\nmodule_param(dhd_watchdog_ms, uint, 0);\n\n#if defined(DHD_DEBUG)\n/* Console poll interval */\nuint dhd_console_ms = 0;\nmodule_param(dhd_console_ms, uint, 0644);\n#endif /* defined(DHD_DEBUG) */\n\n\nuint dhd_slpauto = TRUE;\nmodule_param(dhd_slpauto, uint, 0);\n\n#ifdef PKT_FILTER_SUPPORT\n/* Global Pkt filter enable control */\nuint dhd_pkt_filter_enable = TRUE;\nmodule_param(dhd_pkt_filter_enable, uint, 0);\n#endif\n\n/* Pkt filter init setup */\nuint dhd_pkt_filter_init = 0;\nmodule_param(dhd_pkt_filter_init, uint, 0);\n\n/* Pkt filter mode control */\nuint dhd_master_mode = FALSE;\nmodule_param(dhd_master_mode, uint, 0);\n\nint dhd_watchdog_prio = 0;\nmodule_param(dhd_watchdog_prio, int, 0);\n\n/* DPC thread priority */\nint dhd_dpc_prio = CUSTOM_DPC_PRIO_SETTING;\nmodule_param(dhd_dpc_prio, int, 0);\n\n/* RX frame thread priority */\nint dhd_rxf_prio = CUSTOM_RXF_PRIO_SETTING;\nmodule_param(dhd_rxf_prio, int, 0);\n\nint passive_channel_skip = 0;\nmodule_param(passive_channel_skip, int, (S_IRUSR|S_IWUSR));\n\n#if !defined(BCMDHDUSB)\nextern int dhd_dongle_ramsize;\nmodule_param(dhd_dongle_ramsize, int, 0);\n#endif /* BCMDHDUSB */\n\n/* Keep track of number of instances */\nstatic int dhd_found = 0;\nstatic int instance_base = 0; /* Starting instance number */\nmodule_param(instance_base, int, 0644);\n\n#if defined(CUSTOMER_HW20) && defined(WLANAUDIO)\ndhd_info_t *dhd_global = NULL;\n#endif /* CUSTOMER_HW20 && WLANAUDIO */\n\n\n\n/* DHD Perimiter lock only used in router with bypass forwarding. */\n#define DHD_PERIM_RADIO_INIT()              do { /* noop */ } while (0)\n#define DHD_PERIM_LOCK_TRY(unit, flag)      do { /* noop */ } while (0)\n#define DHD_PERIM_UNLOCK_TRY(unit, flag)    do { /* noop */ } while (0)\n#define DHD_PERIM_LOCK_ALL()                do { /* noop */ } while (0)\n#define DHD_PERIM_UNLOCK_ALL()              do { /* noop */ } while (0)\n\n#ifdef PCIE_FULL_DONGLE\n#if defined(BCM_GMAC3)\n#define DHD_IF_STA_LIST_LOCK_INIT(ifp)      do { /* noop */ } while (0)\n#define DHD_IF_STA_LIST_LOCK(ifp, flags)    ({ BCM_REFERENCE(flags); })\n#define DHD_IF_STA_LIST_UNLOCK(ifp, flags)  ({ BCM_REFERENCE(flags); })\n#else /* ! BCM_GMAC3 */\n#define DHD_IF_STA_LIST_LOCK_INIT(ifp) spin_lock_init(&(ifp)->sta_list_lock)\n#define DHD_IF_STA_LIST_LOCK(ifp, flags) \\\n\tspin_lock_irqsave(&(ifp)->sta_list_lock, (flags))\n#define DHD_IF_STA_LIST_UNLOCK(ifp, flags) \\\n\tspin_unlock_irqrestore(&(ifp)->sta_list_lock, (flags))\n#endif /* ! BCM_GMAC3 */\n#endif /* PCIE_FULL_DONGLE */\n\n/* Control fw roaming */\n#ifdef BCMCCX\nuint dhd_roam_disable = 0;\n#else\nuint dhd_roam_disable = 0;\n#endif /* BCMCCX */\n\n/* Control radio state */\nuint dhd_radio_up = 1;\n\n/* Network inteface name */\nchar iface_name[IFNAMSIZ] = {'\\0'};\nmodule_param_string(iface_name, iface_name, IFNAMSIZ, 0);\n\n/* The following are specific to the SDIO dongle */\n\n/* IOCTL response timeout */\nint dhd_ioctl_timeout_msec = IOCTL_RESP_TIMEOUT;\n\n/* Idle timeout for backplane clock */\nint dhd_idletime = DHD_IDLETIME_TICKS;\nmodule_param(dhd_idletime, int, 0);\n\n/* Use polling */\nuint dhd_poll = FALSE;\nmodule_param(dhd_poll, uint, 0);\n\n/* Use interrupts */\nuint dhd_intr = TRUE;\nmodule_param(dhd_intr, uint, 0);\n\n/* SDIO Drive Strength (in milliamps) */\nuint dhd_sdiod_drive_strength = 6;\nmodule_param(dhd_sdiod_drive_strength, uint, 0);\n\n#ifdef BCMSDIO\n/* Tx/Rx bounds */\nextern uint dhd_txbound;\nextern uint dhd_rxbound;\nmodule_param(dhd_txbound, uint, 0);\nmodule_param(dhd_rxbound, uint, 0);\n\n/* Deferred transmits */\nextern uint dhd_deferred_tx;\nmodule_param(dhd_deferred_tx, uint, 0);\n\n#ifdef BCMDBGFS\nextern void dhd_dbg_init(dhd_pub_t *dhdp);\nextern void dhd_dbg_remove(void);\n#endif /* BCMDBGFS */\n\n#endif /* BCMSDIO */\n\n\n#ifdef SDTEST\n/* Echo packet generator (pkts/s) */\nuint dhd_pktgen = 0;\nmodule_param(dhd_pktgen, uint, 0);\n\n/* Echo packet len (0 => sawtooth, max 2040) */\nuint dhd_pktgen_len = 0;\nmodule_param(dhd_pktgen_len, uint, 0);\n#endif /* SDTEST */\n\n#if defined(BCMSUP_4WAY_HANDSHAKE)\n/* Use in dongle supplicant for 4-way handshake */\nuint dhd_use_idsup = 0;\nmodule_param(dhd_use_idsup, uint, 0);\n#endif /* BCMSUP_4WAY_HANDSHAKE */\n\nextern char dhd_version[];\n\nint dhd_net_bus_devreset(struct net_device *dev, uint8 flag);\nstatic void dhd_net_if_lock_local(dhd_info_t *dhd);\nstatic void dhd_net_if_unlock_local(dhd_info_t *dhd);\nstatic void dhd_suspend_lock(dhd_pub_t *dhdp);\nstatic void dhd_suspend_unlock(dhd_pub_t *dhdp);\n\n#ifdef WLMEDIA_HTSF\nvoid htsf_update(dhd_info_t *dhd, void *data);\ntsf_t prev_tsf, cur_tsf;\n\nuint32 dhd_get_htsf(dhd_info_t *dhd, int ifidx);\nstatic int dhd_ioctl_htsf_get(dhd_info_t *dhd, int ifidx);\nstatic void dhd_dump_latency(void);\nstatic void dhd_htsf_addtxts(dhd_pub_t *dhdp, void *pktbuf);\nstatic void dhd_htsf_addrxts(dhd_pub_t *dhdp, void *pktbuf);\nstatic void dhd_dump_htsfhisto(histo_t *his, char *s);\n#endif /* WLMEDIA_HTSF */\n\n/* Monitor interface */\nint dhd_monitor_init(void *dhd_pub);\nint dhd_monitor_uninit(void);\n\n// Added by ddanggzi\nstruct net_device *gNet;\nint dhd_open(struct net_device *net);\n\n#if defined(WL_WIRELESS_EXT)\nstruct iw_statistics *dhd_get_wireless_stats(struct net_device *dev);\n#endif /* defined(WL_WIRELESS_EXT) */\n\nstatic void dhd_dpc(ulong data);\n/* forward decl */\nextern int dhd_wait_pend8021x(struct net_device *dev);\nvoid dhd_os_wd_timer_extend(void *bus, bool extend);\n\n#ifdef TOE\n#ifndef BDC\n#error TOE requires BDC\n#endif /* !BDC */\nstatic int dhd_toe_get(dhd_info_t *dhd, int idx, uint32 *toe_ol);\nstatic int dhd_toe_set(dhd_info_t *dhd, int idx, uint32 toe_ol);\n#endif /* TOE */\n\nstatic int dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,\n                             wl_event_msg_t *event_ptr, void **data_ptr);\n#ifdef DHD_UNICAST_DHCP\nstatic const uint8 llc_snap_hdr[SNAP_HDR_LEN] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};\nstatic int dhd_get_pkt_ip_type(dhd_pub_t *dhd, void *skb, uint8 **data_ptr,\n\tint *len_ptr, uint8 *prot_ptr);\nstatic int dhd_get_pkt_ether_type(dhd_pub_t *dhd, void *skb, uint8 **data_ptr,\n\tint *len_ptr, uint16 *et_ptr, bool *snap_ptr);\n\nstatic int dhd_convert_dhcp_broadcast_ack_to_unicast(dhd_pub_t *pub, void *pktbuf, int ifidx);\n#endif /* DHD_UNICAST_DHCP */\n#ifdef DHD_L2_FILTER\nstatic int dhd_l2_filter_block_ping(dhd_pub_t *pub, void *pktbuf, int ifidx);\n#endif\n#if defined(CONFIG_PM_SLEEP)\nstatic int dhd_pm_callback(struct notifier_block *nfb, unsigned long action, void *ignored)\n{\n\tint ret = NOTIFY_DONE;\n\tbool suspend = FALSE;\n\tdhd_info_t *dhdinfo = (dhd_info_t*)container_of(nfb, struct dhd_info, pm_notifier);\n\n\tBCM_REFERENCE(dhdinfo);\n\tswitch (action) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\tsuspend = TRUE;\n\t\tbreak;\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_SUSPEND:\n\t\tsuspend = FALSE;\n\t\tbreak;\n\t}\n\n#if defined(SUPPORT_P2P_GO_PS)\n#ifdef PROP_TXSTATUS\n\tif (suspend) {\n\t\tDHD_OS_WAKE_LOCK_WAIVE(&dhdinfo->pub);\n\t\tdhd_wlfc_suspend(&dhdinfo->pub);\n\t\tDHD_OS_WAKE_LOCK_RESTORE(&dhdinfo->pub);\n\t} else\n\t\tdhd_wlfc_resume(&dhdinfo->pub);\n#endif\n#endif /* defined(SUPPORT_P2P_GO_PS) */\n\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && (LINUX_VERSION_CODE <= \\\n\tKERNEL_VERSION(2, 6, 39))\n\tdhd_mmc_suspend = suspend;\n\tsmp_mb();\n#endif\n\n\treturn ret;\n}\n\nstatic struct notifier_block dhd_pm_notifier = {\n\t.notifier_call = dhd_pm_callback,\n\t.priority = 10\n};\n/* to make sure we won't register the same notifier twice, otherwise a loop is likely to be\n * created in kernel notifier link list (with 'next' pointing to itself)\n */\nstatic bool dhd_pm_notifier_registered = FALSE;\n\nextern int register_pm_notifier(struct notifier_block *nb);\nextern int unregister_pm_notifier(struct notifier_block *nb);\n#endif /* CONFIG_PM_SLEEP */\n\n/* Request scheduling of the bus rx frame */\nstatic void dhd_sched_rxf(dhd_pub_t *dhdp, void *skb);\nstatic void dhd_os_rxflock(dhd_pub_t *pub);\nstatic void dhd_os_rxfunlock(dhd_pub_t *pub);\n\n/** priv_link is the link between netdev and the dhdif and dhd_info structs. */\ntypedef struct dhd_dev_priv {\n\tdhd_info_t * dhd; /* cached pointer to dhd_info in netdevice priv */\n\tdhd_if_t   * ifp; /* cached pointer to dhd_if in netdevice priv */\n\tint          ifidx; /* interface index */\n} dhd_dev_priv_t;\n\n#define DHD_DEV_PRIV_SIZE       (sizeof(dhd_dev_priv_t))\n#define DHD_DEV_PRIV(dev)       ((dhd_dev_priv_t *)DEV_PRIV(dev))\n#define DHD_DEV_INFO(dev)       (((dhd_dev_priv_t *)DEV_PRIV(dev))->dhd)\n#define DHD_DEV_IFP(dev)        (((dhd_dev_priv_t *)DEV_PRIV(dev))->ifp)\n#define DHD_DEV_IFIDX(dev)      (((dhd_dev_priv_t *)DEV_PRIV(dev))->ifidx)\n\n/** Clear the dhd net_device's private structure. */\nstatic inline void\ndhd_dev_priv_clear(struct net_device * dev)\n{\n\tdhd_dev_priv_t * dev_priv;\n\tASSERT(dev != (struct net_device *)NULL);\n\tdev_priv = DHD_DEV_PRIV(dev);\n\tdev_priv->dhd = (dhd_info_t *)NULL;\n\tdev_priv->ifp = (dhd_if_t *)NULL;\n\tdev_priv->ifidx = DHD_BAD_IF;\n}\n\n/** Setup the dhd net_device's private structure. */\nstatic inline void\ndhd_dev_priv_save(struct net_device * dev, dhd_info_t * dhd, dhd_if_t * ifp,\n                  int ifidx)\n{\n\tdhd_dev_priv_t * dev_priv;\n\tASSERT(dev != (struct net_device *)NULL);\n\tdev_priv = DHD_DEV_PRIV(dev);\n\tdev_priv->dhd = dhd;\n\tdev_priv->ifp = ifp;\n\tdev_priv->ifidx = ifidx;\n}\n\n#ifdef PCIE_FULL_DONGLE\n\n/** Dummy objects are defined with state representing bad|down.\n * Performance gains from reducing branch conditionals, instruction parallelism,\n * dual issue, reducing load shadows, avail of larger pipelines.\n * Use DHD_XXX_NULL instead of (dhd_xxx_t *)NULL, whenever an object pointer\n * is accessed via the dhd_sta_t.\n */\n\n/* Dummy dhd_info object */\ndhd_info_t dhd_info_null = {\n#if defined(BCM_GMAC3)\n\t.fwdh = FWDER_NULL,\n#endif\n\t.pub = {\n\t         .info = &dhd_info_null,\n#ifdef DHDTCPACK_SUPPRESS\n\t         .tcpack_sup_mode = TCPACK_SUP_REPLACE,\n#endif /* DHDTCPACK_SUPPRESS */\n\t         .up = FALSE, .busstate = DHD_BUS_DOWN\n\t}\n};\n#define DHD_INFO_NULL (&dhd_info_null)\n#define DHD_PUB_NULL  (&dhd_info_null.pub)\n\n/* Dummy netdevice object */\nstruct net_device dhd_net_dev_null = {\n\t.reg_state = NETREG_UNREGISTERED\n};\n#define DHD_NET_DEV_NULL (&dhd_net_dev_null)\n\n/* Dummy dhd_if object */\ndhd_if_t dhd_if_null = {\n#if defined(BCM_GMAC3)\n\t.fwdh = FWDER_NULL,\n#endif\n#ifdef WMF\n\t.wmf = { .wmf_enable = TRUE },\n#endif\n\t.info = DHD_INFO_NULL,\n\t.net = DHD_NET_DEV_NULL,\n\t.idx = DHD_BAD_IF\n};\n#define DHD_IF_NULL  (&dhd_if_null)\n\n#define DHD_STA_NULL ((dhd_sta_t *)NULL)\n\n/** Interface STA list management. */\n\n/** Fetch the dhd_if object, given the interface index in the dhd. */\nstatic inline dhd_if_t *dhd_get_ifp(dhd_pub_t *dhdp, uint32 ifidx);\n\n/** Alloc/Free a dhd_sta object from the dhd instances' sta_pool. */\nstatic void dhd_sta_free(dhd_pub_t *pub, dhd_sta_t *sta);\nstatic dhd_sta_t * dhd_sta_alloc(dhd_pub_t * dhdp);\n\n/* Delete a dhd_sta or flush all dhd_sta in an interface's sta_list. */\nstatic void dhd_if_del_sta_list(dhd_if_t * ifp);\nstatic void\tdhd_if_flush_sta(dhd_if_t * ifp);\n\n/* Construct/Destruct a sta pool. */\nstatic int dhd_sta_pool_init(dhd_pub_t *dhdp, int max_sta);\nstatic void dhd_sta_pool_fini(dhd_pub_t *dhdp, int max_sta);\nstatic void dhd_sta_pool_clear(dhd_pub_t *dhdp, int max_sta);\n\n\n/* Return interface pointer */\nstatic inline dhd_if_t *dhd_get_ifp(dhd_pub_t *dhdp, uint32 ifidx)\n{\n\tASSERT(ifidx < DHD_MAX_IFS);\n\n\tif (ifidx >= DHD_MAX_IFS)\n\t\treturn NULL;\n\n\treturn dhdp->info->iflist[ifidx];\n}\n\n/** Reset a dhd_sta object and free into the dhd pool. */\nstatic void\ndhd_sta_free(dhd_pub_t * dhdp, dhd_sta_t * sta)\n{\n\tint prio;\n\n\tASSERT((sta != DHD_STA_NULL) && (sta->idx != ID16_INVALID));\n\n\tASSERT((dhdp->staid_allocator != NULL) && (dhdp->sta_pool != NULL));\n\tid16_map_free(dhdp->staid_allocator, sta->idx);\n\tfor (prio = 0; prio < (int)NUMPRIO; prio++)\n\t\tsta->flowid[prio] = FLOWID_INVALID;\n\tsta->ifp = DHD_IF_NULL; /* dummy dhd_if object */\n\tsta->ifidx = DHD_BAD_IF;\n\tbzero(sta->ea.octet, ETHER_ADDR_LEN);\n\tINIT_LIST_HEAD(&sta->list);\n\tsta->idx = ID16_INVALID; /* implying free */\n}\n\n/** Allocate a dhd_sta object from the dhd pool. */\nstatic dhd_sta_t *\ndhd_sta_alloc(dhd_pub_t * dhdp)\n{\n\tuint16 idx;\n\tdhd_sta_t * sta;\n\tdhd_sta_pool_t * sta_pool;\n\n\tASSERT((dhdp->staid_allocator != NULL) && (dhdp->sta_pool != NULL));\n\n\tidx = id16_map_alloc(dhdp->staid_allocator);\n\tif (idx == ID16_INVALID) {\n\t\tDHD_ERROR((\"%s: cannot get free staid\\n\", __FUNCTION__));\n\t\treturn DHD_STA_NULL;\n\t}\n\n\tsta_pool = (dhd_sta_pool_t *)(dhdp->sta_pool);\n\tsta = &sta_pool[idx];\n\n\tASSERT((sta->idx == ID16_INVALID) &&\n\t       (sta->ifp == DHD_IF_NULL) && (sta->ifidx == DHD_BAD_IF));\n\tsta->idx = idx; /* implying allocated */\n\n\treturn sta;\n}\n\n/** Delete all STAs in an interface's STA list. */\nstatic void\ndhd_if_del_sta_list(dhd_if_t *ifp)\n{\n\tdhd_sta_t *sta, *next;\n\tunsigned long flags;\n\n\tDHD_IF_STA_LIST_LOCK(ifp, flags);\n\n\tlist_for_each_entry_safe(sta, next, &ifp->sta_list, list) {\n#if defined(BCM_GMAC3)\n\t\tif (ifp->fwdh) {\n\t\t\t/* Remove sta from WOFA forwarder. */\n\t\t\tfwder_deassoc(ifp->fwdh, (uint16 *)(sta->ea.octet), (wofa_t)sta);\n\t\t}\n#endif /* BCM_GMAC3 */\n\t\tlist_del(&sta->list);\n\t\tdhd_sta_free(&ifp->info->pub, sta);\n\t}\n\n\tDHD_IF_STA_LIST_UNLOCK(ifp, flags);\n\n\treturn;\n}\n\n/** Router/GMAC3: Flush all station entries in the forwarder's WOFA database. */\nstatic void\ndhd_if_flush_sta(dhd_if_t * ifp)\n{\n#if defined(BCM_GMAC3)\n\n\tif (ifp && (ifp->fwdh != FWDER_NULL)) {\n\t\tdhd_sta_t *sta, *next;\n\t\tunsigned long flags;\n\n\t\tDHD_IF_STA_LIST_LOCK(ifp, flags);\n\n\t\tlist_for_each_entry_safe(sta, next, &ifp->sta_list, list) {\n\t\t\t/* Remove any sta entry from WOFA forwarder. */\n\t\t\tfwder_flush(ifp->fwdh, (wofa_t)sta);\n\t\t}\n\n\t\tDHD_IF_STA_LIST_UNLOCK(ifp, flags);\n\t}\n#endif /* BCM_GMAC3 */\n}\n\n/** Construct a pool of dhd_sta_t objects to be used by interfaces. */\nstatic int\ndhd_sta_pool_init(dhd_pub_t *dhdp, int max_sta)\n{\n\tint idx, sta_pool_memsz;\n\tdhd_sta_t * sta;\n\tdhd_sta_pool_t * sta_pool;\n\tvoid * staid_allocator;\n\n\tASSERT(dhdp != (dhd_pub_t *)NULL);\n\tASSERT((dhdp->staid_allocator == NULL) && (dhdp->sta_pool == NULL));\n\n\t/* dhd_sta objects per radio are managed in a table. id#0 reserved. */\n\tstaid_allocator = id16_map_init(dhdp->osh, max_sta, 1);\n\tif (staid_allocator == NULL) {\n\t\tDHD_ERROR((\"%s: sta id allocator init failure\\n\", __FUNCTION__));\n\t\treturn BCME_ERROR;\n\t}\n\n\t/* Pre allocate a pool of dhd_sta objects (one extra). */\n\tsta_pool_memsz = ((max_sta + 1) * sizeof(dhd_sta_t)); /* skip idx 0 */\n\tsta_pool = (dhd_sta_pool_t *)MALLOC(dhdp->osh, sta_pool_memsz);\n\tif (sta_pool == NULL) {\n\t\tDHD_ERROR((\"%s: sta table alloc failure\\n\", __FUNCTION__));\n\t\tid16_map_fini(dhdp->osh, staid_allocator);\n\t\treturn BCME_ERROR;\n\t}\n\n\tdhdp->sta_pool = sta_pool;\n\tdhdp->staid_allocator = staid_allocator;\n\n\t/* Initialize all sta(s) for the pre-allocated free pool. */\n\tbzero((uchar *)sta_pool, sta_pool_memsz);\n\tfor (idx = max_sta; idx >= 1; idx--) { /* skip sta_pool[0] */\n\t\tsta = &sta_pool[idx];\n\t\tsta->idx = id16_map_alloc(staid_allocator);\n\t\tASSERT(sta->idx <= max_sta);\n\t}\n\t/* Now place them into the pre-allocated free pool. */\n\tfor (idx = 1; idx <= max_sta; idx++) {\n\t\tsta = &sta_pool[idx];\n\t\tdhd_sta_free(dhdp, sta);\n\t}\n\n\treturn BCME_OK;\n}\n\n/** Destruct the pool of dhd_sta_t objects.\n * Caller must ensure that no STA objects are currently associated with an if.\n */\nstatic void\ndhd_sta_pool_fini(dhd_pub_t *dhdp, int max_sta)\n{\n\tdhd_sta_pool_t * sta_pool = (dhd_sta_pool_t *)dhdp->sta_pool;\n\n\tif (sta_pool) {\n\t\tint idx;\n\t\tint sta_pool_memsz = ((max_sta + 1) * sizeof(dhd_sta_t));\n\t\tfor (idx = 1; idx <= max_sta; idx++) {\n\t\t\tASSERT(sta_pool[idx].ifp == DHD_IF_NULL);\n\t\t\tASSERT(sta_pool[idx].idx == ID16_INVALID);\n\t\t}\n\t\tMFREE(dhdp->osh, dhdp->sta_pool, sta_pool_memsz);\n\t\tdhdp->sta_pool = NULL;\n\t}\n\n\tid16_map_fini(dhdp->osh, dhdp->staid_allocator);\n\tdhdp->staid_allocator = NULL;\n}\n\n/* Clear the pool of dhd_sta_t objects for built-in type driver */\nstatic void\ndhd_sta_pool_clear(dhd_pub_t *dhdp, int max_sta)\n{\n\tint idx, sta_pool_memsz;\n\tdhd_sta_t * sta;\n\tdhd_sta_pool_t * sta_pool;\n\tvoid *staid_allocator;\n\n\tif (!dhdp) {\n\t\tDHD_ERROR((\"%s: dhdp is NULL\\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tsta_pool = (dhd_sta_pool_t *)dhdp->sta_pool;\n\tstaid_allocator = dhdp->staid_allocator;\n\n\tif (!sta_pool) {\n\t\tDHD_ERROR((\"%s: sta_pool is NULL\\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tif (!staid_allocator) {\n\t\tDHD_ERROR((\"%s: staid_allocator is NULL\\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\t/* clear free pool */\n\tsta_pool_memsz = ((max_sta + 1) * sizeof(dhd_sta_t));\n\tbzero((uchar *)sta_pool, sta_pool_memsz);\n\n\t/* dhd_sta objects per radio are managed in a table. id#0 reserved. */\n\tid16_map_clear(staid_allocator, max_sta, 1);\n\n\t/* Initialize all sta(s) for the pre-allocated free pool. */\n\tfor (idx = max_sta; idx >= 1; idx--) { /* skip sta_pool[0] */\n\t\tsta = &sta_pool[idx];\n\t\tsta->idx = id16_map_alloc(staid_allocator);\n\t\tASSERT(sta->idx <= max_sta);\n\t}\n\t/* Now place them into the pre-allocated free pool. */\n\tfor (idx = 1; idx <= max_sta; idx++) {\n\t\tsta = &sta_pool[idx];\n\t\tdhd_sta_free(dhdp, sta);\n\t}\n}\n\n/** Find STA with MAC address ea in an interface's STA list. */\ndhd_sta_t *\ndhd_find_sta(void *pub, int ifidx, void *ea)\n{\n\tdhd_sta_t *sta;\n\tdhd_if_t *ifp;\n\tunsigned long flags;\n\n\tASSERT(ea != NULL);\n\tifp = dhd_get_ifp((dhd_pub_t *)pub, ifidx);\n\tif (ifp == NULL)\n\t\treturn DHD_STA_NULL;\n\n\tDHD_IF_STA_LIST_LOCK(ifp, flags);\n\n\tlist_for_each_entry(sta, &ifp->sta_list, list) {\n\t\tif (!memcmp(sta->ea.octet, ea, ETHER_ADDR_LEN)) {\n\t\t\tDHD_IF_STA_LIST_UNLOCK(ifp, flags);\n\t\t\treturn sta;\n\t\t}\n\t}\n\n\tDHD_IF_STA_LIST_UNLOCK(ifp, flags);\n\n\treturn DHD_STA_NULL;\n}\n\n/** Add STA into the interface's STA list. */\ndhd_sta_t *\ndhd_add_sta(void *pub, int ifidx, void *ea)\n{\n\tdhd_sta_t *sta;\n\tdhd_if_t *ifp;\n\tunsigned long flags;\n\n\tASSERT(ea != NULL);\n\tifp = dhd_get_ifp((dhd_pub_t *)pub, ifidx);\n\tif (ifp == NULL)\n\t\treturn DHD_STA_NULL;\n\n\tsta = dhd_sta_alloc((dhd_pub_t *)pub);\n\tif (sta == DHD_STA_NULL) {\n\t\tDHD_ERROR((\"%s: Alloc failed\\n\", __FUNCTION__));\n\t\treturn DHD_STA_NULL;\n\t}\n\n\tmemcpy(sta->ea.octet, ea, ETHER_ADDR_LEN);\n\n\t/* link the sta and the dhd interface */\n\tsta->ifp = ifp;\n\tsta->ifidx = ifidx;\n\tINIT_LIST_HEAD(&sta->list);\n\n\tDHD_IF_STA_LIST_LOCK(ifp, flags);\n\n\tlist_add_tail(&sta->list, &ifp->sta_list);\n\n#if defined(BCM_GMAC3)\n\tif (ifp->fwdh) {\n\t\tASSERT(ISALIGNED(ea, 2));\n\t\t/* Add sta to WOFA forwarder. */\n\t\tfwder_reassoc(ifp->fwdh, (uint16 *)ea, (wofa_t)sta);\n\t}\n#endif /* BCM_GMAC3 */\n\n\tDHD_IF_STA_LIST_UNLOCK(ifp, flags);\n\n\treturn sta;\n}\n\n/** Delete STA from the interface's STA list. */\nvoid\ndhd_del_sta(void *pub, int ifidx, void *ea)\n{\n\tdhd_sta_t *sta, *next;\n\tdhd_if_t *ifp;\n\tunsigned long flags;\n\n\tASSERT(ea != NULL);\n\tifp = dhd_get_ifp((dhd_pub_t *)pub, ifidx);\n\tif (ifp == NULL)\n\t\treturn;\n\n\tDHD_IF_STA_LIST_LOCK(ifp, flags);\n\n\tlist_for_each_entry_safe(sta, next, &ifp->sta_list, list) {\n\t\tif (!memcmp(sta->ea.octet, ea, ETHER_ADDR_LEN)) {\n#if defined(BCM_GMAC3)\n\t\t\tif (ifp->fwdh) { /* Found a sta, remove from WOFA forwarder. */\n\t\t\t\tASSERT(ISALIGNED(ea, 2));\n\t\t\t\tfwder_deassoc(ifp->fwdh, (uint16 *)ea, (wofa_t)sta);\n\t\t\t}\n#endif /* BCM_GMAC3 */\n\t\t\tlist_del(&sta->list);\n\t\t\tdhd_sta_free(&ifp->info->pub, sta);\n\t\t}\n\t}\n\n\tDHD_IF_STA_LIST_UNLOCK(ifp, flags);\n\n\treturn;\n}\n\n/** Add STA if it doesn't exist. Not reentrant. */\ndhd_sta_t*\ndhd_findadd_sta(void *pub, int ifidx, void *ea)\n{\n\tdhd_sta_t *sta;\n\n\tsta = dhd_find_sta(pub, ifidx, ea);\n\n\tif (!sta) {\n\t\t/* Add entry */\n\t\tsta = dhd_add_sta(pub, ifidx, ea);\n\t}\n\n\treturn sta;\n}\n#else\nstatic inline void dhd_if_flush_sta(dhd_if_t * ifp) { }\nstatic inline void dhd_if_del_sta_list(dhd_if_t *ifp) {}\nstatic inline int dhd_sta_pool_init(dhd_pub_t *dhdp, int max_sta) { return BCME_OK; }\nstatic inline void dhd_sta_pool_fini(dhd_pub_t *dhdp, int max_sta) {}\nstatic inline void dhd_sta_pool_clear(dhd_pub_t *dhdp, int max_sta) {}\ndhd_sta_t *dhd_findadd_sta(void *pub, int ifidx, void *ea) { return NULL; }\nvoid dhd_del_sta(void *pub, int ifidx, void *ea) {}\n#endif /* PCIE_FULL_DONGLE */\n\n\n/* Returns dhd iflist index correspondig the the bssidx provided by apps */\nint dhd_bssidx2idx(dhd_pub_t *dhdp, uint32 bssidx)\n{\n\tdhd_if_t *ifp;\n\tdhd_info_t *dhd = dhdp->info;\n\tint i;\n\n\tASSERT(bssidx < DHD_MAX_IFS);\n\tASSERT(dhdp);\n\n\tfor (i = 0; i < DHD_MAX_IFS; i++) {\n\t\tifp = dhd->iflist[i];\n\t\tif (ifp && (ifp->bssidx == bssidx)) {\n\t\t\tDHD_TRACE((\"Index manipulated for %s from %d to %d\\n\",\n\t\t\t\tifp->name, bssidx, i));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic inline int dhd_rxf_enqueue(dhd_pub_t *dhdp, void* skb)\n{\n\tuint32 store_idx;\n\tuint32 sent_idx;\n\n\tif (!skb) {\n\t\tDHD_ERROR((\"dhd_rxf_enqueue: NULL skb!!!\\n\"));\n\t\treturn BCME_ERROR;\n\t}\n\n\tdhd_os_rxflock(dhdp);\n\tstore_idx = dhdp->store_idx;\n\tsent_idx = dhdp->sent_idx;\n\tif (dhdp->skbbuf[store_idx] != NULL) {\n\t\t/* Make sure the previous packets are processed */\n\t\tdhd_os_rxfunlock(dhdp);\n#ifdef RXF_DEQUEUE_ON_BUSY\n\t\tDHD_TRACE((\"dhd_rxf_enqueue: pktbuf not consumed %p, store idx %d sent idx %d\\n\",\n\t\t\tskb, store_idx, sent_idx));\n\t\treturn BCME_BUSY;\n#else /* RXF_DEQUEUE_ON_BUSY */\n\t\tDHD_ERROR((\"dhd_rxf_enqueue: pktbuf not consumed %p, store idx %d sent idx %d\\n\",\n\t\t\tskb, store_idx, sent_idx));\n\t\t/* removed msleep here, should use wait_event_timeout if we\n\t\t * want to give rx frame thread a chance to run\n\t\t */\n#if defined(WAIT_DEQUEUE)\n\t\tOSL_SLEEP(1);\n#endif\n\t\treturn BCME_ERROR;\n#endif /* RXF_DEQUEUE_ON_BUSY */\n\t}\n\tDHD_TRACE((\"dhd_rxf_enqueue: Store SKB %p. idx %d -> %d\\n\",\n\t\tskb, store_idx, (store_idx + 1) & (MAXSKBPEND - 1)));\n\tdhdp->skbbuf[store_idx] = skb;\n\tdhdp->store_idx = (store_idx + 1) & (MAXSKBPEND - 1);\n\tdhd_os_rxfunlock(dhdp);\n\n\treturn BCME_OK;\n}\n\nstatic inline void* dhd_rxf_dequeue(dhd_pub_t *dhdp)\n{\n\tuint32 store_idx;\n\tuint32 sent_idx;\n\tvoid *skb;\n\n\tdhd_os_rxflock(dhdp);\n\n\tstore_idx = dhdp->store_idx;\n\tsent_idx = dhdp->sent_idx;\n\tskb = dhdp->skbbuf[sent_idx];\n\n\tif (skb == NULL) {\n\t\tdhd_os_rxfunlock(dhdp);\n\t\tDHD_ERROR((\"dhd_rxf_dequeue: Dequeued packet is NULL, store idx %d sent idx %d\\n\",\n\t\t\tstore_idx, sent_idx));\n\t\treturn NULL;\n\t}\n\n\tdhdp->skbbuf[sent_idx] = NULL;\n\tdhdp->sent_idx = (sent_idx + 1) & (MAXSKBPEND - 1);\n\n\tDHD_TRACE((\"dhd_rxf_dequeue: netif_rx_ni(%p), sent idx %d\\n\",\n\t\tskb, sent_idx));\n\n\tdhd_os_rxfunlock(dhdp);\n\n\treturn skb;\n}\n\nint dhd_process_cid_mac(dhd_pub_t *dhdp, bool prepost)\n{\n#ifndef CUSTOMER_HW10\n\tdhd_info_t *dhd = (dhd_info_t *)dhdp->info;\n#endif /* !CUSTOMER_HW10 */\n\n\tif (prepost) { /* pre process */\n\t\tdhd_read_macaddr(dhd);\n\t} else { /* post process */\n\t\tdhd_write_macaddr(&dhd->pub.mac);\n\t}\n\n\treturn 0;\n}\n\n// terence 20160615: fix building error if ARP_OFFLOAD_SUPPORT removed\n#if defined(PKT_FILTER_SUPPORT) &&defined(ARP_OFFLOAD_SUPPORT) && !defined(GAN_LITE_NAT_KEEPALIVE_FILTER)\nstatic bool\n_turn_on_arp_filter(dhd_pub_t *dhd, int op_mode)\n{\n\tbool _apply = FALSE;\n\t/* In case of IBSS mode, apply arp pkt filter */\n\tif (op_mode & DHD_FLAG_IBSS_MODE) {\n\t\t_apply = TRUE;\n\t\tgoto exit;\n\t}\n\t/* In case of P2P GO or GC, apply pkt filter to pass arp pkt to host */\n\tif ((dhd->arp_version == 1) &&\n\t\t(op_mode & (DHD_FLAG_P2P_GC_MODE | DHD_FLAG_P2P_GO_MODE))) {\n\t\t_apply = TRUE;\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn _apply;\n}\n#endif /* PKT_FILTER_SUPPORT && !GAN_LITE_NAT_KEEPALIVE_FILTER */\n\n#if defined(CUSTOM_PLATFORM_NV_TEGRA)\n#ifdef PKT_FILTER_SUPPORT\nvoid\ndhd_set_packet_filter_mode(struct net_device *dev, char *command)\n{\n\tdhd_info_t *dhdi = *(dhd_info_t **)netdev_priv(dev);\n\n\tdhdi->pub.pkt_filter_mode = bcm_strtoul(command, &command, 0);\n}\n\nint\ndhd_set_packet_filter_ports(struct net_device *dev, char *command)\n{\n\tint i = 0, error = BCME_OK, count = 0, get_count = 0, action = 0;\n\tuint16 portnum = 0, *ports = NULL, get_ports[WL_PKT_FILTER_PORTS_MAX];\n\tdhd_info_t *dhdi = *(dhd_info_t **)netdev_priv(dev);\n\tdhd_pub_t *dhdp = &dhdi->pub;\n\tchar iovbuf[WLC_IOCTL_SMLEN];\n\n\t/* get action */\n\taction = bcm_strtoul(command, &command, 0);\n\tif (action > PKT_FILTER_PORTS_MAX)\n\t\treturn BCME_BADARG;\n\n\tif (action == PKT_FILTER_PORTS_LOOPBACK) {\n\t\t/* echo the loopback value if port filter is supported else error */\n\t\tbcm_mkiovar(\"cap\", NULL, 0, iovbuf, sizeof(iovbuf));\n\t\terror = dhd_wl_ioctl_cmd(dhdp, WLC_GET_VAR, iovbuf, sizeof(iovbuf), FALSE, 0);\n\t\tif (error < 0) {\n\t\t\tDHD_ERROR((\"%s: Get Capability failed (error=%d)\\n\", __FUNCTION__, error));\n\t\t\treturn error;\n\t\t}\n\n\t\tif (strstr(iovbuf, \"pktfltr2\"))\n\t\t\treturn bcm_strtoul(command, &command, 0);\n\t\telse {\n\t\t\tDHD_ERROR((\"%s: pktfltr2 is not supported\\n\", __FUNCTION__));\n\t\t\treturn BCME_UNSUPPORTED;\n\t\t}\n\t}\n\n\tif (action == PKT_FILTER_PORTS_CLEAR) {\n\t\t/* action 0 is clear all ports */\n\t\tdhdp->pkt_filter_ports_count = 0;\n\t\tbzero(dhdp->pkt_filter_ports, sizeof(dhdp->pkt_filter_ports));\n\t}\n\telse {\n\t\tportnum = bcm_strtoul(command, &command, 0);\n\t\tif (portnum == 0) {\n\t\t\t/* no ports to add or remove */\n\t\t\treturn BCME_BADARG;\n\t\t}\n\n\t\t/* get configured ports */\n\t\tcount = dhdp->pkt_filter_ports_count;\n\t\tports = dhdp->pkt_filter_ports;\n\n\t\tif (action == PKT_FILTER_PORTS_ADD) {\n\t\t\t/* action 1 is add ports */\n\n\t\t\t/* copy new ports */\n\t\t\twhile ((portnum != 0) && (count < WL_PKT_FILTER_PORTS_MAX)) {\n\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\t/* duplicate port */\n\t\t\t\t\tif (portnum == ports[i])\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (portnum != ports[i])\n\t\t\t\t\tports[count++] = portnum;\n\t\t\t\tportnum = bcm_strtoul(command, &command, 0);\n\t\t\t}\n\t\t} else if ((action == PKT_FILTER_PORTS_DEL) && (count > 0)) {\n\t\t\t/* action 2 is remove ports */\n\t\t\tbcopy(dhdp->pkt_filter_ports, get_ports, count * sizeof(uint16));\n\t\t\tget_count = count;\n\n\t\t\twhile (portnum != 0) {\n\t\t\t\tcount = 0;\n\t\t\t\tfor (i = 0; i < get_count; i++) {\n\t\t\t\t\tif (portnum != get_ports[i])\n\t\t\t\t\t\tports[count++] = get_ports[i];\n\t\t\t\t}\n\t\t\t\tget_count = count;\n\t\t\t\tbcopy(ports, get_ports, count * sizeof(uint16));\n\t\t\t\tportnum = bcm_strtoul(command, &command, 0);\n\t\t\t}\n\t\t}\n\t\tdhdp->pkt_filter_ports_count = count;\n\t}\n\treturn error;\n}\n\nstatic void\ndhd_enable_packet_filter_ports(dhd_pub_t *dhd, bool enable)\n{\n\tint error = 0;\n\twl_pkt_filter_ports_t *portlist = NULL;\n\tconst uint pkt_filter_ports_buf_len = sizeof(\"pkt_filter_ports\")\n\t\t+ WL_PKT_FILTER_PORTS_FIXED_LEN\t+ (WL_PKT_FILTER_PORTS_MAX * sizeof(uint16));\n\tchar pkt_filter_ports_buf[pkt_filter_ports_buf_len];\n\tchar iovbuf[pkt_filter_ports_buf_len];\n\n\tDHD_TRACE((\"%s: enable %d, in_suspend %d, mode %d, port count %d\\n\", __FUNCTION__,\n\t\tenable, dhd->in_suspend, dhd->pkt_filter_mode,\n\t\tdhd->pkt_filter_ports_count));\n\n\tbzero(pkt_filter_ports_buf, sizeof(pkt_filter_ports_buf));\n\tportlist = (wl_pkt_filter_ports_t*)pkt_filter_ports_buf;\n\tportlist->version = WL_PKT_FILTER_PORTS_VERSION;\n\tportlist->reserved = 0;\n\n\tif (enable) {\n\t\tif (!(dhd->pkt_filter_mode & PKT_FILTER_MODE_PORTS_ONLY))\n\t\t\treturn;\n\n\t\t/* enable port filter */\n\t\tdhd_master_mode |= PKT_FILTER_MODE_PORTS_ONLY;\n\t\tif (dhd->pkt_filter_mode & PKT_FILTER_MODE_FORWARD_ON_MATCH)\n\t\t\t/* whitelist mode: FORWARD_ON_MATCH */\n\t\t\tdhd_master_mode |= PKT_FILTER_MODE_FORWARD_ON_MATCH;\n\t\telse\n\t\t\t/* blacklist mode: DISCARD_ON_MATCH */\n\t\t\tdhd_master_mode &= ~PKT_FILTER_MODE_FORWARD_ON_MATCH;\n\n\t\tportlist->count = dhd->pkt_filter_ports_count;\n\t\tbcopy(dhd->pkt_filter_ports, portlist->ports,\n\t\t\tdhd->pkt_filter_ports_count * sizeof(uint16));\n\t} else {\n\t\t/* disable port filter */\n\t\tportlist->count = 0;\n\t\tdhd_master_mode &= ~PKT_FILTER_MODE_PORTS_ONLY;\n\t\tdhd_master_mode |= PKT_FILTER_MODE_FORWARD_ON_MATCH;\n\t}\n\n\tDHD_INFO((\"%s: update: mode %d, port count %d\\n\", __FUNCTION__, dhd_master_mode,\n\t\tportlist->count));\n\n\t/* update ports */\n\tbcm_mkiovar(\"pkt_filter_ports\",\n\t\t(char*)portlist,\n\t\t(WL_PKT_FILTER_PORTS_FIXED_LEN + (portlist->count * sizeof(uint16))),\n\t\tiovbuf, sizeof(iovbuf));\n\terror = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\tif (error < 0)\n\t\tDHD_ERROR((\"%s: set pkt_filter_ports failed %d\\n\", __FUNCTION__, error));\n\n\t/* update mode */\n\tbcm_mkiovar(\"pkt_filter_mode\", (char*)&dhd_master_mode,\n\t\tsizeof(dhd_master_mode), iovbuf, sizeof(iovbuf));\n\terror = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\tif (error < 0)\n\t\tDHD_ERROR((\"%s: set pkt_filter_mode failed %d\\n\", __FUNCTION__, error));\n\n\treturn;\n}\n#endif /* PKT_FILTER_SUPPORT */\n#endif /* defined(CUSTOM_PLATFORM_NV_TEGRA) */\n\nvoid dhd_set_packet_filter(dhd_pub_t *dhd)\n{\n#ifdef PKT_FILTER_SUPPORT\n\tint i;\n\n\tDHD_TRACE((\"%s: enter\\n\", __FUNCTION__));\n\tif (dhd_pkt_filter_enable) {\n\t\tfor (i = 0; i < dhd->pktfilter_count; i++) {\n\t\t\tdhd_pktfilter_offload_set(dhd, dhd->pktfilter[i]);\n\t\t}\n\t}\n#endif /* PKT_FILTER_SUPPORT */\n}\n\nvoid dhd_enable_packet_filter(int value, dhd_pub_t *dhd)\n{\n#ifdef PKT_FILTER_SUPPORT\n\tint i;\n\n\tDHD_TRACE((\"%s: enter, value = %d\\n\", __FUNCTION__, value));\n\n#if defined(CUSTOM_PLATFORM_NV_TEGRA)\n\tdhd_enable_packet_filter_ports(dhd, value);\n#endif /* defined(CUSTOM_PLATFORM_NV_TEGRA) */\n\n\t/* 1 - Enable packet filter, only allow unicast packet to send up */\n\t/* 0 - Disable packet filter */\n\tif (dhd_pkt_filter_enable && (!value ||\n\t\t(dhd_support_sta_mode(dhd) && !dhd->dhcp_in_progress)))\n\t{\n\t\tfor (i = 0; i < dhd->pktfilter_count; i++) {\n// terence 20160615: fix building error if ARP_OFFLOAD_SUPPORT removed\n#if defined(ARP_OFFLOAD_SUPPORT) && !defined(GAN_LITE_NAT_KEEPALIVE_FILTER)\n\t\t\tif (value && (i == DHD_ARP_FILTER_NUM) &&\n\t\t\t\t!_turn_on_arp_filter(dhd, dhd->op_mode)) {\n\t\t\t\tDHD_TRACE((\"Do not turn on ARP white list pkt filter:\"\n\t\t\t\t\t\"val %d, cnt %d, op_mode 0x%x\\n\",\n\t\t\t\t\tvalue, i, dhd->op_mode));\n\t\t\t\tcontinue;\n\t\t\t}\n#endif /* !GAN_LITE_NAT_KEEPALIVE_FILTER */\n\t\t\tdhd_pktfilter_offload_enable(dhd, dhd->pktfilter[i],\n\t\t\t\tvalue, dhd_master_mode);\n\t\t}\n\t}\n#endif /* PKT_FILTER_SUPPORT */\n}\n\nstatic int dhd_set_suspend(int value, dhd_pub_t *dhd)\n{\n#ifndef SUPPORT_PM2_ONLY\n\tint power_mode = PM_MAX;\n#endif /* SUPPORT_PM2_ONLY */\n\t/* wl_pkt_filter_enable_t\tenable_parm; */\n\tchar iovbuf[32];\n\tint bcn_li_dtim = 0; /* Default bcn_li_dtim in resume mode is 0 */\n\tuint roamvar = dhd->conf->roam_off_suspend;\n\tuint nd_ra_filter = 0;\n\tint ret = 0;\n\n\tif (!dhd)\n\t\treturn -ENODEV;\n\n\tDHD_TRACE((\"%s: enter, value = %d in_suspend=%d\\n\",\n\t\t__FUNCTION__, value, dhd->in_suspend));\n\n\tdhd_suspend_lock(dhd);\n\n#ifdef CUSTOM_SET_CPUCORE\n\tDHD_TRACE((\"%s set cpucore(suspend%d)\\n\", __FUNCTION__, value));\n\t/* set specific cpucore */\n\tdhd_set_cpucore(dhd, TRUE);\n#endif /* CUSTOM_SET_CPUCORE */\n#ifndef SUPPORT_PM2_ONLY\n\tif (dhd->conf->pm >= 0)\n\t\tpower_mode = dhd->conf->pm;\n#endif /* SUPPORT_PM2_ONLY */\n\tif (dhd->up) {\n\t\tif (value && dhd->in_suspend) {\n#ifdef PKT_FILTER_SUPPORT\n\t\t\tdhd->early_suspended = 1;\n#endif\n\t\t\t/* Kernel suspended */\n\t\t\tDHD_ERROR((\"%s: force extra Suspend setting\\n\", __FUNCTION__));\n\n#ifndef SUPPORT_PM2_ONLY\n\t\t\tdhd_wl_ioctl_cmd(dhd, WLC_SET_PM, (char *)&power_mode,\n\t\t\t\tsizeof(power_mode), TRUE, 0);\n#endif /* SUPPORT_PM2_ONLY */\n\n\t\t\t/* Enable packet filter, only allow unicast packet to send up */\n\t\t\tdhd_enable_packet_filter(1, dhd);\n\n\t\t\t/* If DTIM skip is set up as default, force it to wake\n\t\t\t * each third DTIM for better power savings.  Note that\n\t\t\t * one side effect is a chance to miss BC/MC packet.\n\t\t\t */\n\t\t\tbcn_li_dtim = dhd_get_suspend_bcn_li_dtim(dhd);\n\t\t\tbcm_mkiovar(\"bcn_li_dtim\", (char *)&bcn_li_dtim,\n\t\t\t\t4, iovbuf, sizeof(iovbuf));\n\t\t\tif (dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf),\n\t\t\t\tTRUE, 0) < 0)\n\t\t\t\t\tDHD_ERROR((\"%s: set dtim failed\\n\", __FUNCTION__));\n\n\t\t\t/* Disable firmware roaming during suspend */\n\t\t\tbcm_mkiovar(\"roam_off\", (char *)&roamvar, 4, iovbuf, sizeof(iovbuf));\n\t\t\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\t\t\tif (FW_SUPPORTED(dhd, ndoe)) {\n\t\t\t\t/* enable IPv6 RA filter in  firmware during suspend */\n\t\t\t\tnd_ra_filter = 1;\n\t\t\t\tbcm_mkiovar(\"nd_ra_filter_enable\", (char *)&nd_ra_filter, 4,\n\t\t\t\t\tiovbuf, sizeof(iovbuf));\n\t\t\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\t\t\t\tsizeof(iovbuf), TRUE, 0)) < 0)\n\t\t\t\t\tDHD_ERROR((\"failed to set nd_ra_filter (%d)\\n\",\n\t\t\t\t\t\tret));\n\t\t\t}\n\t\t} else {\n#ifdef PKT_FILTER_SUPPORT\n\t\t\tdhd->early_suspended = 0;\n#endif\n\t\t\t/* Kernel resumed  */\n\t\t\tDHD_ERROR((\"%s: Remove extra suspend setting\\n\", __FUNCTION__));\n\n#ifndef SUPPORT_PM2_ONLY\n\t\t\tpower_mode = PM_FAST;\n\t\t\tdhd_wl_ioctl_cmd(dhd, WLC_SET_PM, (char *)&power_mode,\n\t\t\t\tsizeof(power_mode), TRUE, 0);\n#endif /* SUPPORT_PM2_ONLY */\n#ifdef PKT_FILTER_SUPPORT\n\t\t\t/* disable pkt filter */\n\t\t\tdhd_enable_packet_filter(0, dhd);\n#endif /* PKT_FILTER_SUPPORT */\n\n\t\t\t/* restore pre-suspend setting for dtim_skip */\n\t\t\tbcm_mkiovar(\"bcn_li_dtim\", (char *)&bcn_li_dtim,\n\t\t\t\t4, iovbuf, sizeof(iovbuf));\n\n\t\t\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\t\t\troamvar = dhd_roam_disable;\n\t\t\tbcm_mkiovar(\"roam_off\", (char *)&roamvar, 4, iovbuf, sizeof(iovbuf));\n\t\t\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\t\t\tif (FW_SUPPORTED(dhd, ndoe)) {\n\t\t\t\t/* disable IPv6 RA filter in  firmware during suspend */\n\t\t\t\tnd_ra_filter = 0;\n\t\t\t\tbcm_mkiovar(\"nd_ra_filter_enable\", (char *)&nd_ra_filter, 4,\n\t\t\t\t\tiovbuf, sizeof(iovbuf));\n\t\t\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\t\t\t\tsizeof(iovbuf), TRUE, 0)) < 0)\n\t\t\t\t\tDHD_ERROR((\"failed to set nd_ra_filter (%d)\\n\",\n\t\t\t\t\t\tret));\n\t\t\t}\n\t\t}\n\t}\n\tdhd_suspend_unlock(dhd);\n\n\treturn 0;\n}\n\nstatic int dhd_suspend_resume_helper(struct dhd_info *dhd, int val, int force)\n{\n\tdhd_pub_t *dhdp = &dhd->pub;\n\tint ret = 0;\n    PM_DBGOUT(\"88888888------------------------------------------------5\\r\\n\");\n\tDHD_OS_WAKE_LOCK(dhdp);\n\tDHD_PERIM_LOCK(dhdp);\n\n\t/* Set flag when early suspend was called */\n\tdhdp->in_suspend = val;\n\tif ((force || !dhdp->suspend_disable_flag) &&\n\t\tdhd_support_sta_mode(dhdp))\n\t{\n\t\tret = dhd_set_suspend(val, dhdp);\n\t}\n\n\tDHD_PERIM_UNLOCK(dhdp);\n\tDHD_OS_WAKE_UNLOCK(dhdp);\n\treturn ret;\n}\n\n#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)\nstatic void dhd_early_suspend(struct early_suspend *h)\n{\n\tstruct dhd_info *dhd = container_of(h, struct dhd_info, early_suspend);\n\tDHD_TRACE_HW4((\"%s: enter\\n\", __FUNCTION__));\n\n\tif (dhd)\n\t\tdhd_suspend_resume_helper(dhd, 1, 0);\n}\n\nstatic void dhd_late_resume(struct early_suspend *h)\n{\n\tstruct dhd_info *dhd = container_of(h, struct dhd_info, early_suspend);\n\tDHD_TRACE_HW4((\"%s: enter\\n\", __FUNCTION__));\n    PM_DBGOUT(\"88888888------------------------------------------------6\\r\\n\");\n\tif (dhd)\n\t\tdhd_suspend_resume_helper(dhd, 0, 0);\n}\n#endif /* CONFIG_HAS_EARLYSUSPEND && DHD_USE_EARLYSUSPEND */\n\n/*\n * Generalized timeout mechanism.  Uses spin sleep with exponential back-off until\n * the sleep time reaches one jiffy, then switches over to task delay.  Usage:\n *\n *      dhd_timeout_start(&tmo, usec);\n *      while (!dhd_timeout_expired(&tmo))\n *              if (poll_something())\n *                      break;\n *      if (dhd_timeout_expired(&tmo))\n *              fatal();\n */\n\nvoid\ndhd_timeout_start(dhd_timeout_t *tmo, uint usec)\n{\n\ttmo->limit = usec;\n\ttmo->increment = 0;\n\ttmo->elapsed = 0;\n\ttmo->tick = jiffies_to_usecs(1);\n}\n\nint\ndhd_timeout_expired(dhd_timeout_t *tmo)\n{\n\t/* Does nothing the first call */\n\tif (tmo->increment == 0) {\n\t\ttmo->increment = 1;\n\t\treturn 0;\n\t}\n\n\tif (tmo->elapsed >= tmo->limit)\n\t\treturn 1;\n\n\t/* Add the delay that's about to take place */\n\ttmo->elapsed += tmo->increment;\n\n\tif ((!CAN_SLEEP()) || tmo->increment < tmo->tick) {\n\t\tOSL_DELAY(tmo->increment);\n\t\ttmo->increment *= 2;\n\t\tif (tmo->increment > tmo->tick)\n\t\t\ttmo->increment = tmo->tick;\n\t} else {\n\t\twait_queue_head_t delay_wait;\n\t\tDECLARE_WAITQUEUE(wait, current);\n\t\tinit_waitqueue_head(&delay_wait);\n\t\tadd_wait_queue(&delay_wait, &wait);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t(void)schedule_timeout(1);\n\t\tremove_wait_queue(&delay_wait, &wait);\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\treturn 0;\n}\n\nint\ndhd_net2idx(dhd_info_t *dhd, struct net_device *net)\n{\n\tint i = 0;\n\n\tif (!dhd) {\n\t\tDHD_ERROR((\"%s : DHD_BAD_IF return\\n\", __FUNCTION__));\n\t\treturn DHD_BAD_IF;\n\t}\n\twhile (i < DHD_MAX_IFS) {\n\t\tif (dhd->iflist[i] && dhd->iflist[i]->net && (dhd->iflist[i]->net == net))\n\t\t\treturn i;\n\t\ti++;\n\t}\n\n\treturn DHD_BAD_IF;\n}\n\nstruct net_device * dhd_idx2net(void *pub, int ifidx)\n{\n\tstruct dhd_pub *dhd_pub = (struct dhd_pub *)pub;\n\tstruct dhd_info *dhd_info;\n\n\tif (!dhd_pub || ifidx < 0 || ifidx >= DHD_MAX_IFS)\n\t\treturn NULL;\n\tdhd_info = dhd_pub->info;\n\tif (dhd_info && dhd_info->iflist[ifidx])\n\t\treturn dhd_info->iflist[ifidx]->net;\n\treturn NULL;\n}\n\nint\ndhd_ifname2idx(dhd_info_t *dhd, char *name)\n{\n\tint i = DHD_MAX_IFS;\n\n\tASSERT(dhd);\n\n\tif (name == NULL || *name == '\\0')\n\t\treturn 0;\n\n\twhile (--i > 0)\n\t\tif (dhd->iflist[i] && !strncmp(dhd->iflist[i]->name, name, IFNAMSIZ))\n\t\t\t\tbreak;\n\n\tDHD_TRACE((\"%s: return idx %d for \\\"%s\\\"\\n\", __FUNCTION__, i, name));\n\n\treturn i;\t/* default - the primary interface */\n}\n\nint\ndhd_ifidx2hostidx(dhd_info_t *dhd, int ifidx)\n{\n\tint i = DHD_MAX_IFS;\n\n\tASSERT(dhd);\n\n\twhile (--i > 0)\n\t\tif (dhd->iflist[i] && (dhd->iflist[i]->idx == ifidx))\n\t\t\t\tbreak;\n\n\tDHD_TRACE((\"%s: return hostidx %d for ifidx %d\\n\", __FUNCTION__, i, ifidx));\n\n\treturn i;\t/* default - the primary interface */\n}\n\nchar *\ndhd_ifname(dhd_pub_t *dhdp, int ifidx)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)dhdp->info;\n\n\tASSERT(dhd);\n\n\tif (ifidx < 0 || ifidx >= DHD_MAX_IFS) {\n\t\tDHD_ERROR((\"%s: ifidx %d out of range\\n\", __FUNCTION__, ifidx));\n\t\treturn \"<if_bad>\";\n\t}\n\n\tif (dhd->iflist[ifidx] == NULL) {\n\t\tDHD_ERROR((\"%s: null i/f %d\\n\", __FUNCTION__, ifidx));\n\t\treturn \"<if_null>\";\n\t}\n\n\tif (dhd->iflist[ifidx]->net)\n\t\treturn dhd->iflist[ifidx]->net->name;\n\n\treturn \"<if_none>\";\n}\n\nuint8 *\ndhd_bssidx2bssid(dhd_pub_t *dhdp, int idx)\n{\n\tint i;\n\tdhd_info_t *dhd = (dhd_info_t *)dhdp;\n\n\tASSERT(dhd);\n\tfor (i = 0; i < DHD_MAX_IFS; i++)\n\tif (dhd->iflist[i] && dhd->iflist[i]->bssidx == idx)\n\t\treturn dhd->iflist[i]->mac_addr;\n\n\treturn NULL;\n}\n\n\nstatic void\n_dhd_set_multicast_list(dhd_info_t *dhd, int ifidx)\n{\n\tstruct net_device *dev;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)\n\tstruct netdev_hw_addr *ha;\n#else\n\tstruct dev_mc_list *mclist;\n#endif\n\tuint32 allmulti, cnt;\n\n\twl_ioctl_t ioc;\n\tchar *buf, *bufp;\n\tuint buflen;\n\tint ret;\n\n\tASSERT(dhd && dhd->iflist[ifidx]);\n\tdev = dhd->iflist[ifidx]->net;\n\tif (!dev)\n\t\treturn;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)\n\tnetif_addr_lock_bh(dev);\n#endif\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)\n\tcnt = netdev_mc_count(dev);\n#else\n\tcnt = dev->mc_count;\n#endif /* LINUX_VERSION_CODE */\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)\n\tnetif_addr_unlock_bh(dev);\n#endif\n\n\t/* Determine initial value of allmulti flag */\n\tallmulti = (dev->flags & IFF_ALLMULTI) ? TRUE : FALSE;\n\n\t/* Send down the multicast list first. */\n\n\n\tbuflen = sizeof(\"mcast_list\") + sizeof(cnt) + (cnt * ETHER_ADDR_LEN);\n\tif (!(bufp = buf = MALLOC(dhd->pub.osh, buflen))) {\n\t\tDHD_ERROR((\"%s: out of memory for mcast_list, cnt %d\\n\",\n\t\t\tdhd_ifname(&dhd->pub, ifidx), cnt));\n\t\treturn;\n\t}\n\n\tstrncpy(bufp, \"mcast_list\", buflen - 1);\n\tbufp[buflen - 1] = '\\0';\n\tbufp += strlen(\"mcast_list\") + 1;\n\n\tcnt = htol32(cnt);\n\tmemcpy(bufp, &cnt, sizeof(cnt));\n\tbufp += sizeof(cnt);\n\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)\n\tnetif_addr_lock_bh(dev);\n#endif\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tif (!cnt)\n\t\t\tbreak;\n\t\tmemcpy(bufp, ha->addr, ETHER_ADDR_LEN);\n\t\tbufp += ETHER_ADDR_LEN;\n\t\tcnt--;\n\t}\n#else\n\tfor (mclist = dev->mc_list; (mclist && (cnt > 0));\n\t\t\tcnt--, mclist = mclist->next) {\n\t\tmemcpy(bufp, (void *)mclist->dmi_addr, ETHER_ADDR_LEN);\n\t\tbufp += ETHER_ADDR_LEN;\n\t}\n#endif /* LINUX_VERSION_CODE */\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)\n\tnetif_addr_unlock_bh(dev);\n#endif\n\n\tmemset(&ioc, 0, sizeof(ioc));\n\tioc.cmd = WLC_SET_VAR;\n\tioc.buf = buf;\n\tioc.len = buflen;\n\tioc.set = TRUE;\n\n\tret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);\n\tif (ret < 0) {\n\t\tDHD_ERROR((\"%s: set mcast_list failed, cnt %d\\n\",\n\t\t\tdhd_ifname(&dhd->pub, ifidx), cnt));\n\t\tallmulti = cnt ? TRUE : allmulti;\n\t}\n\n\tMFREE(dhd->pub.osh, buf, buflen);\n\n\t/* Now send the allmulti setting.  This is based on the setting in the\n\t * net_device flags, but might be modified above to be turned on if we\n\t * were trying to set some addresses and dongle rejected it...\n\t */\n\n\tbuflen = sizeof(\"allmulti\") + sizeof(allmulti);\n\tif (!(buf = MALLOC(dhd->pub.osh, buflen))) {\n\t\tDHD_ERROR((\"%s: out of memory for allmulti\\n\", dhd_ifname(&dhd->pub, ifidx)));\n\t\treturn;\n\t}\n\tallmulti = htol32(allmulti);\n\n\tif (!bcm_mkiovar(\"allmulti\", (void*)&allmulti, sizeof(allmulti), buf, buflen)) {\n\t\tDHD_ERROR((\"%s: mkiovar failed for allmulti, datalen %d buflen %u\\n\",\n\t\t           dhd_ifname(&dhd->pub, ifidx), (int)sizeof(allmulti), buflen));\n\t\tMFREE(dhd->pub.osh, buf, buflen);\n\t\treturn;\n\t}\n\n\n\tmemset(&ioc, 0, sizeof(ioc));\n\tioc.cmd = WLC_SET_VAR;\n\tioc.buf = buf;\n\tioc.len = buflen;\n\tioc.set = TRUE;\n\n\tret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);\n\tif (ret < 0) {\n\t\tDHD_ERROR((\"%s: set allmulti %d failed\\n\",\n\t\t           dhd_ifname(&dhd->pub, ifidx), ltoh32(allmulti)));\n\t}\n\n\tMFREE(dhd->pub.osh, buf, buflen);\n\n\t/* Finally, pick up the PROMISC flag as well, like the NIC driver does */\n\n\tallmulti = (dev->flags & IFF_PROMISC) ? TRUE : FALSE;\n\n\tallmulti = htol32(allmulti);\n\n\tmemset(&ioc, 0, sizeof(ioc));\n\tioc.cmd = WLC_SET_PROMISC;\n\tioc.buf = &allmulti;\n\tioc.len = sizeof(allmulti);\n\tioc.set = TRUE;\n\n\tret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);\n\tif (ret < 0) {\n\t\tDHD_ERROR((\"%s: set promisc %d failed\\n\",\n\t\t           dhd_ifname(&dhd->pub, ifidx), ltoh32(allmulti)));\n\t}\n}\n\nint\n_dhd_set_mac_address(dhd_info_t *dhd, int ifidx, uint8 *addr)\n{\n\tchar buf[32];\n\twl_ioctl_t ioc;\n\tint ret;\n\n\tif (!bcm_mkiovar(\"cur_etheraddr\", (char*)addr, ETHER_ADDR_LEN, buf, 32)) {\n\t\tDHD_ERROR((\"%s: mkiovar failed for cur_etheraddr\\n\", dhd_ifname(&dhd->pub, ifidx)));\n\t\treturn -1;\n\t}\n\tmemset(&ioc, 0, sizeof(ioc));\n\tioc.cmd = WLC_SET_VAR;\n\tioc.buf = buf;\n\tioc.len = 32;\n\tioc.set = TRUE;\n\n\tret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len);\n\tif (ret < 0) {\n\t\tDHD_ERROR((\"%s: set cur_etheraddr failed\\n\", dhd_ifname(&dhd->pub, ifidx)));\n\t} else {\n\t\tmemcpy(dhd->iflist[ifidx]->net->dev_addr, addr, ETHER_ADDR_LEN);\n\t\tif (ifidx == 0)\n\t\t\tmemcpy(dhd->pub.mac.octet, addr, ETHER_ADDR_LEN);\n\t}\n\n\treturn ret;\n}\n\n#ifdef SOFTAP\nextern struct net_device *ap_net_dev;\nextern tsk_ctl_t ap_eth_ctl; /* ap netdev heper thread ctl */\n#endif\n\nstatic void\ndhd_ifadd_event_handler(void *handle, void *event_info, u8 event)\n{\n\tdhd_info_t *dhd = handle;\n\tdhd_if_event_t *if_event = event_info;\n\tstruct net_device *ndev;\n\tint ifidx, bssidx;\n\tint ret;\n#if defined(WL_CFG80211) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0))\n\tstruct wireless_dev *vwdev, *primary_wdev;\n\tstruct net_device *primary_ndev;\n#endif /* OEM_ANDROID && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)) */\n\n\tif (event != DHD_WQ_WORK_IF_ADD) {\n\t\tDHD_ERROR((\"%s: unexpected event \\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tif (!dhd) {\n\t\tDHD_ERROR((\"%s: dhd info not available \\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tif (!if_event) {\n\t\tDHD_ERROR((\"%s: event data is null \\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tdhd_net_if_lock_local(dhd);\n\tDHD_OS_WAKE_LOCK(&dhd->pub);\n\tDHD_PERIM_LOCK(&dhd->pub);\n\n\tifidx = if_event->event.ifidx;\n\tbssidx = if_event->event.bssidx;\n\tDHD_TRACE((\"%s: registering if with ifidx %d\\n\", __FUNCTION__, ifidx));\n\n\tndev = dhd_allocate_if(&dhd->pub, ifidx, if_event->name,\n\t\tif_event->mac, bssidx, TRUE);\n\tif (!ndev) {\n\t\tDHD_ERROR((\"%s: net device alloc failed  \\n\", __FUNCTION__));\n\t\tgoto done;\n\t}\n\n#if defined(WL_CFG80211) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0))\n\tvwdev = kzalloc(sizeof(*vwdev), GFP_KERNEL);\n\tif (unlikely(!vwdev)) {\n\t\tWL_ERR((\"Could not allocate wireless device\\n\"));\n\t\tgoto done;\n\t}\n\tprimary_ndev = dhd->pub.info->iflist[0]->net;\n\tprimary_wdev = ndev_to_wdev(primary_ndev);\n\tvwdev->wiphy = primary_wdev->wiphy;\n\tvwdev->iftype = if_event->event.role;\n\tvwdev->netdev = ndev;\n\tndev->ieee80211_ptr = vwdev;\n\tSET_NETDEV_DEV(ndev, wiphy_dev(vwdev->wiphy));\n\tDHD_ERROR((\"virtual interface(%s) is created\\n\", if_event->name));\n#endif /* OEM_ANDROID && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)) */\n\n\tDHD_PERIM_UNLOCK(&dhd->pub);\n\tret = dhd_register_if(&dhd->pub, ifidx, TRUE);\n\tDHD_PERIM_LOCK(&dhd->pub);\n\tif (ret != BCME_OK) {\n\t\tDHD_ERROR((\"%s: dhd_register_if failed\\n\", __FUNCTION__));\n\t\tdhd_remove_if(&dhd->pub, ifidx, TRUE);\n\t\tgoto done;\n\t}\n#ifdef PCIE_FULL_DONGLE\n\t/* Turn on AP isolation in the firmware for interfaces operating in AP mode */\n\tif (FW_SUPPORTED((&dhd->pub), ap) && !(DHD_IF_ROLE_STA(if_event->event.role))) {\n\t\tchar iovbuf[WLC_IOCTL_SMLEN];\n\t\tuint32 var_int =  1;\n\n\t\tmemset(iovbuf, 0, sizeof(iovbuf));\n\t\tbcm_mkiovar(\"ap_isolate\", (char *)&var_int, 4, iovbuf, sizeof(iovbuf));\n\t\tret = dhd_wl_ioctl_cmd(&dhd->pub, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, ifidx);\n\n\t\tif (ret != BCME_OK) {\n\t\t\tDHD_ERROR((\"%s: Failed to set ap_isolate to dongle\\n\", __FUNCTION__));\n\t\t\tdhd_remove_if(&dhd->pub, ifidx, TRUE);\n\t\t}\n\t}\n#endif /* PCIE_FULL_DONGLE */\ndone:\n\tMFREE(dhd->pub.osh, if_event, sizeof(dhd_if_event_t));\n\n\tDHD_PERIM_UNLOCK(&dhd->pub);\n\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\tdhd_net_if_unlock_local(dhd);\n}\n\nstatic void\ndhd_ifdel_event_handler(void *handle, void *event_info, u8 event)\n{\n\tdhd_info_t *dhd = handle;\n\tint ifidx;\n\tdhd_if_event_t *if_event = event_info;\n\n\n\tif (event != DHD_WQ_WORK_IF_DEL) {\n\t\tDHD_ERROR((\"%s: unexpected event \\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tif (!dhd) {\n\t\tDHD_ERROR((\"%s: dhd info not available \\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tif (!if_event) {\n\t\tDHD_ERROR((\"%s: event data is null \\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tdhd_net_if_lock_local(dhd);\n\tDHD_OS_WAKE_LOCK(&dhd->pub);\n\tDHD_PERIM_LOCK(&dhd->pub);\n\n\tifidx = if_event->event.ifidx;\n\tDHD_TRACE((\"Removing interface with idx %d\\n\", ifidx));\n\n\tdhd_remove_if(&dhd->pub, ifidx, TRUE);\n\n\tMFREE(dhd->pub.osh, if_event, sizeof(dhd_if_event_t));\n\n\tDHD_PERIM_UNLOCK(&dhd->pub);\n\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\tdhd_net_if_unlock_local(dhd);\n}\n\nstatic void\ndhd_set_mac_addr_handler(void *handle, void *event_info, u8 event)\n{\n\tdhd_info_t *dhd = handle;\n\tdhd_if_t *ifp = event_info;\n\n\tif (event != DHD_WQ_WORK_SET_MAC) {\n\t\tDHD_ERROR((\"%s: unexpected event \\n\", __FUNCTION__));\n\t}\n\n\tif (!dhd) {\n\t\tDHD_ERROR((\"%s: dhd info not available \\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tdhd_net_if_lock_local(dhd);\n\tDHD_OS_WAKE_LOCK(&dhd->pub);\n\tDHD_PERIM_LOCK(&dhd->pub);\n\n#ifdef SOFTAP\n\t{\n\t\tunsigned long flags;\n\t\tbool in_ap = FALSE;\n\t\tDHD_GENERAL_LOCK(&dhd->pub, flags);\n\t\tin_ap = (ap_net_dev != NULL);\n\t\tDHD_GENERAL_UNLOCK(&dhd->pub, flags);\n\n\t\tif (in_ap)  {\n\t\t\tDHD_ERROR((\"attempt to set MAC for %s in AP Mode, blocked. \\n\",\n\t\t\t           ifp->net->name));\n\t\t\tgoto done;\n\t\t}\n\t}\n#endif /* SOFTAP */\n\n\t// terence 20160907: fix for not able to set mac when wlan0 is down\n\tif (ifp == NULL || !ifp->set_macaddress) {\n\t\tgoto done;\n\t}\n\tif (ifp == NULL || !dhd->pub.up) {\n\t\tDHD_ERROR((\"%s: interface info not available/down \\n\", __FUNCTION__));\n\t\tgoto done;\n\t}\n\n\tDHD_ERROR((\"%s: MACID is overwritten\\n\", __FUNCTION__));\n\tifp->set_macaddress = FALSE;\n\tif (_dhd_set_mac_address(dhd, ifp->idx, ifp->mac_addr) == 0)\n\t\tDHD_INFO((\"%s: MACID is overwritten\\n\",\t__FUNCTION__));\n\telse\n\t\tDHD_ERROR((\"%s: _dhd_set_mac_address() failed\\n\", __FUNCTION__));\n\ndone:\n\tDHD_PERIM_UNLOCK(&dhd->pub);\n\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\tdhd_net_if_unlock_local(dhd);\n}\n\nstatic void\ndhd_set_mcast_list_handler(void *handle, void *event_info, u8 event)\n{\n\tdhd_info_t *dhd = handle;\n\tdhd_if_t *ifp = event_info;\n\tint ifidx;\n\n\tif (event != DHD_WQ_WORK_SET_MCAST_LIST) {\n\t\tDHD_ERROR((\"%s: unexpected event \\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tif (!dhd) {\n\t\tDHD_ERROR((\"%s: dhd info not available \\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tdhd_net_if_lock_local(dhd);\n\tDHD_OS_WAKE_LOCK(&dhd->pub);\n\tDHD_PERIM_LOCK(&dhd->pub);\n\n#ifdef SOFTAP\n\t{\n\t\tbool in_ap = FALSE;\n\t\tunsigned long flags;\n\t\tDHD_GENERAL_LOCK(&dhd->pub, flags);\n\t\tin_ap = (ap_net_dev != NULL);\n\t\tDHD_GENERAL_UNLOCK(&dhd->pub, flags);\n\n\t\tif (in_ap)  {\n\t\t\tDHD_ERROR((\"set MULTICAST list for %s in AP Mode, blocked. \\n\",\n\t\t\t           ifp->net->name));\n\t\t\tifp->set_multicast = FALSE;\n\t\t\tgoto done;\n\t\t}\n\t}\n#endif /* SOFTAP */\n\n\tif (ifp == NULL || !dhd->pub.up) {\n\t\tDHD_ERROR((\"%s: interface info not available/down \\n\", __FUNCTION__));\n\t\tgoto done;\n\t}\n\n\tifidx = ifp->idx;\n\n\n\t_dhd_set_multicast_list(dhd, ifidx);\n\tDHD_INFO((\"%s: set multicast list for if %d\\n\", __FUNCTION__, ifidx));\n\ndone:\n\tDHD_PERIM_UNLOCK(&dhd->pub);\n\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\tdhd_net_if_unlock_local(dhd);\n}\n\nstatic int\ndhd_set_mac_address(struct net_device *dev, void *addr)\n{\n\tint ret = 0;\n\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tstruct sockaddr *sa = (struct sockaddr *)addr;\n\tint ifidx;\n\tdhd_if_t *dhdif;\n\n\tifidx = dhd_net2idx(dhd, dev);\n\tif (ifidx == DHD_BAD_IF)\n\t\treturn -1;\n\n\tdhdif = dhd->iflist[ifidx];\n\n\tdhd_net_if_lock_local(dhd);\n\tmemcpy(dhdif->mac_addr, sa->sa_data, ETHER_ADDR_LEN);\n\tdhdif->set_macaddress = TRUE;\n\tdhd_net_if_unlock_local(dhd);\n\tdhd_deferred_schedule_work(dhd->dhd_deferred_wq, (void *)dhdif, DHD_WQ_WORK_SET_MAC,\n\t\tdhd_set_mac_addr_handler, DHD_WORK_PRIORITY_LOW);\n\treturn ret;\n}\n\nstatic void\ndhd_set_multicast_list(struct net_device *dev)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tint ifidx;\n\n\tifidx = dhd_net2idx(dhd, dev);\n\tif (ifidx == DHD_BAD_IF)\n\t\treturn;\n\n\tdhd->iflist[ifidx]->set_multicast = TRUE;\n\tdhd_deferred_schedule_work(dhd->dhd_deferred_wq, (void *)dhd->iflist[ifidx],\n\t\tDHD_WQ_WORK_SET_MCAST_LIST, dhd_set_mcast_list_handler, DHD_WORK_PRIORITY_LOW);\n\n\t// terence 20160907: fix for not able to set mac when wlan0 is down\n\tdhd_deferred_schedule_work(dhd->dhd_deferred_wq, (void *)dhd->iflist[ifidx],\n\t\tDHD_WQ_WORK_SET_MAC, dhd_set_mac_addr_handler, DHD_WORK_PRIORITY_LOW);\n}\n\n#ifdef PROP_TXSTATUS\nint\ndhd_os_wlfc_block(dhd_pub_t *pub)\n{\n\tdhd_info_t *di = (dhd_info_t *)(pub->info);\n\tASSERT(di != NULL);\n\tspin_lock_bh(&di->wlfc_spinlock);\n\treturn 1;\n}\n\nint\ndhd_os_wlfc_unblock(dhd_pub_t *pub)\n{\n\tdhd_info_t *di = (dhd_info_t *)(pub->info);\n\n\tASSERT(di != NULL);\n\tspin_unlock_bh(&di->wlfc_spinlock);\n\treturn 1;\n}\n\n#endif /* PROP_TXSTATUS */\n\n#if defined(DHD_RX_DUMP) || defined(DHD_TX_DUMP)\ntypedef struct {\n\tuint16 type;\n\tconst char *str;\n} PKTTYPE_INFO;\n\nstatic const PKTTYPE_INFO packet_type_info[] =\n{\n\t{ ETHER_TYPE_IP, \"IP\" },\n\t{ ETHER_TYPE_ARP, \"ARP\" },\n\t{ ETHER_TYPE_BRCM, \"BRCM\" },\n\t{ ETHER_TYPE_802_1X, \"802.1X\" },\n\t{ ETHER_TYPE_WAI, \"WAPI\" },\n\t{ 0, \"\"}\n};\n\nstatic const char *_get_packet_type_str(uint16 type)\n{\n\tint i;\n\tint n = sizeof(packet_type_info)/sizeof(packet_type_info[1]) - 1;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (packet_type_info[i].type == type)\n\t\t\treturn packet_type_info[i].str;\n\t}\n\n\treturn packet_type_info[n].str;\n}\n#endif /* DHD_RX_DUMP || DHD_TX_DUMP */\n\n#if defined(DHD_TX_DUMP)\nvoid\ndhd_tx_dump(osl_t *osh, void *pkt)\n{\n\tuint8 *dump_data;\n\tuint16 protocol;\n\tstruct ether_header *eh;\n\n\tdump_data = PKTDATA(osh, pkt);\n\teh = (struct ether_header *) dump_data;\n\tprotocol = ntoh16(eh->ether_type);\n\n\tDHD_ERROR((\"TX DUMP - %s\\n\", _get_packet_type_str(protocol)));\n\n\tif (protocol == ETHER_TYPE_802_1X) {\n\t\tDHD_ERROR((\"ETHER_TYPE_802_1X [TX]: ver %d, type %d, replay %d\\n\",\n\t\t\tdump_data[14], dump_data[15], dump_data[30]));\n\t}\n\n#if defined(DHD_TX_FULL_DUMP)\n\t{\n\t\tint i;\n\t\tuint datalen;\n\t\tdatalen = PKTLEN(osh, pkt);\n\n\t\tfor (i = 0; i < datalen; i++) {\n\t\t\tDHD_ERROR((\"%02X \", dump_data[i]));\n\t\t\tif ((i & 15) == 15)\n\t\t\t\tprintk(\"\\n\");\n\t\t}\n\t\tDHD_ERROR((\"\\n\"));\n\t}\n#endif /* DHD_TX_FULL_DUMP */\n}\n#endif /* DHD_TX_DUMP */\n\nint BCMFASTPATH\ndhd_sendpkt(dhd_pub_t *dhdp, int ifidx, void *pktbuf)\n{\n\tint ret = BCME_OK;\n\tdhd_info_t *dhd = (dhd_info_t *)(dhdp->info);\n\tstruct ether_header *eh = NULL;\n\n\t/* Reject if down */\n\tif (!dhdp->up || (dhdp->busstate == DHD_BUS_DOWN)) {\n\t\t/* free the packet here since the caller won't */\n\t\tPKTFREE(dhdp->osh, pktbuf, TRUE);\n\t\treturn -ENODEV;\n\t}\n\n#ifdef PCIE_FULL_DONGLE\n\tif (dhdp->busstate == DHD_BUS_SUSPEND) {\n\t\tDHD_ERROR((\"%s : pcie is still in suspend state!!\\n\", __FUNCTION__));\n\t\tPKTFREE(dhdp->osh, pktbuf, TRUE);\n\t\treturn -EBUSY;\n\t}\n#endif /* PCIE_FULL_DONGLE */\n\n#ifdef DHD_UNICAST_DHCP\n\t/* if dhcp_unicast is enabled, we need to convert the */\n\t/* broadcast DHCP ACK/REPLY packets to Unicast. */\n\tif (dhdp->dhcp_unicast) {\n\t    dhd_convert_dhcp_broadcast_ack_to_unicast(dhdp, pktbuf, ifidx);\n\t}\n#endif /* DHD_UNICAST_DHCP */\n\t/* Update multicast statistic */\n\tif (PKTLEN(dhdp->osh, pktbuf) >= ETHER_HDR_LEN) {\n\t\tuint8 *pktdata = (uint8 *)PKTDATA(dhdp->osh, pktbuf);\n\t\teh = (struct ether_header *)pktdata;\n\n\t\tif (ETHER_ISMULTI(eh->ether_dhost))\n\t\t\tdhdp->tx_multicast++;\n\t\tif (ntoh16(eh->ether_type) == ETHER_TYPE_802_1X)\n\t\t\tatomic_inc(&dhd->pend_8021x_cnt);\n\t} else {\n\t\t\tPKTFREE(dhd->pub.osh, pktbuf, TRUE);\n\t\t\treturn BCME_ERROR;\n\t}\n\n\t/* Look into the packet and update the packet priority */\n#ifndef PKTPRIO_OVERRIDE\n\tif (PKTPRIO(pktbuf) == 0)\n#endif \n\t\tpktsetprio(pktbuf, FALSE);\n\n\n#if defined(PCIE_FULL_DONGLE) && !defined(PCIE_TX_DEFERRAL)\n\t/*\n\t * Lkup the per interface hash table, for a matching flowring. If one is not\n\t * available, allocate a unique flowid and add a flowring entry.\n\t * The found or newly created flowid is placed into the pktbuf's tag.\n\t */\n\tret = dhd_flowid_update(dhdp, ifidx, dhdp->flow_prio_map[(PKTPRIO(pktbuf))], pktbuf);\n\tif (ret != BCME_OK) {\n\t\tPKTCFREE(dhd->pub.osh, pktbuf, TRUE);\n\t\treturn ret;\n\t}\n#endif\n#if defined(DHD_TX_DUMP)\n\tdhd_tx_dump(dhdp->osh, pktbuf);\n#endif\n\n\t/* terence 20150901: Micky add to ajust the 802.1X priority */\n\t/* Set the 802.1X packet with the highest priority 7 */\n\tif (dhdp->conf->pktprio8021x >= 0)\n\t\tpktset8021xprio(pktbuf, dhdp->conf->pktprio8021x);\n\n#ifdef PROP_TXSTATUS\n\tif (dhd_wlfc_is_supported(dhdp)) {\n\t\t/* store the interface ID */\n\t\tDHD_PKTTAG_SETIF(PKTTAG(pktbuf), ifidx);\n\n\t\t/* store destination MAC in the tag as well */\n\t\tDHD_PKTTAG_SETDSTN(PKTTAG(pktbuf), eh->ether_dhost);\n\n\t\t/* decide which FIFO this packet belongs to */\n\t\tif (ETHER_ISMULTI(eh->ether_dhost))\n\t\t\t/* one additional queue index (highest AC + 1) is used for bc/mc queue */\n\t\t\tDHD_PKTTAG_SETFIFO(PKTTAG(pktbuf), AC_COUNT);\n\t\telse\n\t\t\tDHD_PKTTAG_SETFIFO(PKTTAG(pktbuf), WME_PRIO2AC(PKTPRIO(pktbuf)));\n\t} else\n#endif /* PROP_TXSTATUS */\n\t/* If the protocol uses a data header, apply it */\n\tdhd_prot_hdrpush(dhdp, ifidx, pktbuf);\n\n\t/* Use bus module to send data frame */\n#ifdef WLMEDIA_HTSF\n\tdhd_htsf_addtxts(dhdp, pktbuf);\n#endif\n\n#ifdef PROP_TXSTATUS\n\t{\n\t\tif (dhd_wlfc_commit_packets(dhdp, (f_commitpkt_t)dhd_bus_txdata,\n\t\t\tdhdp->bus, pktbuf, TRUE) == WLFC_UNSUPPORTED) {\n\t\t\t/* non-proptxstatus way */\n#ifdef BCMPCIE\n\t\t\tret = dhd_bus_txdata(dhdp->bus, pktbuf, (uint8)ifidx);\n#else\n\t\t\tret = dhd_bus_txdata(dhdp->bus, pktbuf);\n#endif /* BCMPCIE */\n\t\t}\n\t}\n#else\n#ifdef BCMPCIE\n\tret = dhd_bus_txdata(dhdp->bus, pktbuf, (uint8)ifidx);\n#else\n\tret = dhd_bus_txdata(dhdp->bus, pktbuf);\n#endif /* BCMPCIE */\n#endif /* PROP_TXSTATUS */\n\n\treturn ret;\n}\n\nint BCMFASTPATH\ndhd_start_xmit(struct sk_buff *skb, struct net_device *net)\n{\n\tint ret;\n\tuint datalen;\n\tvoid *pktbuf;\n\tdhd_info_t *dhd = DHD_DEV_INFO(net);\n\tdhd_if_t *ifp = NULL;\n\tint ifidx;\n#ifdef WLMEDIA_HTSF\n\tuint8 htsfdlystat_sz = dhd->pub.htsfdlystat_sz;\n#else\n\tuint8 htsfdlystat_sz = 0;\n#endif\n#ifdef DHD_WMF\n\tstruct ether_header *eh;\n\tuint8 *iph;\n#endif /* DHD_WMF */\n\n\tDHD_TRACE((\"%s: Enter\\n\", __FUNCTION__));\n\n\tDHD_OS_WAKE_LOCK(&dhd->pub);\n\tDHD_PERIM_LOCK_TRY(DHD_FWDER_UNIT(dhd), TRUE);\n\n\t/* Reject if down */\n\tif (dhd->pub.busstate == DHD_BUS_DOWN || dhd->pub.hang_was_sent) {\n\t\tDHD_ERROR((\"%s: xmit rejected pub.up=%d busstate=%d \\n\",\n\t\t\t__FUNCTION__, dhd->pub.up, dhd->pub.busstate));\n\t\tnetif_stop_queue(net);\n\t\t/* Send Event when bus down detected during data session */\n\t\tif (dhd->pub.up) {\n\t\t\tDHD_ERROR((\"%s: Event HANG sent up\\n\", __FUNCTION__));\n\t\t\tnet_os_send_hang_message(net);\n\t\t}\n\t\tDHD_PERIM_UNLOCK_TRY(DHD_FWDER_UNIT(dhd), TRUE);\n\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20))\n\t\treturn -ENODEV;\n#else\n\t\treturn NETDEV_TX_BUSY;\n#endif\n\t}\n\n\tifp = DHD_DEV_IFP(net);\n\tifidx = DHD_DEV_IFIDX(net);\n\n\tASSERT(ifidx == dhd_net2idx(dhd, net));\n\tASSERT((ifp != NULL) && (ifp == dhd->iflist[ifidx]));\n\n\tif (ifidx == DHD_BAD_IF) {\n\t\tDHD_ERROR((\"%s: bad ifidx %d\\n\", __FUNCTION__, ifidx));\n\t\tnetif_stop_queue(net);\n\t\tDHD_PERIM_UNLOCK_TRY(DHD_FWDER_UNIT(dhd), TRUE);\n\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20))\n\t\treturn -ENODEV;\n#else\n\t\treturn NETDEV_TX_BUSY;\n#endif\n\t}\n\n\t/* re-align socket buffer if \"skb->data\" is odd address */\n\tif (((unsigned long)(skb->data)) & 0x1) {\n\t\tunsigned char *data = skb->data;\n\t\tuint32 length = skb->len;\n\t\tPKTPUSH(dhd->pub.osh, skb, 1);\n\t\tmemmove(skb->data, data, length);\n\t\tPKTSETLEN(dhd->pub.osh, skb, length);\n\t}\n\n\tdatalen  = PKTLEN(dhd->pub.osh, skb);\n\n\t/* Make sure there's enough room for any header */\n\n\tif (skb_headroom(skb) < dhd->pub.hdrlen + htsfdlystat_sz) {\n\t\tstruct sk_buff *skb2;\n\n\t\tDHD_INFO((\"%s: insufficient headroom\\n\",\n\t\t          dhd_ifname(&dhd->pub, ifidx)));\n\t\tdhd->pub.tx_realloc++;\n\n\t\tskb2 = skb_realloc_headroom(skb, dhd->pub.hdrlen + htsfdlystat_sz);\n\n\t\tdev_kfree_skb(skb);\n\t\tif ((skb = skb2) == NULL) {\n\t\t\tDHD_ERROR((\"%s: skb_realloc_headroom failed\\n\",\n\t\t\t           dhd_ifname(&dhd->pub, ifidx)));\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Convert to packet */\n\tif (!(pktbuf = PKTFRMNATIVE(dhd->pub.osh, skb))) {\n\t\tDHD_ERROR((\"%s: PKTFRMNATIVE failed\\n\",\n\t\t           dhd_ifname(&dhd->pub, ifidx)));\n\t\tdev_kfree_skb_any(skb);\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n#ifdef WLMEDIA_HTSF\n\tif (htsfdlystat_sz && PKTLEN(dhd->pub.osh, pktbuf) >= ETHER_ADDR_LEN) {\n\t\tuint8 *pktdata = (uint8 *)PKTDATA(dhd->pub.osh, pktbuf);\n\t\tstruct ether_header *eh = (struct ether_header *)pktdata;\n\n\t\tif (!ETHER_ISMULTI(eh->ether_dhost) &&\n\t\t\t(ntoh16(eh->ether_type) == ETHER_TYPE_IP)) {\n\t\t\teh->ether_type = hton16(ETHER_TYPE_BRCM_PKTDLYSTATS);\n\t\t}\n\t}\n#endif\n#ifdef DHD_WMF\n\teh = (struct ether_header *)PKTDATA(dhd->pub.osh, pktbuf);\n\tiph = (uint8 *)eh + ETHER_HDR_LEN;\n\n\t/* WMF processing for multicast packets\n\t * Only IPv4 packets are handled\n\t */\n\tif (ifp->wmf.wmf_enable && (ntoh16(eh->ether_type) == ETHER_TYPE_IP) &&\n\t\t(IP_VER(iph) == IP_VER_4) && (ETHER_ISMULTI(eh->ether_dhost) ||\n\t\t((IPV4_PROT(iph) == IP_PROT_IGMP) && dhd->pub.wmf_ucast_igmp))) {\n#if defined(DHD_IGMP_UCQUERY) || defined(DHD_UCAST_UPNP)\n\t\tvoid *sdu_clone;\n\t\tbool ucast_convert = FALSE;\n#ifdef DHD_UCAST_UPNP\n\t\tuint32 dest_ip;\n\n\t\tdest_ip = ntoh32(*((uint32 *)(iph + IPV4_DEST_IP_OFFSET)));\n\t\tucast_convert = dhd->pub.wmf_ucast_upnp && MCAST_ADDR_UPNP_SSDP(dest_ip);\n#endif /* DHD_UCAST_UPNP */\n#ifdef DHD_IGMP_UCQUERY\n\t\tucast_convert |= dhd->pub.wmf_ucast_igmp_query &&\n\t\t\t(IPV4_PROT(iph) == IP_PROT_IGMP) &&\n\t\t\t(*(iph + IPV4_HLEN(iph)) == IGMPV2_HOST_MEMBERSHIP_QUERY);\n#endif /* DHD_IGMP_UCQUERY */\n\t\tif (ucast_convert) {\n\t\t\tdhd_sta_t *sta;\n\t\t\tunsigned long flags;\n\n\t\t\tDHD_IF_STA_LIST_LOCK(ifp, flags);\n\n\t\t\t/* Convert upnp/igmp query to unicast for each assoc STA */\n\t\t\tlist_for_each_entry(sta, &ifp->sta_list, list) {\n\t\t\t\tif ((sdu_clone = PKTDUP(dhd->pub.osh, pktbuf)) == NULL) {\n\t\t\t\t\tDHD_IF_STA_LIST_UNLOCK(ifp, flags);\n\t\t\t\t\tDHD_PERIM_UNLOCK_TRY(DHD_FWDER_UNIT(dhd), TRUE);\n\t\t\t\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\t\t\t\t\treturn (WMF_NOP);\n\t\t\t\t}\n\t\t\t\tdhd_wmf_forward(ifp->wmf.wmfh, sdu_clone, 0, sta, 1);\n\t\t\t}\n\n\t\t\tDHD_IF_STA_LIST_UNLOCK(ifp, flags);\n\t\t\tDHD_PERIM_UNLOCK_TRY(DHD_FWDER_UNIT(dhd), TRUE);\n\t\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\n\t\t\tPKTFREE(dhd->pub.osh, pktbuf, TRUE);\n\t\t\treturn NETDEV_TX_OK;\n\t\t} else\n#endif /* defined(DHD_IGMP_UCQUERY) || defined(DHD_UCAST_UPNP) */\n\t\t{\n\t\t\t/* There will be no STA info if the packet is coming from LAN host\n\t\t\t * Pass as NULL\n\t\t\t */\n\t\t\tret = dhd_wmf_packets_handle(&dhd->pub, pktbuf, NULL, ifidx, 0);\n\t\t\tswitch (ret) {\n\t\t\tcase WMF_TAKEN:\n\t\t\tcase WMF_DROP:\n\t\t\t\t/* Either taken by WMF or we should drop it.\n\t\t\t\t * Exiting send path\n\t\t\t\t */\n\t\t\t\tDHD_PERIM_UNLOCK_TRY(DHD_FWDER_UNIT(dhd), TRUE);\n\t\t\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\t\t\t\treturn NETDEV_TX_OK;\n\t\t\tdefault:\n\t\t\t\t/* Continue the transmit path */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif /* DHD_WMF */\n\n#ifdef DHDTCPACK_SUPPRESS\n\tif (dhd->pub.tcpack_sup_mode == TCPACK_SUP_HOLD) {\n\t\t/* If this packet has been hold or got freed, just return */\n\t\tif (dhd_tcpack_hold(&dhd->pub, pktbuf, ifidx)) {\n\t\t\t// terence 20160817: fix unable to suspend issue\n\t\t\tret = 0;\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\t/* If this packet has replaced another packet and got freed, just return */\n\t\tif (dhd_tcpack_suppress(&dhd->pub, pktbuf)) {\n\t\t\t// terence 20160817: fix unable to suspend issue\n\t\t\tret = 0;\n\t\t\tgoto done;\n\t\t}\n\t}\n#endif /* DHDTCPACK_SUPPRESS */\n\n\tret = dhd_sendpkt(&dhd->pub, ifidx, pktbuf);\n\ndone:\n\tif (ret) {\n\t\tifp->stats.tx_dropped++;\n\t\tdhd->pub.tx_dropped++;\n\t}\n\telse {\n\n#ifdef PROP_TXSTATUS\n\t\t/* tx_packets counter can counted only when wlfc is disabled */\n\t\tif (!dhd_wlfc_is_supported(&dhd->pub))\n#endif\n\t\t{\n\t\t\tdhd->pub.tx_packets++;\n\t\t\tifp->stats.tx_packets++;\n\t\t\tifp->stats.tx_bytes += datalen;\n\t\t}\n\t}\n\n\tDHD_PERIM_UNLOCK_TRY(DHD_FWDER_UNIT(dhd), TRUE);\n\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\n\t/* Return ok: we always eat the packet */\n#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20))\n\treturn 0;\n#else\n\treturn NETDEV_TX_OK;\n#endif\n}\n\n\nvoid\ndhd_txflowcontrol(dhd_pub_t *dhdp, int ifidx, bool state)\n{\n\tstruct net_device *net;\n\tdhd_info_t *dhd = dhdp->info;\n\tint i;\n\n\tDHD_TRACE((\"%s: Enter\\n\", __FUNCTION__));\n\n\tASSERT(dhd);\n\n\tif (ifidx == ALL_INTERFACES) {\n\t\t/* Flow control on all active interfaces */\n\t\tdhdp->txoff = state;\n\t\tfor (i = 0; i < DHD_MAX_IFS; i++) {\n\t\t\tif (dhd->iflist[i]) {\n\t\t\t\tnet = dhd->iflist[i]->net;\n\t\t\t\tif (state == ON)\n\t\t\t\t\tnetif_stop_queue(net);\n\t\t\t\telse\n\t\t\t\t\tnetif_wake_queue(net);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif (dhd->iflist[ifidx]) {\n\t\t\tnet = dhd->iflist[ifidx]->net;\n\t\t\tif (state == ON)\n\t\t\t\tnetif_stop_queue(net);\n\t\t\telse\n\t\t\t\tnetif_wake_queue(net);\n\t\t}\n\t}\n}\n\n\n#ifdef DHD_WMF\nbool\ndhd_is_rxthread_enabled(dhd_pub_t *dhdp)\n{\n\tdhd_info_t *dhd = dhdp->info;\n\n\treturn dhd->rxthread_enabled;\n}\n#endif /* DHD_WMF */\n\nvoid\ndhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)dhdp->info;\n\tstruct sk_buff *skb;\n\tuchar *eth;\n\tuint len;\n\tvoid *data, *pnext = NULL;\n\tint i;\n\tdhd_if_t *ifp;\n\twl_event_msg_t event;\n\tint tout_rx = 0;\n\tint tout_ctrl = 0;\n\tvoid *skbhead = NULL;\n\tvoid *skbprev = NULL;\n#if defined(DHD_RX_DUMP) || defined(DHD_8021X_DUMP)\n\tchar *dump_data;\n\tuint16 protocol;\n#endif /* DHD_RX_DUMP || DHD_8021X_DUMP */\n\n\tDHD_TRACE((\"%s: Enter\\n\", __FUNCTION__));\n\n\tfor (i = 0; pktbuf && i < numpkt; i++, pktbuf = pnext) {\n\t\tstruct ether_header *eh;\n#ifdef WLBTAMP\n\t\tstruct dot11_llc_snap_header *lsh;\n#endif\n\n\t\tpnext = PKTNEXT(dhdp->osh, pktbuf);\n\t\tPKTSETNEXT(dhdp->osh, pktbuf, NULL);\n\n\t\tifp = dhd->iflist[ifidx];\n\t\tif (ifp == NULL) {\n\t\t\tDHD_ERROR((\"%s: ifp is NULL. drop packet\\n\",\n\t\t\t\t__FUNCTION__));\n\t\t\tPKTCFREE(dhdp->osh, pktbuf, FALSE);\n\t\t\tcontinue;\n\t\t}\n\n\t\teh = (struct ether_header *)PKTDATA(dhdp->osh, pktbuf);\n\n\t\t/* Dropping only data packets before registering net device to avoid kernel panic */\n#ifndef PROP_TXSTATUS_VSDB\n\t\tif ((!ifp->net || ifp->net->reg_state != NETREG_REGISTERED) &&\n\t\t\t(ntoh16(eh->ether_type) != ETHER_TYPE_BRCM))\n#else\n\t\tif ((!ifp->net || ifp->net->reg_state != NETREG_REGISTERED || !dhd->pub.up) &&\n\t\t\t(ntoh16(eh->ether_type) != ETHER_TYPE_BRCM))\n#endif /* PROP_TXSTATUS_VSDB */\n\t\t{\n\t\t\tDHD_ERROR((\"%s: net device is NOT registered yet. drop packet\\n\",\n\t\t\t__FUNCTION__));\n\t\t\tPKTCFREE(dhdp->osh, pktbuf, FALSE);\n\t\t\tcontinue;\n\t\t}\n\n#ifdef WLBTAMP\n\t\tlsh = (struct dot11_llc_snap_header *)&eh[1];\n\n\t\tif ((ntoh16(eh->ether_type) < ETHER_TYPE_MIN) &&\n\t\t    (PKTLEN(dhdp->osh, pktbuf) >= RFC1042_HDR_LEN) &&\n\t\t    bcmp(lsh, BT_SIG_SNAP_MPROT, DOT11_LLC_SNAP_HDR_LEN - 2) == 0 &&\n\t\t    lsh->type == HTON16(BTA_PROT_L2CAP)) {\n\t\t\tamp_hci_ACL_data_t *ACL_data = (amp_hci_ACL_data_t *)\n\t\t\t        ((uint8 *)eh + RFC1042_HDR_LEN);\n\t\t\tACL_data = NULL;\n\t\t}\n#endif /* WLBTAMP */\n\n#ifdef PROP_TXSTATUS\n\t\tif (dhd_wlfc_is_header_only_pkt(dhdp, pktbuf)) {\n\t\t\t/* WLFC may send header only packet when\n\t\t\tthere is an urgent message but no packet to\n\t\t\tpiggy-back on\n\t\t\t*/\n\t\t\tPKTCFREE(dhdp->osh, pktbuf, FALSE);\n\t\t\tcontinue;\n\t\t}\n#endif\n#ifdef DHD_L2_FILTER\n\t\t/* If block_ping is enabled drop the ping packet */\n\t\tif (dhdp->block_ping) {\n\t\t\tif (dhd_l2_filter_block_ping(dhdp, pktbuf, ifidx) == BCME_OK) {\n\t\t\t\tPKTFREE(dhdp->osh, pktbuf, FALSE);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n#endif\n#ifdef DHD_WMF\n\t\t/* WMF processing for multicast packets */\n\t\tif (ifp->wmf.wmf_enable && (ETHER_ISMULTI(eh->ether_dhost))) {\n\t\t\tdhd_sta_t *sta;\n\t\t\tint ret;\n\n\t\t\tsta = dhd_find_sta(dhdp, ifidx, (void *)eh->ether_shost);\n\t\t\tret = dhd_wmf_packets_handle(dhdp, pktbuf, sta, ifidx, 1);\n\t\t\tswitch (ret) {\n\t\t\t\tcase WMF_TAKEN:\n\t\t\t\t\t/* The packet is taken by WMF. Continue to next iteration */\n\t\t\t\t\tcontinue;\n\t\t\t\tcase WMF_DROP:\n\t\t\t\t\t/* Packet DROP decision by WMF. Toss it */\n\t\t\t\t\tDHD_ERROR((\"%s: WMF decides to drop packet\\n\",\n\t\t\t\t\t\t__FUNCTION__));\n\t\t\t\t\tPKTCFREE(dhdp->osh, pktbuf, FALSE);\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Continue the transmit path */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif /* DHD_WMF */\n#ifdef DHDTCPACK_SUPPRESS\n\t\tdhd_tcpdata_info_get(dhdp, pktbuf);\n#endif\n\t\tskb = PKTTONATIVE(dhdp->osh, pktbuf);\n\n\t\tifp = dhd->iflist[ifidx];\n\t\tif (ifp == NULL)\n\t\t\tifp = dhd->iflist[0];\n\n\t\tASSERT(ifp);\n\t\tskb->dev = ifp->net;\n\n#ifdef PCIE_FULL_DONGLE\n\t\tif ((DHD_IF_ROLE_AP(dhdp, ifidx) || DHD_IF_ROLE_P2PGO(dhdp, ifidx)) &&\n\t\t\t(!ifp->ap_isolate)) {\n\t\t\teh = (struct ether_header *)PKTDATA(dhdp->osh, pktbuf);\n\t\t\tif (ETHER_ISUCAST(eh->ether_dhost)) {\n\t\t\t\tif (dhd_find_sta(dhdp, ifidx, (void *)eh->ether_dhost)) {\n\t\t\t\t\tdhd_sendpkt(dhdp, ifidx, pktbuf);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvoid *npktbuf = PKTDUP(dhdp->osh, pktbuf);\n\t\t\t\tdhd_sendpkt(dhdp, ifidx, npktbuf);\n\t\t\t}\n\t\t}\n#endif /* PCIE_FULL_DONGLE */\n\n\t\t/* Get the protocol, maintain skb around eth_type_trans()\n\t\t * The main reason for this hack is for the limitation of\n\t\t * Linux 2.4 where 'eth_type_trans' uses the 'net->hard_header_len'\n\t\t * to perform skb_pull inside vs ETH_HLEN. Since to avoid\n\t\t * coping of the packet coming from the network stack to add\n\t\t * BDC, Hardware header etc, during network interface registration\n\t\t * we set the 'net->hard_header_len' to ETH_HLEN + extra space required\n\t\t * for BDC, Hardware header etc. and not just the ETH_HLEN\n\t\t */\n\t\teth = skb->data;\n\t\tlen = skb->len;\n\n#if defined(DHD_RX_DUMP) || defined(DHD_8021X_DUMP)\n\t\tdump_data = skb->data;\n\t\tprotocol = (dump_data[12] << 8) | dump_data[13];\n\n\t\tif (protocol == ETHER_TYPE_802_1X) {\n\t\t\tDHD_ERROR((\"ETHER_TYPE_802_1X [RX]: \"\n\t\t\t\t\"ver %d, type %d, replay %d\\n\",\n\t\t\t\tdump_data[14], dump_data[15],\n\t\t\t\tdump_data[30]));\n\t\t}\n#endif /* DHD_RX_DUMP || DHD_8021X_DUMP */\n#if defined(DHD_RX_DUMP)\n\t\tDHD_ERROR((\"RX DUMP - %s\\n\", _get_packet_type_str(protocol)));\n\t\tif (protocol != ETHER_TYPE_BRCM) {\n\t\t\tif (dump_data[0] == 0xFF) {\n\t\t\t\tDHD_ERROR((\"%s: BROADCAST\\n\", __FUNCTION__));\n\n\t\t\t\tif ((dump_data[12] == 8) &&\n\t\t\t\t\t(dump_data[13] == 6)) {\n\t\t\t\t\tDHD_ERROR((\"%s: ARP %d\\n\",\n\t\t\t\t\t\t__FUNCTION__, dump_data[0x15]));\n\t\t\t\t}\n\t\t\t} else if (dump_data[0] & 1) {\n\t\t\t\tDHD_ERROR((\"%s: MULTICAST: \" MACDBG \"\\n\",\n\t\t\t\t\t__FUNCTION__, MAC2STRDBG(dump_data)));\n\t\t\t}\n#ifdef DHD_RX_FULL_DUMP\n\t\t\t{\n\t\t\t\tint k;\n\t\t\t\tfor (k = 0; k < skb->len; k++) {\n\t\t\t\t\tDHD_ERROR((\"%02X \", dump_data[k]));\n\t\t\t\t\tif ((k & 15) == 15)\n\t\t\t\t\t\tDHD_ERROR((\"\\n\"));\n\t\t\t\t}\n\t\t\t\tDHD_ERROR((\"\\n\"));\n\t\t\t}\n#endif /* DHD_RX_FULL_DUMP */\n\t\t}\n#endif /* DHD_RX_DUMP */\n\n\t\tskb->protocol = eth_type_trans(skb, skb->dev);\n\n\t\tif (skb->pkt_type == PACKET_MULTICAST) {\n\t\t\tdhd->pub.rx_multicast++;\n\t\t\tifp->stats.multicast++;\n\t\t}\n\n\t\tskb->data = eth;\n\t\tskb->len = len;\n\n#ifdef WLMEDIA_HTSF\n\t\tdhd_htsf_addrxts(dhdp, pktbuf);\n#endif\n\t\t/* Strip header, count, deliver upward */\n\t\tskb_pull(skb, ETH_HLEN);\n\n\t\t/* Process special event packets and then discard them */\n\t\tmemset(&event, 0, sizeof(event));\n\t\tif (ntoh16(skb->protocol) == ETHER_TYPE_BRCM) {\n\t\t\tdhd_wl_host_event(dhd, &ifidx,\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)\n\t\t\tskb_mac_header(skb),\n#else\n\t\t\tskb->mac.raw,\n#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22) */\n\t\t\t&event,\n\t\t\t&data);\n\n\t\t\twl_event_to_host_order(&event);\n\t\t\tif (!tout_ctrl)\n\t\t\t\ttout_ctrl = DHD_PACKET_TIMEOUT_MS;\n#ifdef WLBTAMP\n\t\t\tif (event.event_type == WLC_E_BTA_HCI_EVENT) {\n\t\t\t\tdhd_bta_doevt(dhdp, data, event.datalen);\n\t\t\t}\n#endif /* WLBTAMP */\n\n#if defined(PNO_SUPPORT)\n\t\t\tif (event.event_type == WLC_E_PFN_NET_FOUND) {\n\t\t\t\t/* enforce custom wake lock to garantee that Kernel not suspended */\n\t\t\t\ttout_ctrl = CUSTOM_PNO_EVENT_LOCK_xTIME * DHD_PACKET_TIMEOUT_MS;\n\t\t\t}\n#endif /* PNO_SUPPORT */\n\n#ifdef DHD_DONOT_FORWARD_BCMEVENT_AS_NETWORK_PKT\n\t\t\tPKTFREE(dhdp->osh, pktbuf, FALSE);\n\t\t\tcontinue;\n#endif /* DHD_DONOT_FORWARD_BCMEVENT_AS_NETWORK_PKT */\n\t\t} else {\n\t\t\ttout_rx = DHD_PACKET_TIMEOUT_MS;\n\n#ifdef PROP_TXSTATUS\n\t\t\tdhd_wlfc_save_rxpath_ac_time(dhdp, (uint8)PKTPRIO(skb));\n#endif /* PROP_TXSTATUS */\n\t\t}\n\n\t\tASSERT(ifidx < DHD_MAX_IFS && dhd->iflist[ifidx]);\n\t\tifp = dhd->iflist[ifidx];\n\n\t\tif (ifp->net)\n\t\t\tifp->net->last_rx = jiffies;\n\n\t\tif (ntoh16(skb->protocol) != ETHER_TYPE_BRCM) {\n\t\t\tdhdp->dstats.rx_bytes += skb->len;\n\t\t\tdhdp->rx_packets++; /* Local count */\n\t\t\tifp->stats.rx_bytes += skb->len;\n\t\t\tifp->stats.rx_packets++;\n\t\t}\n#if defined(DHD_TCP_WINSIZE_ADJUST)\n\t\tif (dhd_use_tcp_window_size_adjust) {\n\t\t\tif (ifidx == 0 && ntoh16(skb->protocol) == ETHER_TYPE_IP) {\n\t\t\t\tdhd_adjust_tcp_winsize(dhdp->op_mode, skb);\n\t\t\t}\n\t\t}\n#endif /* DHD_TCP_WINSIZE_ADJUST */\n\n\t\tif (in_interrupt()) {\n\t\t\tnetif_rx(skb);\n\t\t} else {\n\t\t\tif (dhd->rxthread_enabled) {\n\t\t\t\tif (!skbhead)\n\t\t\t\t\tskbhead = skb;\n\t\t\t\telse\n\t\t\t\t\tPKTSETNEXT(dhdp->osh, skbprev, skb);\n\t\t\t\tskbprev = skb;\n\t\t\t} else {\n\n\t\t\t\t/* If the receive is not processed inside an ISR,\n\t\t\t\t * the softirqd must be woken explicitly to service\n\t\t\t\t * the NET_RX_SOFTIRQ.\tIn 2.6 kernels, this is handled\n\t\t\t\t * by netif_rx_ni(), but in earlier kernels, we need\n\t\t\t\t * to do it manually.\n\t\t\t\t */\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)\n\t\t\t\tnetif_rx_ni(skb);\n#else\n\t\t\t\tulong flags;\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tlocal_irq_save(flags);\n\t\t\t\tRAISE_RX_SOFTIRQ();\n\t\t\t\tlocal_irq_restore(flags);\n#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0) */\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dhd->rxthread_enabled && skbhead)\n\t\tdhd_sched_rxf(dhdp, skbhead);\n\n\tDHD_OS_WAKE_LOCK_RX_TIMEOUT_ENABLE(dhdp, tout_rx);\n\tDHD_OS_WAKE_LOCK_CTRL_TIMEOUT_ENABLE(dhdp, tout_ctrl);\n}\n\nvoid\ndhd_event(struct dhd_info *dhd, char *evpkt, int evlen, int ifidx)\n{\n\t/* Linux version has nothing to do */\n\treturn;\n}\n\nvoid\ndhd_txcomplete(dhd_pub_t *dhdp, void *txp, bool success)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(dhdp->info);\n\tstruct ether_header *eh;\n\tuint16 type;\n#ifdef WLBTAMP\n\tuint len;\n#endif\n\n\tdhd_prot_hdrpull(dhdp, NULL, txp, NULL, NULL);\n\n\teh = (struct ether_header *)PKTDATA(dhdp->osh, txp);\n\ttype  = ntoh16(eh->ether_type);\n\n\tif (type == ETHER_TYPE_802_1X)\n\t\tatomic_dec(&dhd->pend_8021x_cnt);\n\n#ifdef WLBTAMP\n\t/* Crack open the packet and check to see if it is BT HCI ACL data packet.\n\t * If yes generate packet completion event.\n\t */\n\tlen = PKTLEN(dhdp->osh, txp);\n\n\t/* Generate ACL data tx completion event locally to avoid SDIO bus transaction */\n\tif ((type < ETHER_TYPE_MIN) && (len >= RFC1042_HDR_LEN)) {\n\t\tstruct dot11_llc_snap_header *lsh = (struct dot11_llc_snap_header *)&eh[1];\n\n\t\tif (bcmp(lsh, BT_SIG_SNAP_MPROT, DOT11_LLC_SNAP_HDR_LEN - 2) == 0 &&\n\t\t    ntoh16(lsh->type) == BTA_PROT_L2CAP) {\n\n\t\t\tdhd_bta_tx_hcidata_complete(dhdp, txp, success);\n\t\t}\n\t}\n#endif /* WLBTAMP */\n#ifdef PROP_TXSTATUS\n\tif (dhdp->wlfc_state && (dhdp->proptxstatus_mode != WLFC_FCMODE_NONE)) {\n\t\tdhd_if_t *ifp = dhd->iflist[DHD_PKTTAG_IF(PKTTAG(txp))];\n\t\tuint datalen  = PKTLEN(dhd->pub.osh, txp);\n\n\t\tif (success) {\n\t\t\tdhd->pub.tx_packets++;\n\t\t\tifp->stats.tx_packets++;\n\t\t\tifp->stats.tx_bytes += datalen;\n\t\t} else {\n\t\t\tifp->stats.tx_dropped++;\n\t\t}\n\t}\n#endif\n}\n\nstatic struct net_device_stats *\ndhd_get_stats(struct net_device *net)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(net);\n\tdhd_if_t *ifp;\n\tint ifidx;\n\n\tDHD_TRACE((\"%s: Enter\\n\", __FUNCTION__));\n\n\tifidx = dhd_net2idx(dhd, net);\n\tif (ifidx == DHD_BAD_IF) {\n\t\tDHD_ERROR((\"%s: BAD_IF\\n\", __FUNCTION__));\n\n\t\tmemset(&net->stats, 0, sizeof(net->stats));\n\t\treturn &net->stats;\n\t}\n\n\tifp = dhd->iflist[ifidx];\n\tASSERT(dhd && ifp);\n\n\tif (dhd->pub.up) {\n\t\t/* Use the protocol to get dongle stats */\n\t\tdhd_prot_dstats(&dhd->pub);\n\t}\n\treturn &ifp->stats;\n}\n\nstatic int\ndhd_watchdog_thread(void *data)\n{\n\ttsk_ctl_t *tsk = (tsk_ctl_t *)data;\n\tdhd_info_t *dhd = (dhd_info_t *)tsk->parent;\n\t/* This thread doesn't need any user-level access,\n\t * so get rid of all our resources\n\t */\n\tif (dhd_watchdog_prio > 0) {\n\t\tstruct sched_param param;\n\t\tparam.sched_priority = (dhd_watchdog_prio < MAX_RT_PRIO)?\n\t\t\tdhd_watchdog_prio:(MAX_RT_PRIO-1);\n\t\tsetScheduler(current, SCHED_FIFO, &param);\n\t}\n\n\twhile (1)\n\t\tif (down_interruptible (&tsk->sema) == 0) {\n\t\t\tunsigned long flags;\n\t\t\tunsigned long jiffies_at_start = jiffies;\n\t\t\tunsigned long time_lapse;\n\n\t\t\tSMP_RD_BARRIER_DEPENDS();\n\t\t\tif (tsk->terminated) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (dhd->pub.dongle_reset == FALSE) {\n\t\t\t\tDHD_TIMER((\"%s:\\n\", __FUNCTION__));\n\n\t\t\t\t/* Call the bus module watchdog */\n\t\t\t\tdhd_bus_watchdog(&dhd->pub);\n\n\n\t\t\t\tDHD_GENERAL_LOCK(&dhd->pub, flags);\n\t\t\t\t/* Count the tick for reference */\n\t\t\t\tdhd->pub.tickcnt++;\n\t\t\t\ttime_lapse = jiffies - jiffies_at_start;\n\n\t\t\t\t/* Reschedule the watchdog */\n\t\t\t\tif (dhd->wd_timer_valid)\n\t\t\t\t\tmod_timer(&dhd->timer,\n\t\t\t\t\t    jiffies +\n\t\t\t\t\t    msecs_to_jiffies(dhd_watchdog_ms) -\n\t\t\t\t\t    min(msecs_to_jiffies(dhd_watchdog_ms), time_lapse));\n\t\t\t\t\tDHD_GENERAL_UNLOCK(&dhd->pub, flags);\n\t\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t}\n\n\tcomplete_and_exit(&tsk->completed, 0);\n}\n\nstatic void dhd_watchdog(ulong data)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)data;\n\tunsigned long flags;\n\n\tif (dhd->pub.dongle_reset) {\n\t\treturn;\n\t}\n\n\tif (dhd->thr_wdt_ctl.thr_pid >= 0) {\n\t\tup(&dhd->thr_wdt_ctl.sema);\n\t\treturn;\n\t}\n\n\t/* Call the bus module watchdog */\n\tdhd_bus_watchdog(&dhd->pub);\n\n\tDHD_GENERAL_LOCK(&dhd->pub, flags);\n\t/* Count the tick for reference */\n\tdhd->pub.tickcnt++;\n\n\t/* Reschedule the watchdog */\n\tif (dhd->wd_timer_valid)\n\t\tmod_timer(&dhd->timer, jiffies + msecs_to_jiffies(dhd_watchdog_ms));\n\tDHD_GENERAL_UNLOCK(&dhd->pub, flags);\n\n}\n\n#ifdef ENABLE_ADAPTIVE_SCHED\nstatic void\ndhd_sched_policy(int prio)\n{\n\tstruct sched_param param;\n\tif (cpufreq_quick_get(0) <= CUSTOM_CPUFREQ_THRESH) {\n\t\tparam.sched_priority = 0;\n\t\tsetScheduler(current, SCHED_NORMAL, &param);\n\t} else {\n\t\tif (get_scheduler_policy(current) != SCHED_FIFO) {\n\t\t\tparam.sched_priority = (prio < MAX_RT_PRIO)? prio : (MAX_RT_PRIO-1);\n\t\t\tsetScheduler(current, SCHED_FIFO, &param);\n\t\t}\n\t}\n}\n#endif /* ENABLE_ADAPTIVE_SCHED */\n#ifdef DEBUG_CPU_FREQ\nstatic int dhd_cpufreq_notifier(struct notifier_block *nb, unsigned long val, void *data)\n{\n\tdhd_info_t *dhd = container_of(nb, struct dhd_info, freq_trans);\n\tstruct cpufreq_freqs *freq = data;\n\tif (dhd) {\n\t\tif (!dhd->new_freq)\n\t\t\tgoto exit;\n\t\tif (val == CPUFREQ_POSTCHANGE) {\n\t\t\tDHD_ERROR((\"cpu freq is changed to %u kHZ on CPU %d\\n\",\n\t\t\t\tfreq->new, freq->cpu));\n\t\t\t*per_cpu_ptr(dhd->new_freq, freq->cpu) = freq->new;\n\t\t}\n\t}\nexit:\n\treturn 0;\n}\n#endif /* DEBUG_CPU_FREQ */\nstatic int\ndhd_dpc_thread(void *data)\n{\n\ttsk_ctl_t *tsk = (tsk_ctl_t *)data;\n\tdhd_info_t *dhd = (dhd_info_t *)tsk->parent;\n\n\t/* This thread doesn't need any user-level access,\n\t * so get rid of all our resources\n\t */\n\tif (dhd_dpc_prio > 0)\n\t{\n\t\tstruct sched_param param;\n\t\tparam.sched_priority = (dhd_dpc_prio < MAX_RT_PRIO)?dhd_dpc_prio:(MAX_RT_PRIO-1);\n\t\tsetScheduler(current, SCHED_FIFO, &param);\n\t}\n\n#ifdef CUSTOM_DPC_CPUCORE\n\tset_cpus_allowed_ptr(current, cpumask_of(CUSTOM_DPC_CPUCORE));\n#else\n\tif (dhd->pub.conf->dpc_cpucore >= 0) {\n\t\tprintf(\"%s: set dpc_cpucore %d from config.txt\\n\", __FUNCTION__, dhd->pub.conf->dpc_cpucore);\n\t\tset_cpus_allowed_ptr(current, cpumask_of(dhd->pub.conf->dpc_cpucore));\n\t}\n#endif\n#ifdef CUSTOM_SET_CPUCORE\n\tdhd->pub.current_dpc = current;\n#endif /* CUSTOM_SET_CPUCORE */\n\t/* Run until signal received */\n\twhile (1) {\n\t\tif (!binary_sema_down(tsk)) {\n#ifdef ENABLE_ADAPTIVE_SCHED\n\t\t\tdhd_sched_policy(dhd_dpc_prio);\n#endif /* ENABLE_ADAPTIVE_SCHED */\n\t\t\tSMP_RD_BARRIER_DEPENDS();\n\t\t\tif (tsk->terminated) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Call bus dpc unless it indicated down (then clean stop) */\n\t\t\tif (dhd->pub.busstate != DHD_BUS_DOWN) {\n\t\t\t\tdhd_os_wd_timer_extend(&dhd->pub, TRUE);\n\t\t\t\twhile (dhd_bus_dpc(dhd->pub.bus)) {\n\t\t\t\t\t/* process all data */\n\t\t\t\t}\n\t\t\t\tdhd_os_wd_timer_extend(&dhd->pub, FALSE);\n\t\t\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\n\t\t\t} else {\n\t\t\t\tif (dhd->pub.up)\n\t\t\t\t\tdhd_bus_stop(dhd->pub.bus, TRUE);\n\t\t\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\tcomplete_and_exit(&tsk->completed, 0);\n}\n\nstatic int\ndhd_rxf_thread(void *data)\n{\n\ttsk_ctl_t *tsk = (tsk_ctl_t *)data;\n\tdhd_info_t *dhd = (dhd_info_t *)tsk->parent;\n#if defined(WAIT_DEQUEUE)\n#define RXF_WATCHDOG_TIME 250 /* BARK_TIME(1000) /  */\n\tulong watchdogTime = OSL_SYSUPTIME(); /* msec */\n#endif\n\tdhd_pub_t *pub = &dhd->pub;\n\n\t/* This thread doesn't need any user-level access,\n\t * so get rid of all our resources\n\t */\n\tif (dhd_rxf_prio > 0)\n\t{\n\t\tstruct sched_param param;\n\t\tparam.sched_priority = (dhd_rxf_prio < MAX_RT_PRIO)?dhd_rxf_prio:(MAX_RT_PRIO-1);\n\t\tsetScheduler(current, SCHED_FIFO, &param);\n\t}\n\n\tDAEMONIZE(\"dhd_rxf\");\n\t/* DHD_OS_WAKE_LOCK is called in dhd_sched_dpc[dhd_linux.c] down below  */\n\n\t/*  signal: thread has started */\n\tcomplete(&tsk->completed);\n#ifdef CUSTOM_SET_CPUCORE\n\tdhd->pub.current_rxf = current;\n#endif /* CUSTOM_SET_CPUCORE */\n\t/* Run until signal received */\n\twhile (1) {\n\t\tif (down_interruptible(&tsk->sema) == 0) {\n\t\t\tvoid *skb;\n#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)\n\t\t\tulong flags;\n#endif\n#ifdef ENABLE_ADAPTIVE_SCHED\n\t\t\tdhd_sched_policy(dhd_rxf_prio);\n#endif /* ENABLE_ADAPTIVE_SCHED */\n\n\t\t\tSMP_RD_BARRIER_DEPENDS();\n\n\t\t\tif (tsk->terminated) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tskb = dhd_rxf_dequeue(pub);\n\n\t\t\tif (skb == NULL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (skb) {\n\t\t\t\tvoid *skbnext = PKTNEXT(pub->osh, skb);\n\t\t\t\tPKTSETNEXT(pub->osh, skb, NULL);\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)\n\t\t\t\tnetif_rx_ni(skb);\n#else\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tlocal_irq_save(flags);\n\t\t\t\tRAISE_RX_SOFTIRQ();\n\t\t\t\tlocal_irq_restore(flags);\n\n#endif\n\t\t\t\tskb = skbnext;\n\t\t\t}\n#if defined(WAIT_DEQUEUE)\n\t\t\tif (OSL_SYSUPTIME() - watchdogTime > RXF_WATCHDOG_TIME) {\n\t\t\t\tOSL_SLEEP(1);\n\t\t\t\twatchdogTime = OSL_SYSUPTIME();\n\t\t\t}\n#endif\n\n\t\t\tDHD_OS_WAKE_UNLOCK(pub);\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\tcomplete_and_exit(&tsk->completed, 0);\n}\n\n#ifdef BCMPCIE\nvoid dhd_dpc_kill(dhd_pub_t *dhdp)\n{\n\tdhd_info_t *dhd;\n\n\tif (!dhdp)\n\t\treturn;\n\n\tdhd = dhdp->info;\n\n\tif (!dhd)\n\t\treturn;\n\n\ttasklet_kill(&dhd->tasklet);\n\tDHD_ERROR((\"%s: tasklet disabled\\n\", __FUNCTION__));\n}\n#endif /* BCMPCIE */\n\nstatic void\ndhd_dpc(ulong data)\n{\n\tdhd_info_t *dhd;\n\n\tdhd = (dhd_info_t *)data;\n\n\t/* this (tasklet) can be scheduled in dhd_sched_dpc[dhd_linux.c]\n\t * down below , wake lock is set,\n\t * the tasklet is initialized in dhd_attach()\n\t */\n\t/* Call bus dpc unless it indicated down (then clean stop) */\n\tif (dhd->pub.busstate != DHD_BUS_DOWN) {\n\t\tif (dhd_bus_dpc(dhd->pub.bus))\n\t\t\ttasklet_schedule(&dhd->tasklet);\n\t\telse\n\t\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\t} else {\n\t\tdhd_bus_stop(dhd->pub.bus, TRUE);\n\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\t}\n}\n\nvoid\ndhd_sched_dpc(dhd_pub_t *dhdp)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)dhdp->info;\n\n\tDHD_OS_WAKE_LOCK(dhdp);\n\tif (dhd->thr_dpc_ctl.thr_pid >= 0) {\n\t\t/* If the semaphore does not get up,\n\t\t* wake unlock should be done here\n\t\t*/\n\t\tif (!binary_sema_up(&dhd->thr_dpc_ctl))\n\t\t\tDHD_OS_WAKE_UNLOCK(dhdp);\n\t\treturn;\n\t} else {\n\t\ttasklet_schedule(&dhd->tasklet);\n\t}\n}\n\nstatic void\ndhd_sched_rxf(dhd_pub_t *dhdp, void *skb)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)dhdp->info;\n#ifdef RXF_DEQUEUE_ON_BUSY\n\tint ret = BCME_OK;\n\tint retry = 2;\n#endif /* RXF_DEQUEUE_ON_BUSY */\n\n\tDHD_OS_WAKE_LOCK(dhdp);\n\n\tDHD_TRACE((\"dhd_sched_rxf: Enter\\n\"));\n#ifdef RXF_DEQUEUE_ON_BUSY\n\tdo {\n\t\tret = dhd_rxf_enqueue(dhdp, skb);\n\t\tif (ret == BCME_OK || ret == BCME_ERROR)\n\t\t\tbreak;\n\t\telse\n\t\t\tOSL_SLEEP(50); /* waiting for dequeueing */\n\t} while (retry-- > 0);\n\n\tif (retry <= 0 && ret == BCME_BUSY) {\n\t\tvoid *skbp = skb;\n\n\t\twhile (skbp) {\n\t\t\tvoid *skbnext = PKTNEXT(dhdp->osh, skbp);\n\t\t\tPKTSETNEXT(dhdp->osh, skbp, NULL);\n\t\t\tnetif_rx_ni(skbp);\n\t\t\tskbp = skbnext;\n\t\t}\n\t\tDHD_ERROR((\"send skb to kernel backlog without rxf_thread\\n\"));\n\t}\n\telse {\n\t\tif (dhd->thr_rxf_ctl.thr_pid >= 0) {\n\t\t\tup(&dhd->thr_rxf_ctl.sema);\n\t\t}\n\t}\n#else /* RXF_DEQUEUE_ON_BUSY */\n\tdo {\n\t\tif (dhd_rxf_enqueue(dhdp, skb) == BCME_OK)\n\t\t\tbreak;\n\t} while (1);\n\tif (dhd->thr_rxf_ctl.thr_pid >= 0) {\n\t\tup(&dhd->thr_rxf_ctl.sema);\n\t}\n\treturn;\n#endif /* RXF_DEQUEUE_ON_BUSY */\n}\n\n#ifdef TOE\n/* Retrieve current toe component enables, which are kept as a bitmap in toe_ol iovar */\nstatic int\ndhd_toe_get(dhd_info_t *dhd, int ifidx, uint32 *toe_ol)\n{\n\twl_ioctl_t ioc;\n\tchar buf[32];\n\tint ret;\n\n\tmemset(&ioc, 0, sizeof(ioc));\n\n\tioc.cmd = WLC_GET_VAR;\n\tioc.buf = buf;\n\tioc.len = (uint)sizeof(buf);\n\tioc.set = FALSE;\n\n\tstrncpy(buf, \"toe_ol\", sizeof(buf) - 1);\n\tbuf[sizeof(buf) - 1] = '\\0';\n\tif ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {\n\t\t/* Check for older dongle image that doesn't support toe_ol */\n\t\tif (ret == -EIO) {\n\t\t\tDHD_ERROR((\"%s: toe not supported by device\\n\",\n\t\t\t\tdhd_ifname(&dhd->pub, ifidx)));\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tDHD_INFO((\"%s: could not get toe_ol: ret=%d\\n\", dhd_ifname(&dhd->pub, ifidx), ret));\n\t\treturn ret;\n\t}\n\n\tmemcpy(toe_ol, buf, sizeof(uint32));\n\treturn 0;\n}\n\n/* Set current toe component enables in toe_ol iovar, and set toe global enable iovar */\nstatic int\ndhd_toe_set(dhd_info_t *dhd, int ifidx, uint32 toe_ol)\n{\n\twl_ioctl_t ioc;\n\tchar buf[32];\n\tint toe, ret;\n\n\tmemset(&ioc, 0, sizeof(ioc));\n\n\tioc.cmd = WLC_SET_VAR;\n\tioc.buf = buf;\n\tioc.len = (uint)sizeof(buf);\n\tioc.set = TRUE;\n\n\t/* Set toe_ol as requested */\n\n\tstrncpy(buf, \"toe_ol\", sizeof(buf) - 1);\n\tbuf[sizeof(buf) - 1] = '\\0';\n\tmemcpy(&buf[sizeof(\"toe_ol\")], &toe_ol, sizeof(uint32));\n\n\tif ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {\n\t\tDHD_ERROR((\"%s: could not set toe_ol: ret=%d\\n\",\n\t\t\tdhd_ifname(&dhd->pub, ifidx), ret));\n\t\treturn ret;\n\t}\n\n\t/* Enable toe globally only if any components are enabled. */\n\n\ttoe = (toe_ol != 0);\n\n\tstrcpy(buf, \"toe\");\n\tmemcpy(&buf[sizeof(\"toe\")], &toe, sizeof(uint32));\n\n\tif ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {\n\t\tDHD_ERROR((\"%s: could not set toe: ret=%d\\n\", dhd_ifname(&dhd->pub, ifidx), ret));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif /* TOE */\n\n#if defined(WL_CFG80211)\nvoid dhd_set_scb_probe(dhd_pub_t *dhd)\n{\n#define NUM_SCB_MAX_PROBE 3\n\tint ret = 0;\n\twl_scb_probe_t scb_probe;\n\tchar iovbuf[WL_EVENTING_MASK_LEN + 12];\n\n\tmemset(&scb_probe, 0, sizeof(wl_scb_probe_t));\n\n\tif (dhd->op_mode & DHD_FLAG_HOSTAP_MODE)\n\t\treturn;\n\n\tbcm_mkiovar(\"scb_probe\", NULL, 0, iovbuf, sizeof(iovbuf));\n\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)\n\t\tDHD_ERROR((\"%s: GET max_scb_probe failed\\n\", __FUNCTION__));\n\n\tmemcpy(&scb_probe, iovbuf, sizeof(wl_scb_probe_t));\n\n\tscb_probe.scb_max_probe = NUM_SCB_MAX_PROBE;\n\n\tbcm_mkiovar(\"scb_probe\", (char *)&scb_probe,\n\t\tsizeof(wl_scb_probe_t), iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)\n\t\tDHD_ERROR((\"%s: max_scb_probe setting failed\\n\", __FUNCTION__));\n#undef NUM_SCB_MAX_PROBE\n\treturn;\n}\n#endif /* WL_CFG80211 */\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)\nstatic void\ndhd_ethtool_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *info)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(net);\n\n\tsnprintf(info->driver, sizeof(info->driver), \"wl\");\n\tsnprintf(info->version, sizeof(info->version), \"%lu\", dhd->pub.drv_version);\n}\n\nstruct ethtool_ops dhd_ethtool_ops = {\n\t.get_drvinfo = dhd_ethtool_get_drvinfo\n};\n#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24) */\n\n\n#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 4, 2)\nstatic int\ndhd_ethtool(dhd_info_t *dhd, void *uaddr)\n{\n\tstruct ethtool_drvinfo info;\n\tchar drvname[sizeof(info.driver)];\n\tuint32 cmd;\n#ifdef TOE\n\tstruct ethtool_value edata;\n\tuint32 toe_cmpnt, csum_dir;\n\tint ret;\n#endif\n\n\tDHD_TRACE((\"%s: Enter\\n\", __FUNCTION__));\n\n\t/* all ethtool calls start with a cmd word */\n\tif (copy_from_user(&cmd, uaddr, sizeof (uint32)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ETHTOOL_GDRVINFO:\n\t\t/* Copy out any request driver name */\n\t\tif (copy_from_user(&info, uaddr, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\tstrncpy(drvname, info.driver, sizeof(info.driver));\n\t\tdrvname[sizeof(info.driver)-1] = '\\0';\n\n\t\t/* clear struct for return */\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.cmd = cmd;\n\n\t\t/* if dhd requested, identify ourselves */\n\t\tif (strcmp(drvname, \"?dhd\") == 0) {\n\t\t\tsnprintf(info.driver, sizeof(info.driver), \"dhd\");\n\t\t\tstrncpy(info.version, EPI_VERSION_STR, sizeof(info.version) - 1);\n\t\t\tinfo.version[sizeof(info.version) - 1] = '\\0';\n\t\t}\n\n\t\t/* otherwise, require dongle to be up */\n\t\telse if (!dhd->pub.up) {\n\t\t\tDHD_ERROR((\"%s: dongle is not up\\n\", __FUNCTION__));\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t/* finally, report dongle driver type */\n\t\telse if (dhd->pub.iswl)\n\t\t\tsnprintf(info.driver, sizeof(info.driver), \"wl\");\n\t\telse\n\t\t\tsnprintf(info.driver, sizeof(info.driver), \"xx\");\n\n\t\tsnprintf(info.version, sizeof(info.version), \"%lu\", dhd->pub.drv_version);\n\t\tif (copy_to_user(uaddr, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\tDHD_CTL((\"%s: given %*s, returning %s\\n\", __FUNCTION__,\n\t\t         (int)sizeof(drvname), drvname, info.driver));\n\t\tbreak;\n\n#ifdef TOE\n\t/* Get toe offload components from dongle */\n\tcase ETHTOOL_GRXCSUM:\n\tcase ETHTOOL_GTXCSUM:\n\t\tif ((ret = dhd_toe_get(dhd, 0, &toe_cmpnt)) < 0)\n\t\t\treturn ret;\n\n\t\tcsum_dir = (cmd == ETHTOOL_GTXCSUM) ? TOE_TX_CSUM_OL : TOE_RX_CSUM_OL;\n\n\t\tedata.cmd = cmd;\n\t\tedata.data = (toe_cmpnt & csum_dir) ? 1 : 0;\n\n\t\tif (copy_to_user(uaddr, &edata, sizeof(edata)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\t/* Set toe offload components in dongle */\n\tcase ETHTOOL_SRXCSUM:\n\tcase ETHTOOL_STXCSUM:\n\t\tif (copy_from_user(&edata, uaddr, sizeof(edata)))\n\t\t\treturn -EFAULT;\n\n\t\t/* Read the current settings, update and write back */\n\t\tif ((ret = dhd_toe_get(dhd, 0, &toe_cmpnt)) < 0)\n\t\t\treturn ret;\n\n\t\tcsum_dir = (cmd == ETHTOOL_STXCSUM) ? TOE_TX_CSUM_OL : TOE_RX_CSUM_OL;\n\n\t\tif (edata.data != 0)\n\t\t\ttoe_cmpnt |= csum_dir;\n\t\telse\n\t\t\ttoe_cmpnt &= ~csum_dir;\n\n\t\tif ((ret = dhd_toe_set(dhd, 0, toe_cmpnt)) < 0)\n\t\t\treturn ret;\n\n\t\t/* If setting TX checksum mode, tell Linux the new mode */\n\t\tif (cmd == ETHTOOL_STXCSUM) {\n\t\t\tif (edata.data)\n\t\t\t\tdhd->iflist[0]->net->features |= NETIF_F_IP_CSUM;\n\t\t\telse\n\t\t\t\tdhd->iflist[0]->net->features &= ~NETIF_F_IP_CSUM;\n\t\t}\n\n\t\tbreak;\n#endif /* TOE */\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 4, 2) */\n\nstatic bool dhd_check_hang(struct net_device *net, dhd_pub_t *dhdp, int error)\n{\n\tdhd_info_t *dhd;\n\n\tif (!dhdp) {\n\t\tDHD_ERROR((\"%s: dhdp is NULL\\n\", __FUNCTION__));\n\t\treturn FALSE;\n\t}\n\n\tif (!dhdp->up)\n\t\treturn FALSE;\n\n\tdhd = (dhd_info_t *)dhdp->info;\n#if !defined(BCMPCIE)\n\tif (dhd->thr_dpc_ctl.thr_pid < 0) {\n\t\tDHD_ERROR((\"%s : skipped due to negative pid - unloading?\\n\", __FUNCTION__));\n\t\treturn FALSE;\n\t}\n#endif \n\n#ifdef CONFIG_MACH_UNIVERSAL5433\n\t/* old revision does not send hang message */\n\tif ((check_rev() && (error == -ETIMEDOUT)) || (error == -EREMOTEIO) ||\n#else\n\tif ((error == -ETIMEDOUT) || (error == -EREMOTEIO) ||\n#endif /* CONFIG_MACH_UNIVERSAL5433 */\n\t\t((dhdp->busstate == DHD_BUS_DOWN) && (!dhdp->dongle_reset))) {\n\t\tDHD_ERROR((\"%s: Event HANG send up due to  re=%d te=%d e=%d s=%d\\n\", __FUNCTION__,\n\t\t\tdhdp->rxcnt_timeout, dhdp->txcnt_timeout, error, dhdp->busstate));\n\t\tnet_os_send_hang_message(net);\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nint dhd_ioctl_process(dhd_pub_t *pub, int ifidx, dhd_ioctl_t *ioc, void *data_buf)\n{\n\tint bcmerror = BCME_OK;\n\tint buflen = 0;\n\tstruct net_device *net;\n\n\tnet = dhd_idx2net(pub, ifidx);\n\tif (!net) {\n\t\tbcmerror = BCME_BADARG;\n\t\tgoto done;\n\t}\n\n\tif (data_buf)\n\t\tbuflen = MIN(ioc->len, DHD_IOCTL_MAXLEN);\n\n\t/* check for local dhd ioctl and handle it */\n\tif (ioc->driver == DHD_IOCTL_MAGIC) {\n\t\tbcmerror = dhd_ioctl((void *)pub, ioc, data_buf, buflen);\n\t\tif (bcmerror)\n\t\t\tpub->bcmerror = bcmerror;\n\t\tgoto done;\n\t}\n\n\t/* send to dongle (must be up, and wl). */\n\tif (pub->busstate != DHD_BUS_DATA) {\n\t\tbcmerror = BCME_DONGLE_DOWN;\n\t\tgoto done;\n\t}\n\n\tif (!pub->iswl) {\n\t\tbcmerror = BCME_DONGLE_DOWN;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Flush the TX queue if required for proper message serialization:\n\t * Intercept WLC_SET_KEY IOCTL - serialize M4 send and set key IOCTL to\n\t * prevent M4 encryption and\n\t * intercept WLC_DISASSOC IOCTL - serialize WPS-DONE and WLC_DISASSOC IOCTL to\n\t * prevent disassoc frame being sent before WPS-DONE frame.\n\t */\n\tif (ioc->cmd == WLC_SET_KEY ||\n\t    (ioc->cmd == WLC_SET_VAR && data_buf != NULL &&\n\t     strncmp(\"wsec_key\", data_buf, 9) == 0) ||\n\t    (ioc->cmd == WLC_SET_VAR && data_buf != NULL &&\n\t     strncmp(\"bsscfg:wsec_key\", data_buf, 15) == 0) ||\n\t    ioc->cmd == WLC_DISASSOC)\n\t\tdhd_wait_pend8021x(net);\n\n#ifdef WLMEDIA_HTSF\n\tif (data_buf) {\n\t\t/*  short cut wl ioctl calls here  */\n\t\tif (strcmp(\"htsf\", data_buf) == 0) {\n\t\t\tdhd_ioctl_htsf_get(dhd, 0);\n\t\t\treturn BCME_OK;\n\t\t}\n\n\t\tif (strcmp(\"htsflate\", data_buf) == 0) {\n\t\t\tif (ioc->set) {\n\t\t\t\tmemset(ts, 0, sizeof(tstamp_t)*TSMAX);\n\t\t\t\tmemset(&maxdelayts, 0, sizeof(tstamp_t));\n\t\t\t\tmaxdelay = 0;\n\t\t\t\ttspktcnt = 0;\n\t\t\t\tmaxdelaypktno = 0;\n\t\t\t\tmemset(&vi_d1.bin, 0, sizeof(uint32)*NUMBIN);\n\t\t\t\tmemset(&vi_d2.bin, 0, sizeof(uint32)*NUMBIN);\n\t\t\t\tmemset(&vi_d3.bin, 0, sizeof(uint32)*NUMBIN);\n\t\t\t\tmemset(&vi_d4.bin, 0, sizeof(uint32)*NUMBIN);\n\t\t\t} else {\n\t\t\t\tdhd_dump_latency();\n\t\t\t}\n\t\t\treturn BCME_OK;\n\t\t}\n\t\tif (strcmp(\"htsfclear\", data_buf) == 0) {\n\t\t\tmemset(&vi_d1.bin, 0, sizeof(uint32)*NUMBIN);\n\t\t\tmemset(&vi_d2.bin, 0, sizeof(uint32)*NUMBIN);\n\t\t\tmemset(&vi_d3.bin, 0, sizeof(uint32)*NUMBIN);\n\t\t\tmemset(&vi_d4.bin, 0, sizeof(uint32)*NUMBIN);\n\t\t\thtsf_seqnum = 0;\n\t\t\treturn BCME_OK;\n\t\t}\n\t\tif (strcmp(\"htsfhis\", data_buf) == 0) {\n\t\t\tdhd_dump_htsfhisto(&vi_d1, \"H to D\");\n\t\t\tdhd_dump_htsfhisto(&vi_d2, \"D to D\");\n\t\t\tdhd_dump_htsfhisto(&vi_d3, \"D to H\");\n\t\t\tdhd_dump_htsfhisto(&vi_d4, \"H to H\");\n\t\t\treturn BCME_OK;\n\t\t}\n\t\tif (strcmp(\"tsport\", data_buf) == 0) {\n\t\t\tif (ioc->set) {\n\t\t\t\tmemcpy(&tsport, data_buf + 7, 4);\n\t\t\t} else {\n\t\t\t\tDHD_ERROR((\"current timestamp port: %d \\n\", tsport));\n\t\t\t}\n\t\t\treturn BCME_OK;\n\t\t}\n\t}\n#endif /* WLMEDIA_HTSF */\n\n\tif ((ioc->cmd == WLC_SET_VAR || ioc->cmd == WLC_GET_VAR) &&\n\t\tdata_buf != NULL && strncmp(\"rpc_\", data_buf, 4) == 0) {\n#ifdef BCM_FD_AGGR\n\t\tbcmerror = dhd_fdaggr_ioctl(pub, ifidx, (wl_ioctl_t *)ioc, data_buf, buflen);\n#else\n\t\tbcmerror = BCME_UNSUPPORTED;\n#endif\n\t\tgoto done;\n\t}\n\tbcmerror = dhd_wl_ioctl(pub, ifidx, (wl_ioctl_t *)ioc, data_buf, buflen);\n\ndone:\n\tdhd_check_hang(net, pub, bcmerror);\n\n\treturn bcmerror;\n}\n\nstatic int\ndhd_ioctl_entry(struct net_device *net, struct ifreq *ifr, int cmd)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(net);\n\tdhd_ioctl_t ioc;\n\tint bcmerror = 0;\n\tint ifidx;\n\tint ret;\n\tvoid *local_buf = NULL;\n\tu16 buflen = 0;\n\n\tDHD_OS_WAKE_LOCK(&dhd->pub);\n\tDHD_PERIM_LOCK(&dhd->pub);\n\n\t/* Interface up check for built-in type */\n\tif (!dhd_download_fw_on_driverload && dhd->pub.up == 0) {\n\t\tDHD_ERROR((\"%s: Interface is down \\n\", __FUNCTION__));\n\t\tDHD_PERIM_UNLOCK(&dhd->pub);\n\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\t\treturn BCME_NOTUP;\n\t}\n\n\t/* send to dongle only if we are not waiting for reload already */\n\tif (dhd->pub.hang_was_sent) {\n\t\tDHD_ERROR((\"%s: HANG was sent up earlier\\n\", __FUNCTION__));\n\t\tDHD_OS_WAKE_LOCK_CTRL_TIMEOUT_ENABLE(&dhd->pub, DHD_EVENT_TIMEOUT_MS);\n\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\t\treturn OSL_ERROR(BCME_DONGLE_DOWN);\n\t}\n\n\tifidx = dhd_net2idx(dhd, net);\n\tDHD_TRACE((\"%s: ifidx %d, cmd 0x%04x\\n\", __FUNCTION__, ifidx, cmd));\n\n\tif (ifidx == DHD_BAD_IF) {\n\t\tDHD_ERROR((\"%s: BAD IF\\n\", __FUNCTION__));\n\t\tDHD_PERIM_UNLOCK(&dhd->pub);\n\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\t\treturn -1;\n\t}\n\n#if defined(WL_WIRELESS_EXT)\n\t/* linux wireless extensions */\n\tif ((cmd >= SIOCIWFIRST) && (cmd <= SIOCIWLAST)) {\n\t\t/* may recurse, do NOT lock */\n\t\tret = wl_iw_ioctl(net, ifr, cmd);\n\t\tDHD_PERIM_UNLOCK(&dhd->pub);\n\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\t\treturn ret;\n\t}\n#endif /* defined(WL_WIRELESS_EXT) */\n\n#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 4, 2)\n\tif (cmd == SIOCETHTOOL) {\n\t\tret = dhd_ethtool(dhd, (void*)ifr->ifr_data);\n\t\tDHD_PERIM_UNLOCK(&dhd->pub);\n\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\t\treturn ret;\n\t}\n#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 4, 2) */\n\n\tif (cmd == SIOCDEVPRIVATE+1) {\n\t\tret = wl_android_priv_cmd(net, ifr, cmd);\n\t\tdhd_check_hang(net, &dhd->pub, ret);\n\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\t\treturn ret;\n\t}\n\n\tif (cmd != SIOCDEVPRIVATE) {\n\t\tDHD_PERIM_UNLOCK(&dhd->pub);\n\t\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(&ioc, 0, sizeof(ioc));\n\n#ifdef CONFIG_COMPAT\n\tif (is_compat_task()) {\n\t\tcompat_wl_ioctl_t compat_ioc;\n\t\tif (copy_from_user(&compat_ioc, ifr->ifr_data, sizeof(compat_wl_ioctl_t))) {\n\t\t\tbcmerror = BCME_BADADDR;\n\t\t\tgoto done;\n\t\t}\n\t\tioc.cmd = compat_ioc.cmd;\n\t\tioc.buf = compat_ptr(compat_ioc.buf);\n\t\tioc.len = compat_ioc.len;\n\t\tioc.set = compat_ioc.set;\n\t\tioc.used = compat_ioc.used;\n\t\tioc.needed = compat_ioc.needed;\n\t\t/* To differentiate between wl and dhd read 4 more byes */\n\t\tif ((copy_from_user(&ioc.driver, (char *)ifr->ifr_data + sizeof(compat_wl_ioctl_t),\n\t\t\tsizeof(uint)) != 0)) {\n\t\t\tbcmerror = BCME_BADADDR;\n\t\t\tgoto done;\n\t\t}\n\t} else\n#endif /* CONFIG_COMPAT */\n\t{\n\t\t/* Copy the ioc control structure part of ioctl request */\n\t\tif (copy_from_user(&ioc, ifr->ifr_data, sizeof(wl_ioctl_t))) {\n\t\t\tbcmerror = BCME_BADADDR;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* To differentiate between wl and dhd read 4 more byes */\n\t\tif ((copy_from_user(&ioc.driver, (char *)ifr->ifr_data + sizeof(wl_ioctl_t),\n\t\t\tsizeof(uint)) != 0)) {\n\t\t\tbcmerror = BCME_BADADDR;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (!capable(CAP_NET_ADMIN)) {\n\t\tbcmerror = BCME_EPERM;\n\t\tgoto done;\n\t}\n\n\tif (ioc.len > 0) {\n\t\tbuflen = MIN(ioc.len, DHD_IOCTL_MAXLEN);\n\t\tif (!(local_buf = MALLOC(dhd->pub.osh, buflen+1))) {\n\t\t\tbcmerror = BCME_NOMEM;\n\t\t\tgoto done;\n\t\t}\n\n\t\tDHD_PERIM_UNLOCK(&dhd->pub);\n\t\tif (copy_from_user(local_buf, ioc.buf, buflen)) {\n\t\t\tDHD_PERIM_LOCK(&dhd->pub);\n\t\t\tbcmerror = BCME_BADADDR;\n\t\t\tgoto done;\n\t\t}\n\t\tDHD_PERIM_LOCK(&dhd->pub);\n\n\t\t*(char *)(local_buf + buflen) = '\\0';\n\t}\n\n\tbcmerror = dhd_ioctl_process(&dhd->pub, ifidx, &ioc, local_buf);\n\n\tif (!bcmerror && buflen && local_buf && ioc.buf) {\n\t\tDHD_PERIM_UNLOCK(&dhd->pub);\n\t\tif (copy_to_user(ioc.buf, local_buf, buflen))\n\t\t\tbcmerror = -EFAULT;\n\t\tDHD_PERIM_LOCK(&dhd->pub);\n\t}\n\ndone:\n\tif (local_buf)\n\t\tMFREE(dhd->pub.osh, local_buf, buflen+1);\n\n\tDHD_PERIM_UNLOCK(&dhd->pub);\n\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\n\treturn OSL_ERROR(bcmerror);\n}\n\n#define MAX_TRY_CNT             5 /* Number of tries to disable deepsleep */\nint dhd_deepsleep(dhd_info_t *dhd, int flag)\n{\n\tchar iovbuf[20];\n\tuint powervar = 0;\n\tdhd_pub_t *dhdp;\n\tint cnt = 0;\n\tint ret = 0;\n\n\tdhdp = &dhd->pub;\n\n\tswitch (flag) {\n\t\tcase 1 :  /* Deepsleep on */\n\t\t\tDHD_ERROR((\"dhd_deepsleep: ON\\n\"));\n\t\t\t/* give some time to sysioc_work before deepsleep */\n\t\t\tOSL_SLEEP(200);\n#ifdef PKT_FILTER_SUPPORT\n\t\t\t/* disable pkt filter */\n\t\t\tdhd_enable_packet_filter(0, dhdp);\n#endif /* PKT_FILTER_SUPPORT */\n\t\t\t/* Disable MPC */\n\t\t\tpowervar = 0;\n\t\t\tmemset(iovbuf, 0, sizeof(iovbuf));\n\t\t\tbcm_mkiovar(\"mpc\", (char *)&powervar, 4, iovbuf, sizeof(iovbuf));\n\t\t\tdhd_wl_ioctl_cmd(dhdp, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\n\t\t\t/* Enable Deepsleep */\n\t\t\tpowervar = 1;\n\t\t\tmemset(iovbuf, 0, sizeof(iovbuf));\n\t\t\tbcm_mkiovar(\"deepsleep\", (char *)&powervar, 4, iovbuf, sizeof(iovbuf));\n\t\t\tdhd_wl_ioctl_cmd(dhdp, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\t\t\tbreak;\n\n\t\tcase 0: /* Deepsleep Off */\n\t\t\tDHD_ERROR((\"dhd_deepsleep: OFF\\n\"));\n\n\t\t\t/* Disable Deepsleep */\n\t\t\tfor (cnt = 0; cnt < MAX_TRY_CNT; cnt++) {\n\t\t\t\tpowervar = 0;\n\t\t\t\tmemset(iovbuf, 0, sizeof(iovbuf));\n\t\t\t\tbcm_mkiovar(\"deepsleep\", (char *)&powervar, 4,\n\t\t\t\t\tiovbuf, sizeof(iovbuf));\n\t\t\t\tdhd_wl_ioctl_cmd(dhdp, WLC_SET_VAR, iovbuf,\n\t\t\t\t\tsizeof(iovbuf), TRUE, 0);\n\n\t\t\t\tmemset(iovbuf, 0, sizeof(iovbuf));\n\t\t\t\tbcm_mkiovar(\"deepsleep\", (char *)&powervar, 4,\n\t\t\t\t\tiovbuf, sizeof(iovbuf));\n\t\t\t\tif ((ret = dhd_wl_ioctl_cmd(dhdp, WLC_GET_VAR, iovbuf,\n\t\t\t\t\tsizeof(iovbuf),\tFALSE, 0)) < 0) {\n\t\t\t\t\tDHD_ERROR((\"the error of dhd deepsleep status\"\n\t\t\t\t\t\t\" ret value :%d\\n\", ret));\n\t\t\t\t} else {\n\t\t\t\t\tif (!(*(int *)iovbuf)) {\n\t\t\t\t\t\tDHD_ERROR((\"deepsleep mode is 0,\"\n\t\t\t\t\t\t\t\" count: %d\\n\", cnt));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Enable MPC */\n\t\t\tpowervar = 1;\n\t\t\tmemset(iovbuf, 0, sizeof(iovbuf));\n\t\t\tbcm_mkiovar(\"mpc\", (char *)&powervar, 4, iovbuf, sizeof(iovbuf));\n\t\t\tdhd_wl_ioctl_cmd(dhdp, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndhd_stop(struct net_device *net)\n{\n\tint ifidx = 0;\n\tdhd_info_t *dhd = DHD_DEV_INFO(net);\n\tDHD_OS_WAKE_LOCK(&dhd->pub);\n\tDHD_PERIM_LOCK(&dhd->pub);\n\tprintf(\"%s: Enter %p\\n\", __FUNCTION__, net);\n\tif (dhd->pub.up == 0) {\n\t\tgoto exit;\n\t}\n\n\tdhd_if_flush_sta(DHD_DEV_IFP(net));\n\n\n\tifidx = dhd_net2idx(dhd, net);\n\tBCM_REFERENCE(ifidx);\n\n\t/* Set state and stop OS transmissions */\n\tnetif_stop_queue(net);\n\tdhd->pub.up = 0;\n\n#ifdef WL_CFG80211\n\tif (ifidx == 0) {\n\t\twl_cfg80211_down(NULL);\n\n\t\t/*\n\t\t * For CFG80211: Clean up all the left over virtual interfaces\n\t\t * when the primary Interface is brought down. [ifconfig wlan0 down]\n\t\t */\n\t\tif (!dhd_download_fw_on_driverload) {\n\t\t\tif ((dhd->dhd_state & DHD_ATTACH_STATE_ADD_IF) &&\n\t\t\t\t(dhd->dhd_state & DHD_ATTACH_STATE_CFG80211)) {\n\t\t\t\tint i;\n\n\t\t\t\tdhd_net_if_lock_local(dhd);\n\t\t\t\tfor (i = 1; i < DHD_MAX_IFS; i++)\n\t\t\t\t\tdhd_remove_if(&dhd->pub, i, FALSE);\n\t\t\t\tdhd_net_if_unlock_local(dhd);\n\t\t\t}\n\t\t}\n\t}\n#endif /* WL_CFG80211 */\n\n#ifdef PROP_TXSTATUS\n\tdhd_wlfc_cleanup(&dhd->pub, NULL, 0);\n#endif\n\t/* Stop the protocol module */\n\tdhd_prot_stop(&dhd->pub);\n\n\tOLD_MOD_DEC_USE_COUNT;\nexit:\n\tif (ifidx == 0 && !dhd_download_fw_on_driverload) {\n\t\twl_android_wifi_off(net);\n#ifdef WL_EXT_APSTA\n\t\twl_android_ext_dettach_netdev();\n#endif\n\t} else {\n\t\tif (dhd->pub.conf->deepsleep)\n\t\t\tdhd_deepsleep(dhd, 1);\n\t}\n\tdhd->pub.rxcnt_timeout = 0;\n\tdhd->pub.txcnt_timeout = 0;\n\n\tdhd->pub.hang_was_sent = 0;\n\n\t/* Clear country spec for for built-in type driver */\n\tif (!dhd_download_fw_on_driverload) {\n\t\tdhd->pub.dhd_cspec.country_abbrev[0] = 0x00;\n\t\tdhd->pub.dhd_cspec.rev = 0;\n\t\tdhd->pub.dhd_cspec.ccode[0] = 0x00;\n\t}\n\n\tprintf(\"%s: Exit\\n\", __FUNCTION__);\n\tDHD_PERIM_UNLOCK(&dhd->pub);\n\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\treturn 0;\n}\n\n#if defined(WL_CFG80211) && defined(USE_INITIAL_SHORT_DWELL_TIME)\nextern bool g_first_broadcast_scan;\n#endif \n\n#ifdef WL11U\nstatic int dhd_interworking_enable(dhd_pub_t *dhd)\n{\n\tchar iovbuf[WLC_IOCTL_SMLEN];\n\tuint32 enable = true;\n\tint ret = BCME_OK;\n\n\tbcm_mkiovar(\"interworking\", (char *)&enable, sizeof(enable), iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s: enableing interworking failed, ret=%d\\n\", __FUNCTION__, ret));\n\t}\n\n\tif (ret == BCME_OK) {\n\t\t/* basic capabilities for HS20 REL2 */\n\t\tuint32 cap = WL_WNM_BSSTRANS | WL_WNM_NOTIF;\n\t\tbcm_mkiovar(\"wnm\", (char *)&cap, sizeof(cap), iovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR,\n\t\t\tiovbuf, sizeof(iovbuf), TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s: failed to set WNM info, ret=%d\\n\", __FUNCTION__, ret));\n\t\t}\n\t}\n\n\treturn ret;\n}\n#endif /* WL11u */\n\n\n\n#if 0\nstatic int\ndhd_open(struct net_device *net)\n#else\nint dhd_open(struct net_device *net)\n#endif\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(net);\n\n\tgNet = net;\n#ifdef TOE\n\tuint32 toe_ol;\n#endif\n\tint ifidx;\n\tint32 ret = 0;\n        printk(\"KKS:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\r\\n\");\n         printf(\"KKS:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa==1\\r\\n\");\n\tprintf(\"%s: Enter %p\\n\", __FUNCTION__, net);\n#if defined(MULTIPLE_SUPPLICANT)\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1\n\tif (mutex_is_locked(&_dhd_sdio_mutex_lock_) != 0) {\n\t\tDHD_ERROR((\"%s : dhd_open: call dev open before insmod complete!\\n\", __FUNCTION__));\n\t}\n\tmutex_lock(&_dhd_sdio_mutex_lock_);\n#endif\n#endif /* MULTIPLE_SUPPLICANT */\n\n\tDHD_OS_WAKE_LOCK(&dhd->pub);\n\tDHD_PERIM_LOCK(&dhd->pub);\n\tdhd->pub.dongle_trap_occured = 0;\n\tdhd->pub.hang_was_sent = 0;\n\n#if 0\n\t/*\n\t * Force start if ifconfig_up gets called before START command\n\t *  We keep WEXT's wl_control_wl_start to provide backward compatibility\n\t *  This should be removed in the future\n\t */\n\tret = wl_control_wl_start(net);\n\tif (ret != 0) {\n\t\tDHD_ERROR((\"%s: failed with code %d\\n\", __FUNCTION__, ret));\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n#endif\n\n\tifidx = dhd_net2idx(dhd, net);\n\tDHD_TRACE((\"%s: ifidx %d\\n\", __FUNCTION__, ifidx));\n\n\tif (ifidx < 0) {\n\t\tDHD_ERROR((\"%s: Error: called with invalid IF\\n\", __FUNCTION__));\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n\n\tif (!dhd->iflist[ifidx]) {\n\t\tDHD_ERROR((\"%s: Error: called when IF already deleted\\n\", __FUNCTION__));\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n\n\tif (ifidx == 0) {\n\t\tatomic_set(&dhd->pend_8021x_cnt, 0);\n\t\tif (!dhd_download_fw_on_driverload) {\n\t\t\tDHD_ERROR((\"\\n%s\\n\", dhd_version));\n#if defined(USE_INITIAL_SHORT_DWELL_TIME)\n\t\t\tg_first_broadcast_scan = TRUE;\n#endif \n\t\t\t printf(\"KKS:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa==2\\r\\n\");\n\t\t\tret = wl_android_wifi_on(net);\n\t\t\tif (ret != 0) {\n\t\t\t\tDHD_ERROR((\"%s : wl_android_wifi_on failed (%d)\\n\",\n\t\t\t\t\t__FUNCTION__, ret));\n\t\t\t\tret = -1;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif (dhd->pub.busstate != DHD_BUS_DATA) {\n\n\t\t\t/* try to bring up bus */\n\t\t\tDHD_PERIM_UNLOCK(&dhd->pub);\n\t\t\tret = dhd_bus_start(&dhd->pub);\n\t\t\tDHD_PERIM_LOCK(&dhd->pub);\n\t\t\tif (ret) {\n\t\t\t\tDHD_ERROR((\"%s: failed with code %d\\n\", __FUNCTION__, ret));\n\t\t\t\tret = -1;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t}\n\t\tif (dhd_download_fw_on_driverload) {\n\t\t\tif (dhd->pub.conf->deepsleep)\n\t\t\t\tdhd_deepsleep(dhd, 0);\n\t\t}\n\n\t\t/* dhd_sync_with_dongle has been called in dhd_bus_start or wl_android_wifi_on */\n\t\tmemcpy(net->dev_addr, dhd->pub.mac.octet, ETHER_ADDR_LEN);\n\n#ifdef TOE\n\t\t/* Get current TOE mode from dongle */\n\t\tif (dhd_toe_get(dhd, ifidx, &toe_ol) >= 0 && (toe_ol & TOE_TX_CSUM_OL) != 0)\n\t\t\tdhd->iflist[ifidx]->net->features |= NETIF_F_IP_CSUM;\n\t\telse\n\t\t\tdhd->iflist[ifidx]->net->features &= ~NETIF_F_IP_CSUM;\n#endif /* TOE */\n\n#if defined(WL_CFG80211)\n\t\tif (unlikely(wl_cfg80211_up(NULL))) {\n\t\t\tDHD_ERROR((\"%s: failed to bring up cfg80211\\n\", __FUNCTION__));\n\t\t\tret = -1;\n\t\t\tgoto exit;\n\t\t}\n\t\tdhd_set_scb_probe(&dhd->pub);\n#endif /* WL_CFG80211 */\n\t}\n\n\t/* Allow transmit calls */\n\tnetif_start_queue(net);\n\tdhd->pub.up = 1;\n\n#ifdef BCMDBGFS\n\tdhd_dbg_init(&dhd->pub);\n#endif\n\n\tOLD_MOD_INC_USE_COUNT;\nexit:\n\tif (ret)\n\t\tdhd_stop(net);\n\n\tDHD_PERIM_UNLOCK(&dhd->pub);\n\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\n#if defined(MULTIPLE_SUPPLICANT)\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1\n\tmutex_unlock(&_dhd_sdio_mutex_lock_);\n#endif\n#endif /* MULTIPLE_SUPPLICANT */\n\n\tprintf(\"%s: Exit ret=%d\\n\", __FUNCTION__, ret);\n\treturn ret;\n}\n\nint dhd_do_driver_init(struct net_device *net)\n{\n\tdhd_info_t *dhd = NULL;\n\n\n\tif (!net) {\n\t\tDHD_ERROR((\"Primary Interface not initialized \\n\"));\n\t\treturn -EINVAL;\n\t}\n\n#ifdef MULTIPLE_SUPPLICANT\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1 && defined(BCMSDIO)\n\tif (mutex_is_locked(&_dhd_sdio_mutex_lock_) != 0) {\n\t\tDHD_ERROR((\"%s : dhdsdio_probe is already running!\\n\", __FUNCTION__));\n\t\treturn 0;\n\t}\n#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) */\n#endif /* MULTIPLE_SUPPLICANT */\n\n\t/*  && defined(OEM_ANDROID) && defined(BCMSDIO) */\n\tdhd = DHD_DEV_INFO(net);\n\n\t/* If driver is already initialized, do nothing\n\t */\n\tif (dhd->pub.busstate == DHD_BUS_DATA) {\n\t\tDHD_TRACE((\"Driver already Inititalized. Nothing to do\"));\n\t\treturn 0;\n\t}\n\n    printf(\"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\\r\\n\");\n\tif (dhd_open(net) < 0) {\n\t\tDHD_ERROR((\"Driver Init Failed \\n\"));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint\ndhd_event_ifadd(dhd_info_t *dhdinfo, wl_event_data_if_t *ifevent, char *name, uint8 *mac)\n{\n\n#ifdef WL_CFG80211\n\tif (wl_cfg80211_notify_ifadd(ifevent->ifidx, name, mac, ifevent->bssidx) == BCME_OK)\n\t\treturn BCME_OK;\n#endif\n\n\t/* handle IF event caused by wl commands, SoftAP, WEXT and\n\t * anything else. This has to be done asynchronously otherwise\n\t * DPC will be blocked (and iovars will timeout as DPC has no chance\n\t * to read the response back)\n\t */\n\tif (ifevent->ifidx > 0) {\n\t\tdhd_if_event_t *if_event = MALLOC(dhdinfo->pub.osh, sizeof(dhd_if_event_t));\n\n\t\tmemcpy(&if_event->event, ifevent, sizeof(if_event->event));\n\t\tmemcpy(if_event->mac, mac, ETHER_ADDR_LEN);\n\t\tstrncpy(if_event->name, name, IFNAMSIZ);\n\t\tif_event->name[IFNAMSIZ - 1] = '\\0';\n\t\tdhd_deferred_schedule_work(dhdinfo->dhd_deferred_wq, (void *)if_event,\n\t\t\tDHD_WQ_WORK_IF_ADD, dhd_ifadd_event_handler, DHD_WORK_PRIORITY_LOW);\n\t}\n\n\treturn BCME_OK;\n}\n\nint\ndhd_event_ifdel(dhd_info_t *dhdinfo, wl_event_data_if_t *ifevent, char *name, uint8 *mac)\n{\n\tdhd_if_event_t *if_event;\n\n#if defined(WL_CFG80211) && !defined(P2PONEINT)\n\tif (wl_cfg80211_notify_ifdel(ifevent->ifidx, name, mac, ifevent->bssidx) == BCME_OK)\n\t\treturn BCME_OK;\n#endif /* WL_CFG80211 */\n\n\t/* handle IF event caused by wl commands, SoftAP, WEXT and\n\t * anything else\n\t */\n\tif_event = MALLOC(dhdinfo->pub.osh, sizeof(dhd_if_event_t));\n\tmemcpy(&if_event->event, ifevent, sizeof(if_event->event));\n\tmemcpy(if_event->mac, mac, ETHER_ADDR_LEN);\n\tstrncpy(if_event->name, name, IFNAMSIZ);\n\tif_event->name[IFNAMSIZ - 1] = '\\0';\n\tdhd_deferred_schedule_work(dhdinfo->dhd_deferred_wq, (void *)if_event, DHD_WQ_WORK_IF_DEL,\n\t\tdhd_ifdel_event_handler, DHD_WORK_PRIORITY_LOW);\n\n\treturn BCME_OK;\n}\n\n/* unregister and free the existing net_device interface (if any) in iflist and\n * allocate a new one. the slot is reused. this function does NOT register the\n * new interface to linux kernel. dhd_register_if does the job\n */\nstruct net_device*\ndhd_allocate_if(dhd_pub_t *dhdpub, int ifidx, char *name,\n\tuint8 *mac, uint8 bssidx, bool need_rtnl_lock)\n{\n\tdhd_info_t *dhdinfo = (dhd_info_t *)dhdpub->info;\n\tdhd_if_t *ifp;\n\n\tASSERT(dhdinfo && (ifidx < DHD_MAX_IFS));\n\tifp = dhdinfo->iflist[ifidx];\n\n\tif (ifp != NULL) {\n\t\tif (ifp->net != NULL) {\n\t\t\tDHD_ERROR((\"%s: free existing IF %s\\n\", __FUNCTION__, ifp->net->name));\n\n\t\t\tdhd_dev_priv_clear(ifp->net); /* clear net_device private */\n\n\t\t\t/* in unregister_netdev case, the interface gets freed by net->destructor\n\t\t\t * (which is set to free_netdev)\n\t\t\t */\n\t\t\tif (ifp->net->reg_state == NETREG_UNINITIALIZED) {\n\t\t\t\tfree_netdev(ifp->net);\n\t\t\t} else {\n\t\t\t\tnetif_stop_queue(ifp->net);\n\t\t\t\tif (need_rtnl_lock)\n\t\t\t\t\tunregister_netdev(ifp->net);\n\t\t\t\telse\n\t\t\t\t\tunregister_netdevice(ifp->net);\n\t\t\t}\n\t\t\tifp->net = NULL;\n\t\t}\n\t} else {\n\t\tifp = MALLOC(dhdinfo->pub.osh, sizeof(dhd_if_t));\n\t\tif (ifp == NULL) {\n\t\t\tDHD_ERROR((\"%s: OOM - dhd_if_t(%zu)\\n\", __FUNCTION__, sizeof(dhd_if_t)));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tmemset(ifp, 0, sizeof(dhd_if_t));\n\tifp->info = dhdinfo;\n\tifp->idx = ifidx;\n\tifp->bssidx = bssidx;\n\tif (mac != NULL)\n\t\tmemcpy(&ifp->mac_addr, mac, ETHER_ADDR_LEN);\n\n\t/* Allocate etherdev, including space for private structure */\n\tifp->net = alloc_etherdev(DHD_DEV_PRIV_SIZE);\n\tif (ifp->net == NULL) {\n\t\tDHD_ERROR((\"%s: OOM - alloc_etherdev(%zu)\\n\", __FUNCTION__, sizeof(dhdinfo)));\n\t\tgoto fail;\n\t}\n\n\t/* Setup the dhd interface's netdevice private structure. */\n\tdhd_dev_priv_save(ifp->net, dhdinfo, ifp, ifidx);\n\n\tif (name && name[0]) {\n\t\tstrncpy(ifp->net->name, name, IFNAMSIZ);\n\t\tifp->net->name[IFNAMSIZ - 1] = '\\0';\n\t}\n#ifdef WL_CFG80211\n\tif (ifidx == 0)\n\t\tifp->net->destructor = free_netdev;\n\telse\n\t\tifp->net->destructor = dhd_netdev_free;\n#else\n\tifp->net->destructor = free_netdev;\n#endif /* WL_CFG80211 */\n\tstrncpy(ifp->name, ifp->net->name, IFNAMSIZ);\n\tifp->name[IFNAMSIZ - 1] = '\\0';\n\tdhdinfo->iflist[ifidx] = ifp;\n\n#ifdef PCIE_FULL_DONGLE\n\t/* Initialize STA info list */\n\tINIT_LIST_HEAD(&ifp->sta_list);\n\tDHD_IF_STA_LIST_LOCK_INIT(ifp);\n#endif /* PCIE_FULL_DONGLE */\n\n\treturn ifp->net;\n\nfail:\n\tif (ifp != NULL) {\n\t\tif (ifp->net != NULL) {\n\t\t\tdhd_dev_priv_clear(ifp->net);\n\t\t\tfree_netdev(ifp->net);\n\t\t\tifp->net = NULL;\n\t\t}\n\t\tMFREE(dhdinfo->pub.osh, ifp, sizeof(*ifp));\n\t\tifp = NULL;\n\t}\n\tdhdinfo->iflist[ifidx] = NULL;\n\treturn NULL;\n}\n\n/* unregister and free the the net_device interface associated with the indexed\n * slot, also free the slot memory and set the slot pointer to NULL\n */\nint\ndhd_remove_if(dhd_pub_t *dhdpub, int ifidx, bool need_rtnl_lock)\n{\n\tdhd_info_t *dhdinfo = (dhd_info_t *)dhdpub->info;\n\tdhd_if_t *ifp;\n\n\tifp = dhdinfo->iflist[ifidx];\n\tif (ifp != NULL) {\n\t\tif (ifp->net != NULL) {\n\t\t\tDHD_ERROR((\"deleting interface '%s' idx %d\\n\", ifp->net->name, ifp->idx));\n\n\t\t\t/* in unregister_netdev case, the interface gets freed by net->destructor\n\t\t\t * (which is set to free_netdev)\n\t\t\t */\n\t\t\tif (ifp->net->reg_state == NETREG_UNINITIALIZED) {\n\t\t\t\tfree_netdev(ifp->net);\n\t\t\t} else {\n\t\t\t\tnetif_stop_queue(ifp->net);\n\n\n\n#ifdef SET_RPS_CPUS\n\t\t\t\tcustom_rps_map_clear(ifp->net->_rx);\n#endif /* SET_RPS_CPUS */\n\t\t\t\tif (need_rtnl_lock)\n\t\t\t\t\tunregister_netdev(ifp->net);\n\t\t\t\telse\n\t\t\t\t\tunregister_netdevice(ifp->net);\n\t\t\t}\n\t\t\tifp->net = NULL;\n\t\t}\n#ifdef DHD_WMF\n\t\tdhd_wmf_cleanup(dhdpub, ifidx);\n#endif /* DHD_WMF */\n\n\t\tdhd_if_del_sta_list(ifp);\n\n\t\tdhdinfo->iflist[ifidx] = NULL;\n\t\tMFREE(dhdinfo->pub.osh, ifp, sizeof(*ifp));\n\n\t}\n\n\treturn BCME_OK;\n}\n\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31))\nstatic struct net_device_ops dhd_ops_pri = {\n\t.ndo_open = dhd_open,\n\t.ndo_stop = dhd_stop,\n\t.ndo_get_stats = dhd_get_stats,\n\t.ndo_do_ioctl = dhd_ioctl_entry,\n\t.ndo_start_xmit = dhd_start_xmit,\n\t.ndo_set_mac_address = dhd_set_mac_address,\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))\n\t.ndo_set_rx_mode = dhd_set_multicast_list,\n#else\n\t.ndo_set_multicast_list = dhd_set_multicast_list,\n#endif\n};\n\nstatic struct net_device_ops dhd_ops_virt = {\n\t.ndo_get_stats = dhd_get_stats,\n\t.ndo_do_ioctl = dhd_ioctl_entry,\n\t.ndo_start_xmit = dhd_start_xmit,\n\t.ndo_set_mac_address = dhd_set_mac_address,\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))\n\t.ndo_set_rx_mode = dhd_set_multicast_list,\n#else\n\t.ndo_set_multicast_list = dhd_set_multicast_list,\n#endif\n};\n\n#ifdef P2PONEINT\nextern int wl_cfgp2p_if_open(struct net_device *net);\nextern int wl_cfgp2p_if_stop(struct net_device *net);\n\nstatic struct net_device_ops dhd_cfgp2p_ops_virt = {\n\t.ndo_open = wl_cfgp2p_if_open,\n\t.ndo_stop = wl_cfgp2p_if_stop,\n\t.ndo_get_stats = dhd_get_stats,\n\t.ndo_do_ioctl = dhd_ioctl_entry,\n\t.ndo_start_xmit = dhd_start_xmit,\n\t.ndo_set_mac_address = dhd_set_mac_address,\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))\n\t.ndo_set_rx_mode = dhd_set_multicast_list,\n#else\n\t.ndo_set_multicast_list = dhd_set_multicast_list,\n#endif\n};\n#endif /* P2PONEINT */\n#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31)) */\n\n#ifdef DEBUGGER\nextern void debugger_init(void *bus_handle);\n#endif\n\n\n#ifdef SHOW_LOGTRACE\nstatic char *logstrs_path = \"/root/logstrs.bin\";\nmodule_param(logstrs_path, charp, S_IRUGO);\n\nint\ndhd_init_logstrs_array(dhd_event_log_t *temp)\n{\n\tstruct file *filep = NULL;\n\tstruct kstat stat;\n\tmm_segment_t fs;\n\tchar *raw_fmts =  NULL;\n\tint logstrs_size = 0;\n\n\tlogstr_header_t *hdr = NULL;\n\tuint32 *lognums = NULL;\n\tchar *logstrs = NULL;\n\tint ram_index = 0;\n\tchar **fmts;\n\tint num_fmts = 0;\n\tuint32 i = 0;\n\tint error = 0;\n\tset_fs(KERNEL_DS);\n\tfs = get_fs();\n\tfilep = filp_open(logstrs_path, O_RDONLY, 0);\n\tif (IS_ERR(filep)) {\n\t\tDHD_ERROR((\"Failed to open the file logstrs.bin in %s\\n\",  __FUNCTION__));\n\t\tgoto fail;\n\t}\n\terror = vfs_stat(logstrs_path, &stat);\n\tif (error) {\n\t\tDHD_ERROR((\"Failed in %s to find file stat\\n\", __FUNCTION__));\n\t\tgoto fail;\n\t}\n\tlogstrs_size = (int) stat.size;\n\n\traw_fmts = kmalloc(logstrs_size, GFP_KERNEL);\n\tif (raw_fmts == NULL) {\n\t\tDHD_ERROR((\"Failed to allocate raw_fmts memory\\n\"));\n\t\tgoto fail;\n\t}\n\tif (vfs_read(filep, raw_fmts, logstrs_size, &filep->f_pos) !=\tlogstrs_size) {\n\t\tDHD_ERROR((\"Error: Log strings file read failed\\n\"));\n\t\tgoto fail;\n\t}\n\n\t/* Remember header from the logstrs.bin file */\n\thdr = (logstr_header_t *) (raw_fmts + logstrs_size -\n\t\tsizeof(logstr_header_t));\n\n\tif (hdr->log_magic == LOGSTRS_MAGIC) {\n\t\t/*\n\t\t* logstrs.bin start with header.\n\t\t*/\n\t\tnum_fmts =\thdr->rom_logstrs_offset / sizeof(uint32);\n\t\tram_index = (hdr->ram_lognums_offset -\n\t\t\thdr->rom_lognums_offset) / sizeof(uint32);\n\t\tlognums = (uint32 *) &raw_fmts[hdr->rom_lognums_offset];\n\t\tlogstrs = (char *)\t &raw_fmts[hdr->rom_logstrs_offset];\n\t} else {\n\t\t/*\n\t\t * Legacy logstrs.bin format without header.\n\t\t */\n\t\tnum_fmts = *((uint32 *) (raw_fmts)) / sizeof(uint32);\n\t\tif (num_fmts == 0) {\n\t\t\t/* Legacy ROM/RAM logstrs.bin format:\n\t\t\t  *  - ROM 'lognums' section\n\t\t\t  *   - RAM 'lognums' section\n\t\t\t  *   - ROM 'logstrs' section.\n\t\t\t  *   - RAM 'logstrs' section.\n\t\t\t  *\n\t\t\t  * 'lognums' is an array of indexes for the strings in the\n\t\t\t  * 'logstrs' section. The first uint32 is 0 (index of first\n\t\t\t  * string in ROM 'logstrs' section).\n\t\t\t  *\n\t\t\t  * The 4324b5 is the only ROM that uses this legacy format. Use the\n\t\t\t  * fixed number of ROM fmtnums to find the start of the RAM\n\t\t\t  * 'lognums' section. Use the fixed first ROM string (\"Con\\n\") to\n\t\t\t  * find the ROM 'logstrs' section.\n\t\t\t  */\n\t\t\t#define NUM_4324B5_ROM_FMTS\t186\n\t\t\t#define FIRST_4324B5_ROM_LOGSTR \"Con\\n\"\n\t\t\tram_index = NUM_4324B5_ROM_FMTS;\n\t\t\tlognums = (uint32 *) raw_fmts;\n\t\t\tnum_fmts =\tram_index;\n\t\t\tlogstrs = (char *) &raw_fmts[num_fmts << 2];\n\t\t\twhile (strncmp(FIRST_4324B5_ROM_LOGSTR, logstrs, 4)) {\n\t\t\t\tnum_fmts++;\n\t\t\t\tlogstrs = (char *) &raw_fmts[num_fmts << 2];\n\t\t\t}\n\t\t} else {\n\t\t\t\t/* Legacy RAM-only logstrs.bin format:\n\t\t\t\t *\t  - RAM 'lognums' section\n\t\t\t\t *\t  - RAM 'logstrs' section.\n\t\t\t\t *\n\t\t\t\t * 'lognums' is an array of indexes for the strings in the\n\t\t\t\t * 'logstrs' section. The first uint32 is an index to the\n\t\t\t\t * start of 'logstrs'. Therefore, if this index is divided\n\t\t\t\t * by 'sizeof(uint32)' it provides the number of logstr\n\t\t\t\t *\tentries.\n\t\t\t\t */\n\t\t\t\tram_index = 0;\n\t\t\t\tlognums = (uint32 *) raw_fmts;\n\t\t\t\tlogstrs = (char *)\t&raw_fmts[num_fmts << 2];\n\t\t\t}\n\t}\n\tfmts = kmalloc(num_fmts  * sizeof(char *), GFP_KERNEL);\n\tif (fmts == NULL) {\n\t\tDHD_ERROR((\"Failed to allocate fmts memory\\n\"));\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < num_fmts; i++) {\n\t\t/* ROM lognums index into logstrs using 'rom_logstrs_offset' as a base\n\t\t* (they are 0-indexed relative to 'rom_logstrs_offset').\n\t\t*\n\t\t* RAM lognums are already indexed to point to the correct RAM logstrs (they\n\t\t* are 0-indexed relative to the start of the logstrs.bin file).\n\t\t*/\n\t\tif (i == ram_index) {\n\t\t\tlogstrs = raw_fmts;\n\t\t}\n\t\tfmts[i] = &logstrs[lognums[i]];\n\t}\n\ttemp->fmts = fmts;\n\ttemp->raw_fmts = raw_fmts;\n\ttemp->num_fmts = num_fmts;\n\tfilp_close(filep, NULL);\n\tset_fs(fs);\n\treturn 0;\nfail:\n\tif (raw_fmts) {\n\t\tkfree(raw_fmts);\n\t\traw_fmts = NULL;\n\t}\n\tif (!IS_ERR(filep))\n\t\tfilp_close(filep, NULL);\n\tset_fs(fs);\n\ttemp->fmts = NULL;\n\treturn -1;\n}\n#endif /* SHOW_LOGTRACE */\n\n\ndhd_pub_t *\ndhd_attach(osl_t *osh, struct dhd_bus *bus, uint bus_hdrlen)\n{\n\tdhd_info_t *dhd = NULL;\n\tstruct net_device *net = NULL;\n\tchar if_name[IFNAMSIZ] = {'\\0'};\n\tuint32 bus_type = -1;\n\tuint32 bus_num = -1;\n\tuint32 slot_num = -1;\n\twifi_adapter_info_t *adapter = NULL;\n\n\tdhd_attach_states_t dhd_state = DHD_ATTACH_STATE_INIT;\n\tDHD_TRACE((\"%s: Enter\\n\", __FUNCTION__));\n\n\t/* will implement get_ids for DBUS later */\n#if defined(BCMSDIO)\n\tdhd_bus_get_ids(bus, &bus_type, &bus_num, &slot_num);\n#endif \n\tadapter = dhd_wifi_platform_get_adapter(bus_type, bus_num, slot_num);\n\n\t/* Allocate primary dhd_info */\n\tdhd = wifi_platform_prealloc(adapter, DHD_PREALLOC_DHD_INFO, sizeof(dhd_info_t));\n\tif (dhd == NULL) {\n\t\tdhd = MALLOC(osh, sizeof(dhd_info_t));\n\t\tif (dhd == NULL) {\n\t\t\tDHD_ERROR((\"%s: OOM - alloc dhd_info\\n\", __FUNCTION__));\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tmemset(dhd, 0, sizeof(dhd_info_t));\n\tdhd_state |= DHD_ATTACH_STATE_DHD_ALLOC;\n\n\tdhd->unit = dhd_found + instance_base; /* do not increment dhd_found, yet */\n\n\tdhd->pub.osh = osh;\n\tdhd->adapter = adapter;\n\n#ifdef GET_CUSTOM_MAC_ENABLE\n\twifi_platform_get_mac_addr(dhd->adapter, dhd->pub.mac.octet);\n#endif /* GET_CUSTOM_MAC_ENABLE */\n\tdhd->thr_dpc_ctl.thr_pid = DHD_PID_KT_TL_INVALID;\n\tdhd->thr_wdt_ctl.thr_pid = DHD_PID_KT_INVALID;\n\n\t/* Initialize thread based operation and lock */\n\tsema_init(&dhd->sdsem, 1);\n\n\t/* Link to info module */\n\tdhd->pub.info = dhd;\n\n\n\t/* Link to bus module */\n\tdhd->pub.bus = bus;\n\tdhd->pub.hdrlen = bus_hdrlen;\n\n\t/* dhd_conf must be attached after linking dhd to dhd->pub.info,\n\t * because dhd_detech will check .info is NULL or not.\n\t*/\n\tif (dhd_conf_attach(&dhd->pub) != 0) {\n\t\tDHD_ERROR((\"dhd_conf_attach failed\\n\"));\n\t\tgoto fail;\n\t}\n\tdhd_conf_reset(&dhd->pub);\n\tdhd_conf_set_chiprev(&dhd->pub, dhd_bus_chip(bus), dhd_bus_chiprev(bus));\n\tdhd_conf_preinit(&dhd->pub);\n\n\t/* Some DHD modules (e.g. cfg80211) configures operation mode based on firmware name.\n\t * This is indeed a hack but we have to make it work properly before we have a better\n\t * solution\n\t */\n\tdhd_update_fw_nv_path(dhd);\n#ifndef BUILD_IN_KERNEL\n\tdhd_conf_read_config(&dhd->pub, dhd->conf_path);\n#endif\n\n\t/* Set network interface name if it was provided as module parameter */\n\tif (iface_name[0]) {\n\t\tint len;\n\t\tchar ch;\n\t\tstrncpy(if_name, iface_name, IFNAMSIZ);\n\t\tif_name[IFNAMSIZ - 1] = 0;\n\t\tlen = strlen(if_name);\n\t\tch = if_name[len - 1];\n\t\tif ((ch > '9' || ch < '0') && (len < IFNAMSIZ - 2))\n\t\t\tstrcat(if_name, \"%d\");\n\t}\n\tnet = dhd_allocate_if(&dhd->pub, 0, if_name, NULL, 0, TRUE);\n\tif (net == NULL)\n\t\tgoto fail;\n\tdhd_state |= DHD_ATTACH_STATE_ADD_IF;\n\n#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31))\n\tnet->open = NULL;\n#else\n\tnet->netdev_ops = NULL;\n#endif\n\n\tsema_init(&dhd->proto_sem, 1);\n\n#ifdef PROP_TXSTATUS\n\tspin_lock_init(&dhd->wlfc_spinlock);\n\n\tdhd->pub.skip_fc = dhd_wlfc_skip_fc;\n\tdhd->pub.plat_init = dhd_wlfc_plat_init;\n\tdhd->pub.plat_deinit = dhd_wlfc_plat_deinit;\n#endif /* PROP_TXSTATUS */\n\n\t/* Initialize other structure content */\n\tinit_waitqueue_head(&dhd->ioctl_resp_wait);\n\tinit_waitqueue_head(&dhd->ctrl_wait);\n\n\t/* Initialize the spinlocks */\n\tspin_lock_init(&dhd->sdlock);\n\tspin_lock_init(&dhd->txqlock);\n\tspin_lock_init(&dhd->dhd_lock);\n\tspin_lock_init(&dhd->rxf_lock);\n#if defined(RXFRAME_THREAD)\n\tdhd->rxthread_enabled = TRUE;\n#endif /* defined(RXFRAME_THREAD) */\n\n#ifdef DHDTCPACK_SUPPRESS\n\tspin_lock_init(&dhd->tcpack_lock);\n#endif /* DHDTCPACK_SUPPRESS */\n\n\t/* Initialize Wakelock stuff */\n\tspin_lock_init(&dhd->wakelock_spinlock);\n\tdhd->wakelock_counter = 0;\n\tdhd->wakelock_wd_counter = 0;\n\tdhd->wakelock_rx_timeout_enable = 0;\n\tdhd->wakelock_ctrl_timeout_enable = 0;\n#ifdef CONFIG_HAS_WAKELOCK\n\twake_lock_init(&dhd->wl_wifi, WAKE_LOCK_SUSPEND, \"wlan_wake\");\n\twake_lock_init(&dhd->wl_rxwake, WAKE_LOCK_SUSPEND, \"wlan_rx_wake\");\n\twake_lock_init(&dhd->wl_ctrlwake, WAKE_LOCK_SUSPEND, \"wlan_ctrl_wake\");\n\twake_lock_init(&dhd->wl_wdwake, WAKE_LOCK_SUSPEND, \"wlan_wd_wake\");\n#ifdef BCMPCIE_OOB_HOST_WAKE\n\twake_lock_init(&dhd->wl_intrwake, WAKE_LOCK_SUSPEND, \"wlan_oob_irq_wake\");\n#endif /* BCMPCIE_OOB_HOST_WAKE */\n#endif /* CONFIG_HAS_WAKELOCK */\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1\n\tmutex_init(&dhd->dhd_net_if_mutex);\n\tmutex_init(&dhd->dhd_suspend_mutex);\n#endif\n\tdhd_state |= DHD_ATTACH_STATE_WAKELOCKS_INIT;\n\n\t/* Attach and link in the protocol */\n\tif (dhd_prot_attach(&dhd->pub) != 0) {\n\t\tDHD_ERROR((\"dhd_prot_attach failed\\n\"));\n\t\tgoto fail;\n\t}\n\tdhd_state |= DHD_ATTACH_STATE_PROT_ATTACH;\n\n#ifdef WL_CFG80211\n\t/* Attach and link in the cfg80211 */\n\tif (unlikely(wl_cfg80211_attach(net, &dhd->pub))) {\n\t\tDHD_ERROR((\"wl_cfg80211_attach failed\\n\"));\n\t\tgoto fail;\n\t}\n\n\tdhd_monitor_init(&dhd->pub);\n\tdhd_state |= DHD_ATTACH_STATE_CFG80211;\n#endif\n#if defined(WL_WIRELESS_EXT)\n\t/* Attach and link in the iw */\n\tif (!(dhd_state &  DHD_ATTACH_STATE_CFG80211)) {\n\t\tif (wl_iw_attach(net, (void *)&dhd->pub) != 0) {\n\t\t\tDHD_ERROR((\"wl_iw_attach failed\\n\"));\n\t\t\tgoto fail;\n\t\t}\n\t\tdhd_state |= DHD_ATTACH_STATE_WL_ATTACH;\n\t}\n#ifdef WL_ESCAN\n\twl_escan_attach(net, (void *)&dhd->pub);\n#endif\n#endif /* defined(WL_WIRELESS_EXT) */\n\n#ifdef SHOW_LOGTRACE\n\tdhd_init_logstrs_array(&dhd->event_data);\n#endif /* SHOW_LOGTRACE */\n\n\tif (dhd_sta_pool_init(&dhd->pub, DHD_MAX_STA) != BCME_OK) {\n\t\tDHD_ERROR((\"%s: Initializing %u sta\\n\", __FUNCTION__, DHD_MAX_STA));\n\t\tgoto fail;\n\t}\n\n\n\t/* Set up the watchdog timer */\n\tinit_timer(&dhd->timer);\n\tdhd->timer.data = (ulong)dhd;\n\tdhd->timer.function = dhd_watchdog;\n\tdhd->default_wd_interval = dhd_watchdog_ms;\n\n\tif (dhd_watchdog_prio >= 0) {\n\t\t/* Initialize watchdog thread */\n\t\tPROC_START(dhd_watchdog_thread, dhd, &dhd->thr_wdt_ctl, 0, \"dhd_watchdog_thread\");\n\n\t} else {\n\t\tdhd->thr_wdt_ctl.thr_pid = -1;\n\t}\n\n#ifdef DEBUGGER\n\tdebugger_init((void *) bus);\n#endif\n\n\t/* Set up the bottom half handler */\n\tif (dhd_dpc_prio >= 0) {\n\t\t/* Initialize DPC thread */\n\t\tPROC_START(dhd_dpc_thread, dhd, &dhd->thr_dpc_ctl, 0, \"dhd_dpc\");\n\t} else {\n\t\t/*  use tasklet for dpc */\n\t\ttasklet_init(&dhd->tasklet, dhd_dpc, (ulong)dhd);\n\t\tdhd->thr_dpc_ctl.thr_pid = -1;\n\t}\n\n\tif (dhd->rxthread_enabled) {\n\t\tbzero(&dhd->pub.skbbuf[0], sizeof(void *) * MAXSKBPEND);\n\t\t/* Initialize RXF thread */\n\t\tPROC_START(dhd_rxf_thread, dhd, &dhd->thr_rxf_ctl, 0, \"dhd_rxf\");\n\t}\n\n\tdhd_state |= DHD_ATTACH_STATE_THREADS_CREATED;\n\n#if defined(CONFIG_PM_SLEEP)\n\tif (!dhd_pm_notifier_registered) {\n\t\tdhd_pm_notifier_registered = TRUE;\n\t\tregister_pm_notifier(&dhd_pm_notifier);\n\t}\n#endif /* CONFIG_PM_SLEEP */\n\n#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)\n\tdhd->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 20;\n\tdhd->early_suspend.suspend = dhd_early_suspend;\n\tdhd->early_suspend.resume = dhd_late_resume;\n\tregister_early_suspend(&dhd->early_suspend);\n\tdhd_state |= DHD_ATTACH_STATE_EARLYSUSPEND_DONE;\n#endif /* CONFIG_HAS_EARLYSUSPEND && DHD_USE_EARLYSUSPEND */\n\n#ifdef ARP_OFFLOAD_SUPPORT\n\tdhd->pend_ipaddr = 0;\n\tif (!dhd_inetaddr_notifier_registered) {\n\t\tdhd_inetaddr_notifier_registered = TRUE;\n\t\tregister_inetaddr_notifier(&dhd_inetaddr_notifier);\n\t}\n#endif /* ARP_OFFLOAD_SUPPORT */\n#ifdef CONFIG_IPV6\n\tif (!dhd_inet6addr_notifier_registered) {\n\t\tdhd_inet6addr_notifier_registered = TRUE;\n\t\tregister_inet6addr_notifier(&dhd_inet6addr_notifier);\n\t}\n#endif\n\tdhd->dhd_deferred_wq = dhd_deferred_work_init((void *)dhd);\n#ifdef DEBUG_CPU_FREQ\n\tdhd->new_freq = alloc_percpu(int);\n\tdhd->freq_trans.notifier_call = dhd_cpufreq_notifier;\n\tcpufreq_register_notifier(&dhd->freq_trans, CPUFREQ_TRANSITION_NOTIFIER);\n#endif\n#ifdef DHDTCPACK_SUPPRESS\n#ifdef BCMSDIO\n\tdhd_tcpack_suppress_set(&dhd->pub, TCPACK_SUP_DELAYTX);\n#elif defined(BCMPCIE)\n\tdhd_tcpack_suppress_set(&dhd->pub, TCPACK_SUP_HOLD);\n#else\n\tdhd_tcpack_suppress_set(&dhd->pub, TCPACK_SUP_OFF);\n#endif /* BCMSDIO */\n#endif /* DHDTCPACK_SUPPRESS */\n\n\tdhd_state |= DHD_ATTACH_STATE_DONE;\n\tdhd->dhd_state = dhd_state;\n\n\tdhd_found++;\n#if defined(CUSTOMER_HW20) && defined(WLANAUDIO)\n\tdhd_global = dhd;\n#endif /* CUSTOMER_HW20 && WLANAUDIO */\n\treturn &dhd->pub;\n\nfail:\n\tif (dhd_state >= DHD_ATTACH_STATE_DHD_ALLOC) {\n\t\tDHD_TRACE((\"%s: Calling dhd_detach dhd_state 0x%x &dhd->pub %p\\n\",\n\t\t\t__FUNCTION__, dhd_state, &dhd->pub));\n\t\tdhd->dhd_state = dhd_state;\n\t\tdhd_detach(&dhd->pub);\n\t\tdhd_free(&dhd->pub);\n\t}\n\n\treturn NULL;\n}\n\nint dhd_get_fw_mode(dhd_info_t *dhdinfo)\n{\n\tif (strstr(dhdinfo->fw_path, \"_apsta\") != NULL)\n\t\treturn DHD_FLAG_HOSTAP_MODE;\n\tif (strstr(dhdinfo->fw_path, \"_p2p\") != NULL)\n\t\treturn DHD_FLAG_P2P_MODE;\n\tif (strstr(dhdinfo->fw_path, \"_ibss\") != NULL)\n\t\treturn DHD_FLAG_IBSS_MODE;\n\tif (strstr(dhdinfo->fw_path, \"_mfg\") != NULL)\n\t\treturn DHD_FLAG_MFG_MODE;\n\n\treturn DHD_FLAG_STA_MODE;\n}\n\nbool dhd_update_fw_nv_path(dhd_info_t *dhdinfo)\n{\n\tint fw_len;\n\tint nv_len;\n\tint conf_len;\n\tconst char *fw = NULL;\n\tconst char *nv = NULL;\n\tconst char *conf = NULL;\n\twifi_adapter_info_t *adapter = dhdinfo->adapter;\n\n\n\t/* Update firmware and nvram path. The path may be from adapter info or module parameter\n\t * The path from adapter info is used for initialization only (as it won't change).\n\t *\n\t * The firmware_path/nvram_path module parameter may be changed by the system at run\n\t * time. When it changes we need to copy it to dhdinfo->fw_path. Also Android private\n\t * command may change dhdinfo->fw_path. As such we need to clear the path info in\n\t * module parameter after it is copied. We won't update the path until the module parameter\n\t * is changed again (first character is not '\\0')\n\t */\n\n\t/* set default firmware and nvram path for built-in type driver */\n//\tif (!dhd_download_fw_on_driverload) {\n#ifdef CONFIG_BCMDHD_FW_PATH\n\t\tfw = CONFIG_BCMDHD_FW_PATH;\n#endif /* CONFIG_BCMDHD_FW_PATH */\n#ifdef CONFIG_BCMDHD_NVRAM_PATH\n\t\tnv = CONFIG_BCMDHD_NVRAM_PATH;\n#endif /* CONFIG_BCMDHD_NVRAM_PATH */\n//\t}\n\n\t/* check if we need to initialize the path */\n\tif (dhdinfo->fw_path[0] == '\\0') {\n\t\tif (adapter && adapter->fw_path && adapter->fw_path[0] != '\\0')\n\t\t\tfw = adapter->fw_path;\n\n\t}\n\tif (dhdinfo->nv_path[0] == '\\0') {\n\t\tif (adapter && adapter->nv_path && adapter->nv_path[0] != '\\0')\n\t\t\tnv = adapter->nv_path;\n\t}\n\tif (dhdinfo->conf_path[0] == '\\0') {\n\t\tif (adapter && adapter->conf_path && adapter->conf_path[0] != '\\0')\n\t\t\tconf = adapter->conf_path;\n\t}\n\n\t/* Use module parameter if it is valid, EVEN IF the path has not been initialized\n\t *\n\t * TODO: need a solution for multi-chip, can't use the same firmware for all chips\n\t */\n\tif (firmware_path[0] != '\\0')\n\t\tfw = firmware_path;\n\tif (nvram_path[0] != '\\0')\n\t\tnv = nvram_path;\n\tif (config_path[0] != '\\0')\n\t\tconf = config_path;\n\n\tif (fw && fw[0] != '\\0') {\n\t\tfw_len = strlen(fw);\n\t\tif (fw_len >= sizeof(dhdinfo->fw_path)) {\n\t\t\tDHD_ERROR((\"fw path len exceeds max len of dhdinfo->fw_path\\n\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\tstrncpy(dhdinfo->fw_path, fw, sizeof(dhdinfo->fw_path));\n\t\tif (dhdinfo->fw_path[fw_len-1] == '\\n')\n\t\t       dhdinfo->fw_path[fw_len-1] = '\\0';\n\t}\n\tif (nv && nv[0] != '\\0') {\n\t\tnv_len = strlen(nv);\n\t\tif (nv_len >= sizeof(dhdinfo->nv_path)) {\n\t\t\tDHD_ERROR((\"nvram path len exceeds max len of dhdinfo->nv_path\\n\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\tstrncpy(dhdinfo->nv_path, nv, sizeof(dhdinfo->nv_path));\n\t\tif (dhdinfo->nv_path[nv_len-1] == '\\n')\n\t\t       dhdinfo->nv_path[nv_len-1] = '\\0';\n\t}\n\tif (conf && conf[0] != '\\0') {\n\t\tconf_len = strlen(conf);\n\t\tif (conf_len >= sizeof(dhdinfo->conf_path)) {\n\t\t\tDHD_ERROR((\"config path len exceeds max len of dhdinfo->conf_path\\n\"));\n\t\t\treturn FALSE;\n\t\t}\n\t\tstrncpy(dhdinfo->conf_path, conf, sizeof(dhdinfo->conf_path));\n\t\tif (dhdinfo->conf_path[conf_len-1] == '\\n')\n\t\t       dhdinfo->conf_path[conf_len-1] = '\\0';\n\t}\n\n#if 0\n\t/* clear the path in module parameter */\n\tfirmware_path[0] = '\\0';\n\tnvram_path[0] = '\\0';\n\tconfig_path[0] = '\\0';\n#endif\n\n#ifndef BCMEMBEDIMAGE\n\t/* fw_path and nv_path are not mandatory for BCMEMBEDIMAGE */\n\tif (dhdinfo->fw_path[0] == '\\0') {\n\t\tDHD_ERROR((\"firmware path not found\\n\"));\n\t\treturn FALSE;\n\t}\n\tif (dhdinfo->nv_path[0] == '\\0') {\n\t\tDHD_ERROR((\"nvram path not found\\n\"));\n\t\treturn FALSE;\n\t}\n\tif (dhdinfo->conf_path[0] == '\\0') {\n\t\tdhd_conf_set_conf_path_by_nv_path(&dhdinfo->pub, dhdinfo->conf_path, dhdinfo->nv_path);\n\t}\n#ifdef CONFIG_PATH_AUTO_SELECT\n\tdhd_conf_set_conf_name_by_chip(&dhdinfo->pub, dhdinfo->conf_path);\n#endif\n#endif /* BCMEMBEDIMAGE */\n\n\treturn TRUE;\n}\n\n\nint\ndhd_bus_start(dhd_pub_t *dhdp)\n{\n\tint ret = -1;\n\tdhd_info_t *dhd = (dhd_info_t*)dhdp->info;\n\tunsigned long flags;\n\n\tASSERT(dhd);\n\n\tDHD_TRACE((\"Enter %s:\\n\", __FUNCTION__));\n\n\tDHD_PERIM_LOCK(dhdp);\n\n\t/* try to download image and nvram to the dongle */\n\tif  (dhd->pub.busstate == DHD_BUS_DOWN && dhd_update_fw_nv_path(dhd)) {\n\t\tDHD_INFO((\"%s download fw %s, nv %s, conf %s\\n\",\n\t\t\t__FUNCTION__, dhd->fw_path, dhd->nv_path, dhd->conf_path));\n\t\tret = dhd_bus_download_firmware(dhd->pub.bus, dhd->pub.osh,\n\t\t\tdhd->fw_path, dhd->nv_path, dhd->conf_path);\n\t\tif (ret < 0) {\n\t\t\tDHD_ERROR((\"%s: failed to download firmware %s\\n\",\n\t\t\t\t__FUNCTION__, dhd->fw_path));\n\t\t\tDHD_PERIM_UNLOCK(dhdp);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (dhd->pub.busstate != DHD_BUS_LOAD) {\n\t\tDHD_PERIM_UNLOCK(dhdp);\n\t\treturn -ENETDOWN;\n\t}\n\n\tdhd_os_sdlock(dhdp);\n\n\t/* Start the watchdog timer */\n\tdhd->pub.tickcnt = 0;\n\tdhd_os_wd_timer(&dhd->pub, dhd_watchdog_ms);\n\n\t/* Bring up the bus */\n\tif ((ret = dhd_bus_init(&dhd->pub, FALSE)) != 0) {\n\n\t\tDHD_ERROR((\"%s, dhd_bus_init failed %d\\n\", __FUNCTION__, ret));\n\t\tdhd_os_sdunlock(dhdp);\n\t\tDHD_PERIM_UNLOCK(dhdp);\n\t\treturn ret;\n\t}\n#if defined(OOB_INTR_ONLY) || defined(BCMPCIE_OOB_HOST_WAKE)\n#if defined(BCMPCIE_OOB_HOST_WAKE)\n\tdhd_os_sdunlock(dhdp);\n#endif /* BCMPCIE_OOB_HOST_WAKE */\n\t/* Host registration for OOB interrupt */\n\tif (dhd_bus_oob_intr_register(dhdp)) {\n\t\t/* deactivate timer and wait for the handler to finish */\n#if !defined(BCMPCIE_OOB_HOST_WAKE)\n\t\tDHD_GENERAL_LOCK(&dhd->pub, flags);\n\t\tdhd->wd_timer_valid = FALSE;\n\t\tDHD_GENERAL_UNLOCK(&dhd->pub, flags);\n\t\tdel_timer_sync(&dhd->timer);\n\n\t\tdhd_os_sdunlock(dhdp);\n#endif /* BCMPCIE_OOB_HOST_WAKE */\n\t\tDHD_PERIM_UNLOCK(dhdp);\n\t\tDHD_OS_WD_WAKE_UNLOCK(&dhd->pub);\n\t\tDHD_ERROR((\"%s Host failed to register for OOB\\n\", __FUNCTION__));\n\t\treturn -ENODEV;\n\t}\n\n#if defined(BCMPCIE_OOB_HOST_WAKE)\n\tdhd_os_sdlock(dhdp);\n\tdhd_bus_oob_intr_set(dhdp, TRUE);\n#else\n\t/* Enable oob at firmware */\n\tdhd_enable_oob_intr(dhd->pub.bus, TRUE);\n#endif /* BCMPCIE_OOB_HOST_WAKE */\n#elif defined(FORCE_WOWLAN)\n\t/* Enable oob at firmware */\n\tdhd_enable_oob_intr(dhd->pub.bus, TRUE);\n#endif \n#ifdef PCIE_FULL_DONGLE\n\t{\n\t\tuint8 txpush = 0;\n\t\tuint32 num_flowrings; /* includes H2D common rings */\n\t\tnum_flowrings = dhd_bus_max_h2d_queues(dhd->pub.bus, &txpush);\n\t\tDHD_ERROR((\"%s: Initializing %u flowrings\\n\", __FUNCTION__,\n\t\t\tnum_flowrings));\n\t\tif ((ret = dhd_flow_rings_init(&dhd->pub, num_flowrings)) != BCME_OK) {\n\t\t\tdhd_os_sdunlock(dhdp);\n\t\t\tDHD_PERIM_UNLOCK(dhdp);\n\t\t\treturn ret;\n\t\t}\n\t}\n#endif /* PCIE_FULL_DONGLE */\n\n\t/* Do protocol initialization necessary for IOCTL/IOVAR */\n\tdhd_prot_init(&dhd->pub);\n\n\t/* If bus is not ready, can't come up */\n\tif (dhd->pub.busstate != DHD_BUS_DATA) {\n\t\tDHD_GENERAL_LOCK(&dhd->pub, flags);\n\t\tdhd->wd_timer_valid = FALSE;\n\t\tDHD_GENERAL_UNLOCK(&dhd->pub, flags);\n\t\tdel_timer_sync(&dhd->timer);\n\t\tDHD_ERROR((\"%s failed bus is not ready\\n\", __FUNCTION__));\n\t\tdhd_os_sdunlock(dhdp);\n\t\tDHD_PERIM_UNLOCK(dhdp);\n\t\tDHD_OS_WD_WAKE_UNLOCK(&dhd->pub);\n\t\treturn -ENODEV;\n\t}\n\n\tdhd_os_sdunlock(dhdp);\n\n\t/* Bus is ready, query any dongle information */\n\tif ((ret = dhd_sync_with_dongle(&dhd->pub)) < 0) {\n\t\tDHD_PERIM_UNLOCK(dhdp);\n\t\treturn ret;\n\t}\n\n#ifdef ARP_OFFLOAD_SUPPORT\n\tif (dhd->pend_ipaddr) {\n#ifdef AOE_IP_ALIAS_SUPPORT\n\t\taoe_update_host_ipv4_table(&dhd->pub, dhd->pend_ipaddr, TRUE, 0);\n#endif /* AOE_IP_ALIAS_SUPPORT */\n\t\tdhd->pend_ipaddr = 0;\n\t}\n#endif /* ARP_OFFLOAD_SUPPORT */\n\n\tDHD_PERIM_UNLOCK(dhdp);\n\treturn 0;\n}\n\n#ifdef WLTDLS\nint _dhd_tdls_enable(dhd_pub_t *dhd, bool tdls_on, bool auto_on, struct ether_addr *mac)\n{\n\tchar iovbuf[WLC_IOCTL_SMLEN];\n\tuint32 tdls = tdls_on;\n\tint ret = 0;\n\tuint32 tdls_auto_op = 0;\n\tuint32 tdls_idle_time = CUSTOM_TDLS_IDLE_MODE_SETTING;\n\tint32 tdls_rssi_high = CUSTOM_TDLS_RSSI_THRESHOLD_HIGH;\n\tint32 tdls_rssi_low = CUSTOM_TDLS_RSSI_THRESHOLD_LOW;\n\tBCM_REFERENCE(mac);\n\tif (!FW_SUPPORTED(dhd, tdls))\n\t\treturn BCME_ERROR;\n\n\tif (dhd->tdls_enable == tdls_on)\n\t\tgoto auto_mode;\n\tbcm_mkiovar(\"tdls_enable\", (char *)&tdls, sizeof(tdls), iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s: tdls %d failed %d\\n\", __FUNCTION__, tdls, ret));\n\t\tgoto exit;\n\t}\n\tdhd->tdls_enable = tdls_on;\nauto_mode:\n\n\ttdls_auto_op = auto_on;\n\tbcm_mkiovar(\"tdls_auto_op\", (char *)&tdls_auto_op, sizeof(tdls_auto_op),\n\t\tiovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s: tdls_auto_op failed %d\\n\", __FUNCTION__, ret));\n\t\tgoto exit;\n\t}\n\n\tif (tdls_auto_op) {\n\t\tbcm_mkiovar(\"tdls_idle_time\", (char *)&tdls_idle_time,\n\t\t\tsizeof(tdls_idle_time),\tiovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s: tdls_idle_time failed %d\\n\", __FUNCTION__, ret));\n\t\t\tgoto exit;\n\t\t}\n\t\tbcm_mkiovar(\"tdls_rssi_high\", (char *)&tdls_rssi_high, 4, iovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s: tdls_rssi_high failed %d\\n\", __FUNCTION__, ret));\n\t\t\tgoto exit;\n\t\t}\n\t\tbcm_mkiovar(\"tdls_rssi_low\", (char *)&tdls_rssi_low, 4, iovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s: tdls_rssi_low failed %d\\n\", __FUNCTION__, ret));\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\treturn ret;\n}\n\nint dhd_tdls_enable(struct net_device *dev, bool tdls_on, bool auto_on, struct ether_addr *mac)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tint ret = 0;\n\tif (dhd)\n\t\tret = _dhd_tdls_enable(&dhd->pub, tdls_on, auto_on, mac);\n\telse\n\t\tret = BCME_ERROR;\n\treturn ret;\n}\n#ifdef PCIE_FULL_DONGLE\nvoid dhd_tdls_update_peer_info(struct net_device *dev, bool connect, uint8 *da)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tdhd_pub_t *dhdp =  (dhd_pub_t *)&dhd->pub;\n\ttdls_peer_node_t *cur = dhdp->peer_tbl.node;\n\ttdls_peer_node_t *new = NULL, *prev = NULL;\n\tdhd_if_t *dhdif;\n\tuint8 sa[ETHER_ADDR_LEN];\n\tint ifidx = dhd_net2idx(dhd, dev);\n\n\tif (ifidx == DHD_BAD_IF)\n\t\treturn;\n\n\tdhdif = dhd->iflist[ifidx];\n\tmemcpy(sa, dhdif->mac_addr, ETHER_ADDR_LEN);\n\n\tif (connect) {\n\t\twhile (cur != NULL) {\n\t\t\tif (!memcmp(da, cur->addr, ETHER_ADDR_LEN)) {\n\t\t\t\tDHD_ERROR((\"%s: TDLS Peer exist already %d\\n\",\n\t\t\t\t\t__FUNCTION__, __LINE__));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcur = cur->next;\n\t\t}\n\n\t\tnew = MALLOC(dhdp->osh, sizeof(tdls_peer_node_t));\n\t\tif (new == NULL) {\n\t\t\tDHD_ERROR((\"%s: Failed to allocate memory\\n\", __FUNCTION__));\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(new->addr, da, ETHER_ADDR_LEN);\n\t\tnew->next = dhdp->peer_tbl.node;\n\t\tdhdp->peer_tbl.node = new;\n\t\tdhdp->peer_tbl.tdls_peer_count++;\n\n\t} else {\n\t\twhile (cur != NULL) {\n\t\t\tif (!memcmp(da, cur->addr, ETHER_ADDR_LEN)) {\n\t\t\t\tdhd_flow_rings_delete_for_peer(dhdp, ifidx, da);\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = cur->next;\n\t\t\t\telse\n\t\t\t\t\tdhdp->peer_tbl.node = cur->next;\n\t\t\t\tMFREE(dhdp->osh, cur, sizeof(tdls_peer_node_t));\n\t\t\t\tdhdp->peer_tbl.tdls_peer_count--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprev = cur;\n\t\t\tcur = cur->next;\n\t\t}\n\t\tDHD_ERROR((\"%s: TDLS Peer Entry Not found\\n\", __FUNCTION__));\n\t}\n}\n#endif /* PCIE_FULL_DONGLE */\n#endif \n\nbool dhd_is_concurrent_mode(dhd_pub_t *dhd)\n{\n\tif (!dhd)\n\t\treturn FALSE;\n\n\tif (dhd->op_mode & DHD_FLAG_CONCURR_MULTI_CHAN_MODE)\n\t\treturn TRUE;\n\telse if ((dhd->op_mode & DHD_FLAG_CONCURR_SINGLE_CHAN_MODE) ==\n\t\tDHD_FLAG_CONCURR_SINGLE_CHAN_MODE)\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}\n#if !defined(AP) && defined(WLP2P)\n/* From Android JerryBean release, the concurrent mode is enabled by default and the firmware\n * name would be fw_bcmdhd.bin. So we need to determine whether P2P is enabled in the STA\n * firmware and accordingly enable concurrent mode (Apply P2P settings). SoftAP firmware\n * would still be named as fw_bcmdhd_apsta.\n */\nuint32\ndhd_get_concurrent_capabilites(dhd_pub_t *dhd)\n{\n\tint32 ret = 0;\n\tchar buf[WLC_IOCTL_SMLEN];\n\tbool mchan_supported = FALSE;\n\t/* if dhd->op_mode is already set for HOSTAP and Manufacturing\n\t * test mode, that means we only will use the mode as it is\n\t */\n\tif (dhd->op_mode & (DHD_FLAG_HOSTAP_MODE | DHD_FLAG_MFG_MODE))\n\t\treturn 0;\n\tif (FW_SUPPORTED(dhd, vsdb)) {\n\t\tmchan_supported = TRUE;\n\t}\n\tif (!FW_SUPPORTED(dhd, p2p)) {\n\t\tDHD_TRACE((\"Chip does not support p2p\\n\"));\n\t\treturn 0;\n\t}\n\telse {\n\t\t/* Chip supports p2p but ensure that p2p is really implemented in firmware or not */\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tbcm_mkiovar(\"p2p\", 0, 0, buf, sizeof(buf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, buf, sizeof(buf),\n\t\t\tFALSE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s: Get P2P failed (error=%d)\\n\", __FUNCTION__, ret));\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tif (buf[0] == 1) {\n\t\t\t\t/* By default, chip supports single chan concurrency,\n\t\t\t\t* now lets check for mchan\n\t\t\t\t*/\n\t\t\t\tret = DHD_FLAG_CONCURR_SINGLE_CHAN_MODE;\n\t\t\t\tif (mchan_supported)\n\t\t\t\t\tret |= DHD_FLAG_CONCURR_MULTI_CHAN_MODE;\n#if defined(WL_ENABLE_P2P_IF) || defined(WL_CFG80211_P2P_DEV_IF)\n\t\t\t\t/* For customer_hw4, although ICS,\n\t\t\t\t* we still support concurrent mode\n\t\t\t\t*/\n\t\t\t\treturn ret;\n#else\n\t\t\t\treturn 0;\n#endif\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n\n#ifdef SUPPORT_AP_POWERSAVE\n#define RXCHAIN_PWRSAVE_PPS\t\t\t10\n#define RXCHAIN_PWRSAVE_QUIET_TIME\t\t10\n#define RXCHAIN_PWRSAVE_STAS_ASSOC_CHECK\t0\nint dhd_set_ap_powersave(dhd_pub_t *dhdp, int ifidx, int enable)\n{\n\tchar iovbuf[128];\n\tint32 pps = RXCHAIN_PWRSAVE_PPS;\n\tint32 quiet_time = RXCHAIN_PWRSAVE_QUIET_TIME;\n\tint32 stas_assoc_check = RXCHAIN_PWRSAVE_STAS_ASSOC_CHECK;\n\n\tif (enable) {\n\t\tbcm_mkiovar(\"rxchain_pwrsave_enable\", (char *)&enable, 4, iovbuf, sizeof(iovbuf));\n\t\tif (dhd_wl_ioctl_cmd(dhdp, WLC_SET_VAR,\n\t\t    iovbuf, sizeof(iovbuf), TRUE, 0) != BCME_OK) {\n\t\t\tDHD_ERROR((\"Failed to enable AP power save\\n\"));\n\t\t}\n\t\tbcm_mkiovar(\"rxchain_pwrsave_pps\", (char *)&pps, 4, iovbuf, sizeof(iovbuf));\n\t\tif (dhd_wl_ioctl_cmd(dhdp, WLC_SET_VAR,\n\t\t    iovbuf, sizeof(iovbuf), TRUE, 0) != BCME_OK) {\n\t\t\tDHD_ERROR((\"Failed to set pps\\n\"));\n\t\t}\n\t\tbcm_mkiovar(\"rxchain_pwrsave_quiet_time\", (char *)&quiet_time,\n\t\t4, iovbuf, sizeof(iovbuf));\n\t\tif (dhd_wl_ioctl_cmd(dhdp, WLC_SET_VAR,\n\t\t    iovbuf, sizeof(iovbuf), TRUE, 0) != BCME_OK) {\n\t\t\tDHD_ERROR((\"Failed to set quiet time\\n\"));\n\t\t}\n\t\tbcm_mkiovar(\"rxchain_pwrsave_stas_assoc_check\", (char *)&stas_assoc_check,\n\t\t4, iovbuf, sizeof(iovbuf));\n\t\tif (dhd_wl_ioctl_cmd(dhdp, WLC_SET_VAR,\n\t\t    iovbuf, sizeof(iovbuf), TRUE, 0) != BCME_OK) {\n\t\t\tDHD_ERROR((\"Failed to set stas assoc check\\n\"));\n\t\t}\n\t} else {\n\t\tbcm_mkiovar(\"rxchain_pwrsave_enable\", (char *)&enable, 4, iovbuf, sizeof(iovbuf));\n\t\tif (dhd_wl_ioctl_cmd(dhdp, WLC_SET_VAR,\n\t\t    iovbuf, sizeof(iovbuf), TRUE, 0) != BCME_OK) {\n\t\t\tDHD_ERROR((\"Failed to disable AP power save\\n\"));\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif /* SUPPORT_AP_POWERSAVE */\n\n\n#if defined(READ_CONFIG_FROM_FILE)\n#include <linux/fs.h>\n#include <linux/ctype.h>\n\n#define strtoul(nptr, endptr, base) bcm_strtoul((nptr), (endptr), (base))\nbool PM_control = TRUE;\n\nstatic int dhd_preinit_proc(dhd_pub_t *dhd, int ifidx, char *name, char *value)\n{\n\tint var_int;\n\twl_country_t cspec = {{0}, -1, {0}};\n\tchar *revstr;\n\tchar *endptr = NULL;\n\tint iolen;\n\tchar smbuf[WLC_IOCTL_SMLEN*2];\n\n\tif (!strcmp(name, \"country\")) {\n\t\trevstr = strchr(value, '/');\n\t\tif (revstr) {\n\t\t\tcspec.rev = strtoul(revstr + 1, &endptr, 10);\n\t\t\tmemcpy(cspec.country_abbrev, value, WLC_CNTRY_BUF_SZ);\n\t\t\tcspec.country_abbrev[2] = '\\0';\n\t\t\tmemcpy(cspec.ccode, cspec.country_abbrev, WLC_CNTRY_BUF_SZ);\n\t\t} else {\n\t\t\tcspec.rev = -1;\n\t\t\tmemcpy(cspec.country_abbrev, value, WLC_CNTRY_BUF_SZ);\n\t\t\tmemcpy(cspec.ccode, value, WLC_CNTRY_BUF_SZ);\n\t\t\tget_customized_country_code(dhd->info->adapter,\n\t\t\t\t(char *)&cspec.country_abbrev, &cspec);\n\t\t}\n\t\tmemset(smbuf, 0, sizeof(smbuf));\n\t\tDHD_ERROR((\"config country code is country : %s, rev : %d !!\\n\",\n\t\t\tcspec.country_abbrev, cspec.rev));\n\t\tiolen = bcm_mkiovar(\"country\", (char*)&cspec, sizeof(cspec),\n\t\t\tsmbuf, sizeof(smbuf));\n\t\treturn dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR,\n\t\t\tsmbuf, iolen, TRUE, 0);\n\t} else if (!strcmp(name, \"roam_scan_period\")) {\n\t\tvar_int = (int)simple_strtol(value, NULL, 0);\n\t\treturn dhd_wl_ioctl_cmd(dhd, WLC_SET_ROAM_SCAN_PERIOD,\n\t\t\t&var_int, sizeof(var_int), TRUE, 0);\n\t} else if (!strcmp(name, \"roam_delta\")) {\n\t\tstruct {\n\t\t\tint val;\n\t\t\tint band;\n\t\t} x;\n\t\tx.val = (int)simple_strtol(value, NULL, 0);\n\t\t/* x.band = WLC_BAND_AUTO; */\n\t\tx.band = WLC_BAND_ALL;\n\t\treturn dhd_wl_ioctl_cmd(dhd, WLC_SET_ROAM_DELTA, &x, sizeof(x), TRUE, 0);\n\t} else if (!strcmp(name, \"roam_trigger\")) {\n\t\tint ret = 0;\n\n\t\troam_trigger[0] = (int)simple_strtol(value, NULL, 0);\n\t\troam_trigger[1] = WLC_BAND_ALL;\n\t\tret = dhd_wl_ioctl_cmd(dhd, WLC_SET_ROAM_TRIGGER, &roam_trigger,\n\t\t\tsizeof(roam_trigger), TRUE, 0);\n\n\t\treturn ret;\n\t} else if (!strcmp(name, \"PM\")) {\n\t\tint ret = 0;\n\t\tvar_int = (int)simple_strtol(value, NULL, 0);\n\n\t\tret =  dhd_wl_ioctl_cmd(dhd, WLC_SET_PM,\n\t\t\t&var_int, sizeof(var_int), TRUE, 0);\n\n#if defined(CONFIG_PM_LOCK)\n\t\tif (var_int == 0) {\n\t\t\tg_pm_control = TRUE;\n\t\t\tprintk(\"%s var_int=%d don't control PM\\n\", __func__, var_int);\n\t\t} else {\n\t\t\tg_pm_control = FALSE;\n\t\t\tprintk(\"%s var_int=%d do control PM\\n\", __func__, var_int);\n\t\t}\n#endif\n\n\t\treturn ret;\n\t}\n#ifdef WLBTAMP\n\telse if (!strcmp(name, \"btamp_chan\")) {\n\t\tint btamp_chan;\n\t\tint iov_len = 0;\n\t\tchar iovbuf[128];\n\t\tint ret;\n\n\t\tbtamp_chan = (int)simple_strtol(value, NULL, 0);\n\t\tiov_len = bcm_mkiovar(\"btamp_chan\", (char *)&btamp_chan, 4, iovbuf, sizeof(iovbuf));\n\t\tif ((ret  = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, iov_len, TRUE, 0) < 0))\n\t\t\tDHD_ERROR((\"%s btamp_chan=%d set failed code %d\\n\",\n\t\t\t\t__FUNCTION__, btamp_chan, ret));\n\t\telse\n\t\t\tDHD_ERROR((\"%s btamp_chan %d set success\\n\",\n\t\t\t\t__FUNCTION__, btamp_chan));\n\t}\n#endif /* WLBTAMP */\n\telse if (!strcmp(name, \"band\")) {\n\t\tint ret;\n\t\tif (!strcmp(value, \"auto\"))\n\t\t\tvar_int = WLC_BAND_AUTO;\n\t\telse if (!strcmp(value, \"a\"))\n\t\t\tvar_int = WLC_BAND_5G;\n\t\telse if (!strcmp(value, \"b\"))\n\t\t\tvar_int = WLC_BAND_2G;\n\t\telse if (!strcmp(value, \"all\"))\n\t\t\tvar_int = WLC_BAND_ALL;\n\t\telse {\n\t\t\tprintk(\" set band value should be one of the a or b or all\\n\");\n\t\t\tvar_int = WLC_BAND_AUTO;\n\t\t}\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_BAND, &var_int,\n\t\t\tsizeof(var_int), TRUE, 0)) < 0)\n\t\t\tprintk(\" set band err=%d\\n\", ret);\n\t\treturn ret;\n\t} else if (!strcmp(name, \"cur_etheraddr\")) {\n\t\tstruct ether_addr ea;\n\t\tchar buf[32];\n\t\tuint iovlen;\n\t\tint ret;\n\n\t\tbcm_ether_atoe(value, &ea);\n\n\t\tret = memcmp(&ea.octet, dhd->mac.octet, ETHER_ADDR_LEN);\n\t\tif (ret == 0) {\n\t\t\tDHD_ERROR((\"%s: Same Macaddr\\n\", __FUNCTION__));\n\t\t\treturn 0;\n\t\t}\n\n\t\tDHD_ERROR((\"%s: Change Macaddr = %02X:%02X:%02X:%02X:%02X:%02X\\n\", __FUNCTION__,\n\t\t\tea.octet[0], ea.octet[1], ea.octet[2],\n\t\t\tea.octet[3], ea.octet[4], ea.octet[5]));\n\n\t\tiovlen = bcm_mkiovar(\"cur_etheraddr\", (char*)&ea, ETHER_ADDR_LEN, buf, 32);\n\n\t\tret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, buf, iovlen, TRUE, 0);\n\t\tif (ret < 0) {\n\t\t\tDHD_ERROR((\"%s: can't set MAC address , error=%d\\n\", __FUNCTION__, ret));\n\t\t\treturn ret;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(dhd->mac.octet, (void *)&ea, ETHER_ADDR_LEN);\n\t\t\treturn ret;\n\t\t}\n\t} else if (!strcmp(name, \"lpc\")) {\n\t\tint ret = 0;\n\t\tchar buf[32];\n\t\tuint iovlen;\n\t\tvar_int = (int)simple_strtol(value, NULL, 0);\n\t\tif (dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, 0) < 0) {\n\t\t\tDHD_ERROR((\"%s: wl down failed\\n\", __FUNCTION__));\n\t\t}\n\t\tiovlen = bcm_mkiovar(\"lpc\", (char *)&var_int, 4, buf, sizeof(buf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, buf, iovlen, TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s Set lpc failed  %d\\n\", __FUNCTION__, ret));\n\t\t}\n\t\tif (dhd_wl_ioctl_cmd(dhd, WLC_UP, NULL, 0, TRUE, 0) < 0) {\n\t\t\tDHD_ERROR((\"%s: wl up failed\\n\", __FUNCTION__));\n\t\t}\n\t\treturn ret;\n\t} else if (!strcmp(name, \"vht_features\")) {\n\t\tint ret = 0;\n\t\tchar buf[32];\n\t\tuint iovlen;\n\t\tvar_int = (int)simple_strtol(value, NULL, 0);\n\n\t\tif (dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, 0) < 0) {\n\t\t\tDHD_ERROR((\"%s: wl down failed\\n\", __FUNCTION__));\n\t\t}\n\t\tiovlen = bcm_mkiovar(\"vht_features\", (char *)&var_int, 4, buf, sizeof(buf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, buf, iovlen, TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s Set vht_features failed  %d\\n\", __FUNCTION__, ret));\n\t\t}\n\t\tif (dhd_wl_ioctl_cmd(dhd, WLC_UP, NULL, 0, TRUE, 0) < 0) {\n\t\t\tDHD_ERROR((\"%s: wl up failed\\n\", __FUNCTION__));\n\t\t}\n\t\treturn ret;\n\t} else {\n\t\tuint iovlen;\n\t\tchar iovbuf[WLC_IOCTL_SMLEN];\n\n\t\t/* wlu_iovar_setint */\n\t\tvar_int = (int)simple_strtol(value, NULL, 0);\n\n\t\t/* Setup timeout bcn_timeout from dhd driver 4.217.48 */\n\t\tif (!strcmp(name, \"roam_off\")) {\n\t\t\t/* Setup timeout if Beacons are lost to report link down */\n\t\t\tif (var_int) {\n\t\t\t\tuint bcn_timeout = 2;\n\t\t\t\tbcm_mkiovar(\"bcn_timeout\", (char *)&bcn_timeout, 4,\n\t\t\t\t\tiovbuf, sizeof(iovbuf));\n\t\t\t\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\t\t\t}\n\t\t}\n\t\t/* Setup timeout bcm_timeout from dhd driver 4.217.48 */\n\n\t\tDHD_INFO((\"%s:[%s]=[%d]\\n\", __FUNCTION__, name, var_int));\n\n\t\tiovlen = bcm_mkiovar(name, (char *)&var_int, sizeof(var_int),\n\t\t\tiovbuf, sizeof(iovbuf));\n\t\treturn dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR,\n\t\t\tiovbuf, iovlen, TRUE, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int dhd_preinit_config(dhd_pub_t *dhd, int ifidx)\n{\n\tmm_segment_t old_fs;\n\tstruct kstat stat;\n\tstruct file *fp = NULL;\n\tunsigned int len;\n\tchar *buf = NULL, *p, *name, *value;\n\tint ret = 0;\n\tchar *config_path;\n\n\tconfig_path = CONFIG_BCMDHD_CONFIG_PATH;\n\n\tif (!config_path)\n\t{\n\t\tprintk(KERN_ERR \"config_path can't read. \\n\");\n\t\treturn 0;\n\t}\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tif ((ret = vfs_stat(config_path, &stat))) {\n\t\tset_fs(old_fs);\n\t\tprintk(KERN_ERR \"%s: Failed to get information (%d)\\n\",\n\t\t\tconfig_path, ret);\n\t\treturn ret;\n\t}\n\tset_fs(old_fs);\n\n\tif (!(buf = MALLOC(dhd->osh, stat.size + 1))) {\n\t\tprintk(KERN_ERR \"Failed to allocate memory %llu bytes\\n\", stat.size);\n\t\treturn -ENOMEM;\n\t}\n\n\tprintk(\"dhd_preinit_config : config path : %s \\n\", config_path);\n\n\tif (!(fp = dhd_os_open_image(config_path)) ||\n\t\t(len = dhd_os_get_image_block(buf, stat.size, fp)) < 0)\n\t\tgoto err;\n\n\tbuf[stat.size] = '\\0';\n\tfor (p = buf; *p; p++) {\n\t\tif (isspace(*p))\n\t\t\tcontinue;\n\t\tfor (name = p++; *p && !isspace(*p); p++) {\n\t\t\tif (*p == '=') {\n\t\t\t\t*p = '\\0';\n\t\t\t\tp++;\n\t\t\t\tfor (value = p; *p && !isspace(*p); p++);\n\t\t\t\t*p = '\\0';\n\t\t\t\tif ((ret = dhd_preinit_proc(dhd, ifidx, name, value)) < 0) {\n\t\t\t\t\tprintk(KERN_ERR \"%s: %s=%s\\n\",\n\t\t\t\t\t\tbcmerrorstr(ret), name, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\n\nout:\n\tif (fp)\n\t\tdhd_os_close_image(fp);\n\tif (buf)\n\t\tMFREE(dhd->osh, buf, stat.size+1);\n\treturn ret;\n\nerr:\n\tret = -1;\n\tgoto out;\n}\n#endif /* READ_CONFIG_FROM_FILE */\n\nint\ndhd_preinit_ioctls(dhd_pub_t *dhd)\n{\n\tint ret = 0;\n\tchar eventmask[WL_EVENTING_MASK_LEN];\n\tchar iovbuf[WL_EVENTING_MASK_LEN + 12];\t/*  Room for \"event_msgs\" + '\\0' + bitvec  */\n\tuint32 buf_key_b4_m4 = 1;\n#ifndef WL_CFG80211\n\tu32 up = 0;\n#endif\n\tuint8 msglen;\n\teventmsgs_ext_t *eventmask_msg = NULL;\n\tchar* iov_buf = NULL;\n\tint ret2 = 0;\n#ifdef WLAIBSS\n\taibss_bcn_force_config_t bcn_config;\n\tuint32 aibss;\n#ifdef WLAIBSS_PS\n\tuint32 aibss_ps;\n#endif /* WLAIBSS_PS */\n#endif /* WLAIBSS */\n#if defined(BCMSUP_4WAY_HANDSHAKE) && defined(WLAN_AKM_SUITE_FT_8021X)\n\tuint32 sup_wpa = 0;\n#endif\n#if defined(CUSTOM_AMPDU_BA_WSIZE) || (defined(WLAIBSS) && \\\n\tdefined(CUSTOM_IBSS_AMPDU_BA_WSIZE))\n\tuint32 ampdu_ba_wsize = 0;\n#endif /* CUSTOM_AMPDU_BA_WSIZE ||(WLAIBSS && CUSTOM_IBSS_AMPDU_BA_WSIZE) */\n#if defined(CUSTOM_AMPDU_MPDU)\n\tint32 ampdu_mpdu = 0;\n#endif\n#if defined(CUSTOM_AMPDU_RELEASE)\n\tint32 ampdu_release = 0;\n#endif\n#if defined(CUSTOM_AMSDU_AGGSF)\n\tint32 amsdu_aggsf = 0;\n#endif\n\n#if defined(BCMSDIO)\n#ifdef PROP_TXSTATUS\n\tint wlfc_enable = TRUE;\n#ifndef DISABLE_11N\n\tuint32 hostreorder = 1;\n\tuint wl_down = 1;\n#endif /* DISABLE_11N */\n#endif /* PROP_TXSTATUS */\n#endif \n#ifdef PCIE_FULL_DONGLE\n\tuint32 wl_ap_isolate;\n#endif /* PCIE_FULL_DONGLE */\n\n#ifdef DHD_ENABLE_LPC\n\tuint32 lpc = 1;\n#endif /* DHD_ENABLE_LPC */\n\tuint power_mode = PM_FAST;\n\tuint32 dongle_align = DHD_SDALIGN;\n#if defined(BCMSDIO)\n\tuint32 glom = CUSTOM_GLOM_SETTING;\n#endif /* defined(BCMSDIO) */\n#if defined(CUSTOMER_HW2) && defined(USE_WL_CREDALL)\n\tuint32 credall = 1;\n#endif\n\tuint bcn_timeout = dhd->conf->bcn_timeout;\n\tuint retry_max = 3;\n#if defined(ARP_OFFLOAD_SUPPORT)\n\tint arpoe = 1;\n#endif\n\tint scan_assoc_time = DHD_SCAN_ASSOC_ACTIVE_TIME;\n\tint scan_unassoc_time = DHD_SCAN_UNASSOC_ACTIVE_TIME;\n\tint scan_passive_time = DHD_SCAN_PASSIVE_TIME;\n\tchar buf[WLC_IOCTL_SMLEN];\n\tchar *ptr;\n\tuint32 listen_interval = CUSTOM_LISTEN_INTERVAL; /* Default Listen Interval in Beacons */\n#ifdef ROAM_ENABLE\n\tuint roamvar = 0;\n\tint roam_trigger[2] = {CUSTOM_ROAM_TRIGGER_SETTING, WLC_BAND_ALL};\n\tint roam_scan_period[2] = {10, WLC_BAND_ALL};\n\tint roam_delta[2] = {CUSTOM_ROAM_DELTA_SETTING, WLC_BAND_ALL};\n#ifdef FULL_ROAMING_SCAN_PERIOD_60_SEC\n\tint roam_fullscan_period = 60;\n#else /* FULL_ROAMING_SCAN_PERIOD_60_SEC */\n\tint roam_fullscan_period = 120;\n#endif /* FULL_ROAMING_SCAN_PERIOD_60_SEC */\n#else\n#ifdef DISABLE_BUILTIN_ROAM\n\tuint roamvar = 1;\n#endif /* DISABLE_BUILTIN_ROAM */\n#endif /* ROAM_ENABLE */\n\n#if defined(SOFTAP)\n\tuint dtim = 1;\n#endif\n#if (defined(AP) && !defined(WLP2P)) || (!defined(AP) && defined(WL_CFG80211))\n\tuint32 mpc = 0; /* Turn MPC off for AP/APSTA mode */\n\tstruct ether_addr p2p_ea;\n#endif\n#ifdef BCMCCX\n\tuint32 ccx = 1;\n#endif\n#ifdef SOFTAP_UAPSD_OFF\n\tuint32 wme_apsd = 0;\n#endif /* SOFTAP_UAPSD_OFF */\n#if (defined(AP) || defined(WLP2P)) && !defined(SOFTAP_AND_GC)\n\tuint32 apsta = 1; /* Enable APSTA mode */\n#elif defined(SOFTAP_AND_GC)\n\tuint32 apsta = 0;\n\tint ap_mode = 1;\n#endif /* (defined(AP) || defined(WLP2P)) && !defined(SOFTAP_AND_GC) */\n#ifdef GET_CUSTOM_MAC_ENABLE\n\tstruct ether_addr ea_addr;\n#endif /* GET_CUSTOM_MAC_ENABLE */\n\n#ifdef DISABLE_11N\n\tuint32 nmode = 0;\n#endif /* DISABLE_11N */\n\n#if defined(DISABLE_11AC)\n\tuint32 vhtmode = 0;\n#endif /* DISABLE_11AC */\n#ifdef USE_WL_TXBF\n\tuint32 txbf = 1;\n#endif /* USE_WL_TXBF */\n#ifdef AMPDU_VO_ENABLE\n\tstruct ampdu_tid_control tid;\n#endif\n#ifdef USE_WL_FRAMEBURST\n\tuint32 frameburst = 1;\n#endif /* USE_WL_FRAMEBURST */\n#ifdef DHD_SET_FW_HIGHSPEED\n\tuint32 ack_ratio = 250;\n\tuint32 ack_ratio_depth = 64;\n#endif /* DHD_SET_FW_HIGHSPEED */\n#ifdef SUPPORT_2G_VHT\n\tuint32 vht_features = 0x3; /* 2G enable | rates all */\n#endif /* SUPPORT_2G_VHT */\n#ifdef CUSTOM_PSPRETEND_THR\n\tuint32 pspretend_thr = CUSTOM_PSPRETEND_THR;\n#endif\n#ifdef PKT_FILTER_SUPPORT\n\tdhd_pkt_filter_enable = TRUE;\n#endif /* PKT_FILTER_SUPPORT */\n#ifdef WLTDLS\n\tdhd->tdls_enable = FALSE;\n#endif /* WLTDLS */\n\tdhd->suspend_bcn_li_dtim = CUSTOM_SUSPEND_BCN_LI_DTIM;\n\tDHD_TRACE((\"Enter %s\\n\", __FUNCTION__));\n\n\tdhd_conf_set_fw_int_cmd(dhd, \"WLC_SET_BAND\", WLC_SET_BAND, dhd->conf->band, 0, FALSE);\n#ifdef DHDTCPACK_SUPPRESS\n\tprintf(\"%s: Set tcpack_sup_mode %d\\n\", __FUNCTION__, dhd->conf->tcpack_sup_mode);\n\tdhd_tcpack_suppress_set(dhd, dhd->conf->tcpack_sup_mode);\n#endif\n\n\tdhd->op_mode = 0;\n\tif ((!op_mode && dhd_get_fw_mode(dhd->info) == DHD_FLAG_MFG_MODE) ||\n\t\t(op_mode == DHD_FLAG_MFG_MODE)) {\n\t\t/* Check and adjust IOCTL response timeout for Manufactring firmware */\n\t\tdhd_os_set_ioctl_resp_timeout(MFG_IOCTL_RESP_TIMEOUT);\n\t\tDHD_ERROR((\"%s : Set IOCTL response time for Manufactring Firmware\\n\",\n\t\t\t__FUNCTION__));\n\t}\n\telse {\n\t\tdhd_os_set_ioctl_resp_timeout(IOCTL_RESP_TIMEOUT);\n\t\tDHD_INFO((\"%s : Set IOCTL response time.\\n\", __FUNCTION__));\n\t}\n#ifdef GET_CUSTOM_MAC_ENABLE\n\tret = wifi_platform_get_mac_addr(dhd->info->adapter, ea_addr.octet);\n\tif (!ret) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tbcm_mkiovar(\"cur_etheraddr\", (void *)&ea_addr, ETHER_ADDR_LEN, buf, sizeof(buf));\n\t\tret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, buf, sizeof(buf), TRUE, 0);\n\t\tif (ret < 0) {\n\t\t\tDHD_ERROR((\"%s: can't set MAC address MAC=\"MACDBG\", error=%d\\n\",\n\t\t\t\t__FUNCTION__, MAC2STRDBG(ea_addr.octet), ret));\n\t\t\tret = BCME_NOTUP;\n\t\t\tgoto done;\n\t\t}\n\t\tmemcpy(dhd->mac.octet, ea_addr.octet, ETHER_ADDR_LEN);\n\t} else {\n#endif /* GET_CUSTOM_MAC_ENABLE */\n\t\t/* Get the default device MAC address directly from firmware */\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tbcm_mkiovar(\"cur_etheraddr\", 0, 0, buf, sizeof(buf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, buf, sizeof(buf),\n\t\t\tFALSE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s: can't get MAC address , error=%d\\n\", __FUNCTION__, ret));\n\t\t\tret = BCME_NOTUP;\n\t\t\tgoto done;\n\t\t}\n\t\t/* Update public MAC address after reading from Firmware */\n\t\tmemcpy(dhd->mac.octet, buf, ETHER_ADDR_LEN);\n\n#ifdef GET_CUSTOM_MAC_ENABLE\n\t}\n#endif /* GET_CUSTOM_MAC_ENABLE */\n\n\t/* get a capabilities from firmware */\n\tmemset(dhd->fw_capabilities, 0, sizeof(dhd->fw_capabilities));\n\tbcm_mkiovar(\"cap\", 0, 0, dhd->fw_capabilities, sizeof(dhd->fw_capabilities));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, dhd->fw_capabilities,\n\t\tsizeof(dhd->fw_capabilities), FALSE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s: Get Capability failed (error=%d)\\n\",\n\t\t\t__FUNCTION__, ret));\n\t\tgoto done;\n\t}\n\tif ((!op_mode && dhd_get_fw_mode(dhd->info) == DHD_FLAG_HOSTAP_MODE) ||\n\t\t(op_mode == DHD_FLAG_HOSTAP_MODE)) {\n#ifdef SET_RANDOM_MAC_SOFTAP\n\t\tuint rand_mac;\n#endif\n\t\tdhd->op_mode = DHD_FLAG_HOSTAP_MODE;\n#if defined(ARP_OFFLOAD_SUPPORT)\n\t\tarpoe = 0;\n#endif\n#ifdef PKT_FILTER_SUPPORT\n\t\t\tdhd_pkt_filter_enable = FALSE;\n#endif\n#ifdef SET_RANDOM_MAC_SOFTAP\n\t\tSRANDOM32((uint)jiffies);\n\t\trand_mac = RANDOM32();\n\t\tiovbuf[0] = 0x02;\t\t\t   /* locally administered bit */\n\t\tiovbuf[1] = 0x1A;\n\t\tiovbuf[2] = 0x11;\n\t\tiovbuf[3] = (unsigned char)(rand_mac & 0x0F) | 0xF0;\n\t\tiovbuf[4] = (unsigned char)(rand_mac >> 8);\n\t\tiovbuf[5] = (unsigned char)(rand_mac >> 16);\n\n\t\tbcm_mkiovar(\"cur_etheraddr\", (void *)iovbuf, ETHER_ADDR_LEN, buf, sizeof(buf));\n\t\tret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, buf, sizeof(buf), TRUE, 0);\n\t\tif (ret < 0) {\n\t\t\tDHD_ERROR((\"%s: can't set MAC address , error=%d\\n\", __FUNCTION__, ret));\n\t\t} else\n\t\t\tmemcpy(dhd->mac.octet, iovbuf, ETHER_ADDR_LEN);\n#endif /* SET_RANDOM_MAC_SOFTAP */\n#if !defined(AP) && defined(WL_CFG80211)\n\t\t/* Turn off MPC in AP mode */\n\t\tbcm_mkiovar(\"mpc\", (char *)&mpc, 4, iovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s mpc for HostAPD failed  %d\\n\", __FUNCTION__, ret));\n\t\t}\n#endif\n#ifdef SUPPORT_AP_POWERSAVE\n\t\tdhd_set_ap_powersave(dhd, 0, TRUE);\n#endif\n#ifdef SOFTAP_UAPSD_OFF\n\t\tbcm_mkiovar(\"wme_apsd\", (char *)&wme_apsd, 4, iovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)\n\t\t\tDHD_ERROR((\"%s: set wme_apsd 0 fail (error=%d)\\n\", __FUNCTION__, ret));\n#endif /* SOFTAP_UAPSD_OFF */\n\t} else if ((!op_mode && dhd_get_fw_mode(dhd->info) == DHD_FLAG_MFG_MODE) ||\n\t\t(op_mode == DHD_FLAG_MFG_MODE)) {\n#if defined(ARP_OFFLOAD_SUPPORT)\n\t\tarpoe = 0;\n#endif /* ARP_OFFLOAD_SUPPORT */\n#ifdef PKT_FILTER_SUPPORT\n\t\tdhd_pkt_filter_enable = FALSE;\n#endif /* PKT_FILTER_SUPPORT */\n\t\tdhd->op_mode = DHD_FLAG_MFG_MODE;\n\t} else {\n\t\tuint32 concurrent_mode = 0;\n\t\tif ((!op_mode && dhd_get_fw_mode(dhd->info) == DHD_FLAG_P2P_MODE) ||\n\t\t\t(op_mode == DHD_FLAG_P2P_MODE)) {\n#if defined(ARP_OFFLOAD_SUPPORT)\n\t\t\tarpoe = 0;\n#endif\n#ifdef PKT_FILTER_SUPPORT\n\t\t\tdhd_pkt_filter_enable = FALSE;\n#endif\n\t\t\tdhd->op_mode = DHD_FLAG_P2P_MODE;\n\t\t} else if ((!op_mode && dhd_get_fw_mode(dhd->info) == DHD_FLAG_IBSS_MODE) ||\n\t\t\t(op_mode == DHD_FLAG_IBSS_MODE)) {\n\t\t\tdhd->op_mode = DHD_FLAG_IBSS_MODE;\n\t\t} else\n\t\t\tdhd->op_mode = DHD_FLAG_STA_MODE;\n#if !defined(AP) && defined(WLP2P)\n\t\tif (dhd->op_mode != DHD_FLAG_IBSS_MODE &&\n\t\t\t(concurrent_mode = dhd_get_concurrent_capabilites(dhd))) {\n#if defined(ARP_OFFLOAD_SUPPORT)\n\t\t\tarpoe = 1;\n#endif\n\t\t\tdhd->op_mode |= concurrent_mode;\n\t\t}\n\n\t\t/* Check if we are enabling p2p */\n\t\tif (dhd->op_mode & DHD_FLAG_P2P_MODE) {\n\t\t\tbcm_mkiovar(\"apsta\", (char *)&apsta, 4, iovbuf, sizeof(iovbuf));\n\t\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR,\n\t\t\t\tiovbuf, sizeof(iovbuf), TRUE, 0)) < 0) {\n\t\t\t\tDHD_ERROR((\"%s APSTA for P2P failed ret= %d\\n\", __FUNCTION__, ret));\n\t\t\t}\n\n#if defined(SOFTAP_AND_GC)\n\t\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_AP,\n\t\t\t\t(char *)&ap_mode, sizeof(ap_mode), TRUE, 0)) < 0) {\n\t\t\t\t\tDHD_ERROR((\"%s WLC_SET_AP failed %d\\n\", __FUNCTION__, ret));\n\t\t\t}\n#endif\n\t\t\tmemcpy(&p2p_ea, &dhd->mac, ETHER_ADDR_LEN);\n\t\t\tETHER_SET_LOCALADDR(&p2p_ea);\n\t\t\tbcm_mkiovar(\"p2p_da_override\", (char *)&p2p_ea,\n\t\t\t\tETHER_ADDR_LEN, iovbuf, sizeof(iovbuf));\n\t\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR,\n\t\t\t\tiovbuf, sizeof(iovbuf), TRUE, 0)) < 0) {\n\t\t\t\tDHD_ERROR((\"%s p2p_da_override ret= %d\\n\", __FUNCTION__, ret));\n\t\t\t} else {\n\t\t\t\tDHD_INFO((\"dhd_preinit_ioctls: p2p_da_override succeeded\\n\"));\n\t\t\t}\n\t\t}\n#else\n\t\t(void)concurrent_mode;\n#endif \n\t}\n\n\tDHD_ERROR((\"Firmware up: op_mode=0x%04x, MAC=\"MACDBG\"\\n\",\n\t\tdhd->op_mode, MAC2STRDBG(dhd->mac.octet)));\n\t/* Set Country code  */\n\tif (dhd->dhd_cspec.ccode[0] != 0) {\n\t\tprintf(\"Set country %s, revision %d\\n\", dhd->dhd_cspec.ccode, dhd->dhd_cspec.rev);\n\t\tbcm_mkiovar(\"country\", (char *)&dhd->dhd_cspec,\n\t\t\tsizeof(wl_country_t), iovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)\n\t\t\tprintf(\"%s: country code setting failed %d\\n\", __FUNCTION__, ret);\n\t} else {\n\t\tdhd_conf_set_country(dhd);\n\t\tdhd_conf_fix_country(dhd);\n\t}\n\tdhd_conf_get_country(dhd, &dhd->dhd_cspec);\n\n#if defined(DISABLE_11AC)\n\tbcm_mkiovar(\"vhtmode\", (char *)&vhtmode, 4, iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)\n\t\tDHD_ERROR((\"%s wl vhtmode 0 failed %d\\n\", __FUNCTION__, ret));\n#endif /* DISABLE_11AC */\n\n\t/* Set Listen Interval */\n\tbcm_mkiovar(\"assoc_listen\", (char *)&listen_interval, 4, iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)\n\t\tDHD_ERROR((\"%s assoc_listen failed %d\\n\", __FUNCTION__, ret));\n\n#if defined(ROAM_ENABLE) || defined(DISABLE_BUILTIN_ROAM)\n\t/* Disable built-in roaming to allowed ext supplicant to take care of roaming */\n\tbcm_mkiovar(\"roam_off\", (char *)&roamvar, 4, iovbuf, sizeof(iovbuf));\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n#endif /* ROAM_ENABLE || DISABLE_BUILTIN_ROAM */\n#if defined(ROAM_ENABLE)\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_ROAM_TRIGGER, roam_trigger,\n\t\tsizeof(roam_trigger), TRUE, 0)) < 0)\n\t\tDHD_ERROR((\"%s: roam trigger set failed %d\\n\", __FUNCTION__, ret));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_ROAM_SCAN_PERIOD, roam_scan_period,\n\t\tsizeof(roam_scan_period), TRUE, 0)) < 0)\n\t\tDHD_ERROR((\"%s: roam scan period set failed %d\\n\", __FUNCTION__, ret));\n\tif ((dhd_wl_ioctl_cmd(dhd, WLC_SET_ROAM_DELTA, roam_delta,\n\t\tsizeof(roam_delta), TRUE, 0)) < 0)\n\t\tDHD_ERROR((\"%s: roam delta set failed %d\\n\", __FUNCTION__, ret));\n\tbcm_mkiovar(\"fullroamperiod\", (char *)&roam_fullscan_period, 4, iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)\n\t\tDHD_ERROR((\"%s: roam fullscan period set failed %d\\n\", __FUNCTION__, ret));\n#endif /* ROAM_ENABLE */\n\tdhd_conf_set_roam(dhd);\n\n#ifdef BCMCCX\n\tbcm_mkiovar(\"ccx_enable\", (char *)&ccx, 4, iovbuf, sizeof(iovbuf));\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n#endif /* BCMCCX */\n#ifdef WLTDLS\n\t/* by default TDLS on and auto mode off */\n\t_dhd_tdls_enable(dhd, true, false, NULL);\n#endif /* WLTDLS */\n\n#ifdef DHD_ENABLE_LPC\n\t/* Set lpc 1 */\n\tbcm_mkiovar(\"lpc\", (char *)&lpc, 4, iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s Set lpc failed  %d\\n\", __FUNCTION__, ret));\n\t}\n#endif /* DHD_ENABLE_LPC */\n\tdhd_conf_set_fw_string_cmd(dhd, \"lpc\", dhd->conf->lpc, 0, FALSE);\n\n\t/* Set PowerSave mode */\n\tif (dhd->conf->pm >= 0)\n\t\tpower_mode = dhd->conf->pm;\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_PM, (char *)&power_mode, sizeof(power_mode), TRUE, 0);\n\tdhd_conf_set_fw_string_cmd(dhd, \"pm2_sleep_ret\", dhd->conf->pm2_sleep_ret, 0, FALSE);\n\n\t/* Match Host and Dongle rx alignment */\n\tbcm_mkiovar(\"bus:txglomalign\", (char *)&dongle_align, 4, iovbuf, sizeof(iovbuf));\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\n#if defined(CUSTOMER_HW2) && defined(USE_WL_CREDALL)\n\t/* enable credall to reduce the chance of no bus credit happened. */\n\tbcm_mkiovar(\"bus:credall\", (char *)&credall, 4, iovbuf, sizeof(iovbuf));\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n#endif\n\n#if defined(BCMSDIO)\n\tif (glom != DEFAULT_GLOM_VALUE) {\n\t\tDHD_INFO((\"%s set glom=0x%X\\n\", __FUNCTION__, glom));\n\t\tbcm_mkiovar(\"bus:txglom\", (char *)&glom, 4, iovbuf, sizeof(iovbuf));\n\t\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\t}\n#endif /* defined(BCMSDIO) */\n\n\t/* Setup timeout if Beacons are lost and roam is off to report link down */\n\tbcm_mkiovar(\"bcn_timeout\", (char *)&bcn_timeout, 4, iovbuf, sizeof(iovbuf));\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\t/* Setup assoc_retry_max count to reconnect target AP in dongle */\n\tbcm_mkiovar(\"assoc_retry_max\", (char *)&retry_max, 4, iovbuf, sizeof(iovbuf));\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n#if defined(AP) && !defined(WLP2P)\n\t/* Turn off MPC in AP mode */\n\tbcm_mkiovar(\"mpc\", (char *)&mpc, 4, iovbuf, sizeof(iovbuf));\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\tbcm_mkiovar(\"apsta\", (char *)&apsta, 4, iovbuf, sizeof(iovbuf));\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n#endif /* defined(AP) && !defined(WLP2P) */\n\t/*  0:HT20 in ALL, 1:HT40 in ALL, 2: HT20 in 2G HT40 in 5G */\n\tdhd_conf_set_fw_string_cmd(dhd, \"mimo_bw_cap\", dhd->conf->mimo_bw_cap, 1, TRUE);\n\tdhd_conf_set_fw_string_cmd(dhd, \"force_wme_ac\", dhd->conf->force_wme_ac, 1, FALSE);\n\tdhd_conf_set_fw_string_cmd(dhd, \"stbc_tx\", dhd->conf->stbc, 0, FALSE);\n\tdhd_conf_set_fw_string_cmd(dhd, \"stbc_rx\", dhd->conf->stbc, 0, FALSE);\n\tdhd_conf_set_fw_int_cmd(dhd, \"WLC_SET_SRL\", WLC_SET_SRL, dhd->conf->srl, 0, TRUE);\n\tdhd_conf_set_fw_int_cmd(dhd, \"WLC_SET_LRL\", WLC_SET_LRL, dhd->conf->lrl, 0, FALSE);\n\tdhd_conf_set_fw_int_cmd(dhd, \"WLC_SET_SPECT_MANAGMENT\", WLC_SET_SPECT_MANAGMENT, dhd->conf->spect, 0, FALSE);\n\tdhd_conf_set_fw_string_cmd(dhd, \"rsdb_mode\", dhd->conf->rsdb_mode, -1, TRUE);\n\tdhd_conf_set_fw_string_cmd(dhd, \"vhtmode\", dhd->conf->vhtmode, 0, TRUE);\n\tdhd_conf_set_bw_cap(dhd);\n\n#if defined(SOFTAP)\n\tif (ap_fw_loaded == TRUE) {\n\t\tdhd_wl_ioctl_cmd(dhd, WLC_SET_DTIMPRD, (char *)&dtim, sizeof(dtim), TRUE, 0);\n\t}\n#endif \n\n#if defined(KEEP_ALIVE)\n\t{\n\t/* Set Keep Alive : be sure to use FW with -keepalive */\n\tint res;\n\n#if defined(SOFTAP)\n\tif (ap_fw_loaded == FALSE)\n#endif \n\t\tif (!(dhd->op_mode &\n\t\t\t(DHD_FLAG_HOSTAP_MODE | DHD_FLAG_MFG_MODE))) {\n\t\t\tif ((res = dhd_keep_alive_onoff(dhd)) < 0)\n\t\t\t\tDHD_ERROR((\"%s set keeplive failed %d\\n\",\n\t\t\t\t__FUNCTION__, res));\n\t\t}\n\t}\n#endif /* defined(KEEP_ALIVE) */\n\n#ifdef USE_WL_TXBF\n\tbcm_mkiovar(\"txbf\", (char *)&txbf, 4, iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s Set txbf failed  %d\\n\", __FUNCTION__, ret));\n\t}\n#endif /* USE_WL_TXBF */\n\tdhd_conf_set_fw_string_cmd(dhd, \"txbf\", dhd->conf->txbf, 0, FALSE);\n#ifdef USE_WL_FRAMEBURST\n\t/* Set frameburst to value */\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_FAKEFRAG, (char *)&frameburst,\n\t\tsizeof(frameburst), TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s Set frameburst failed  %d\\n\", __FUNCTION__, ret));\n\t}\n#endif /* USE_WL_FRAMEBURST */\n\tdhd_conf_set_fw_int_cmd(dhd, \"WLC_SET_FAKEFRAG\", WLC_SET_FAKEFRAG, dhd->conf->frameburst, 0, FALSE);\n#ifdef DHD_SET_FW_HIGHSPEED\n\t/* Set ack_ratio */\n\tbcm_mkiovar(\"ack_ratio\", (char *)&ack_ratio, 4, iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s Set ack_ratio failed  %d\\n\", __FUNCTION__, ret));\n\t}\n\n\t/* Set ack_ratio_depth */\n\tbcm_mkiovar(\"ack_ratio_depth\", (char *)&ack_ratio_depth, 4, iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s Set ack_ratio_depth failed  %d\\n\", __FUNCTION__, ret));\n\t}\n#endif /* DHD_SET_FW_HIGHSPEED */\n#if defined(CUSTOM_AMPDU_BA_WSIZE) || (defined(WLAIBSS) && \\\n\tdefined(CUSTOM_IBSS_AMPDU_BA_WSIZE))\n\t/* Set ampdu ba wsize to 64 or 16 */\n#ifdef CUSTOM_AMPDU_BA_WSIZE\n\tampdu_ba_wsize = CUSTOM_AMPDU_BA_WSIZE;\n#endif\n#if defined(WLAIBSS) && defined(CUSTOM_IBSS_AMPDU_BA_WSIZE)\n\tif (dhd->op_mode == DHD_FLAG_IBSS_MODE)\n\t\tampdu_ba_wsize = CUSTOM_IBSS_AMPDU_BA_WSIZE;\n#endif /* WLAIBSS && CUSTOM_IBSS_AMPDU_BA_WSIZE */\n\tif (ampdu_ba_wsize != 0) {\n\t\tbcm_mkiovar(\"ampdu_ba_wsize\", (char *)&ampdu_ba_wsize, 4, iovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s Set ampdu_ba_wsize to %d failed  %d\\n\",\n\t\t\t\t__FUNCTION__, ampdu_ba_wsize, ret));\n\t\t}\n\t}\n#endif /* CUSTOM_AMPDU_BA_WSIZE || (WLAIBSS && CUSTOM_IBSS_AMPDU_BA_WSIZE) */\n\tdhd_conf_set_fw_string_cmd(dhd, \"ampdu_ba_wsize\", dhd->conf->ampdu_ba_wsize, 1, FALSE);\n\n\tiov_buf = (char*)kmalloc(WLC_IOCTL_SMLEN, GFP_KERNEL);\n\tif (iov_buf == NULL) {\n\t\tDHD_ERROR((\"failed to allocate %d bytes for iov_buf\\n\", WLC_IOCTL_SMLEN));\n\t\tret = BCME_NOMEM;\n\t\tgoto done;\n\t}\n#ifdef WLAIBSS\n\t/* Configure custom IBSS beacon transmission */\n\tif (dhd->op_mode & DHD_FLAG_IBSS_MODE)\n\t{\n\t\taibss = 1;\n\t\tbcm_mkiovar(\"aibss\", (char *)&aibss, 4, iovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s Set aibss to %d failed  %d\\n\",\n\t\t\t\t__FUNCTION__, aibss, ret));\n\t\t}\n#ifdef WLAIBSS_PS\n\t\taibss_ps = 1;\n\t\tbcm_mkiovar(\"aibss_ps\", (char *)&aibss_ps, 4, iovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s Set aibss PS to %d failed  %d\\n\",\n\t\t\t\t__FUNCTION__, aibss, ret));\n\t\t}\n#endif /* WLAIBSS_PS */\n\t}\n\tmemset(&bcn_config, 0, sizeof(bcn_config));\n\tbcn_config.initial_min_bcn_dur = AIBSS_INITIAL_MIN_BCN_DUR;\n\tbcn_config.min_bcn_dur = AIBSS_MIN_BCN_DUR;\n\tbcn_config.bcn_flood_dur = AIBSS_BCN_FLOOD_DUR;\n\tbcn_config.version = AIBSS_BCN_FORCE_CONFIG_VER_0;\n\tbcn_config.len = sizeof(bcn_config);\n\n\tbcm_mkiovar(\"aibss_bcn_force_config\", (char *)&bcn_config,\n\t\tsizeof(aibss_bcn_force_config_t), iov_buf, WLC_IOCTL_SMLEN);\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iov_buf,\n\t\tWLC_IOCTL_SMLEN, TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s Set aibss_bcn_force_config to %d, %d, %d failed %d\\n\",\n\t\t\t__FUNCTION__, AIBSS_INITIAL_MIN_BCN_DUR, AIBSS_MIN_BCN_DUR,\n\t\t\tAIBSS_BCN_FLOOD_DUR, ret));\n\t}\n#endif /* WLAIBSS */\n\n#if defined(CUSTOM_AMPDU_MPDU)\n\tampdu_mpdu = CUSTOM_AMPDU_MPDU;\n\tif (ampdu_mpdu != 0 && (ampdu_mpdu <= ampdu_ba_wsize)) {\n\t\tbcm_mkiovar(\"ampdu_mpdu\", (char *)&ampdu_mpdu, 4, iovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s Set ampdu_mpdu to %d failed  %d\\n\",\n\t\t\t\t__FUNCTION__, CUSTOM_AMPDU_MPDU, ret));\n\t\t}\n\t}\n#endif /* CUSTOM_AMPDU_MPDU */\n\n#if defined(CUSTOM_AMPDU_RELEASE)\n\tampdu_release = CUSTOM_AMPDU_RELEASE;\n\tif (ampdu_release != 0 && (ampdu_release <= ampdu_ba_wsize)) {\n\t\tbcm_mkiovar(\"ampdu_release\", (char *)&ampdu_release, 4, iovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s Set ampdu_release to %d failed  %d\\n\",\n\t\t\t\t__FUNCTION__, CUSTOM_AMPDU_RELEASE, ret));\n\t\t}\n\t}\n#endif /* CUSTOM_AMPDU_RELEASE */\n\n#if defined(CUSTOM_AMSDU_AGGSF)\n\tamsdu_aggsf = CUSTOM_AMSDU_AGGSF;\n\tif (amsdu_aggsf != 0) {\n\t\tbcm_mkiovar(\"amsdu_aggsf\", (char *)&amsdu_aggsf, 4, iovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s Set amsdu_aggsf to %d failed  %d\\n\",\n\t\t\t\t__FUNCTION__, CUSTOM_AMSDU_AGGSF, ret));\n\t\t}\n\t}\n#endif /* CUSTOM_AMSDU_AGGSF */\n\n#if defined(BCMSUP_4WAY_HANDSHAKE) && defined(WLAN_AKM_SUITE_FT_8021X)\n\t/* Read 4-way handshake requirements */\n\tif (dhd_use_idsup == 1) {\n\t\tbcm_mkiovar(\"sup_wpa\", (char *)&sup_wpa, 4, iovbuf, sizeof(iovbuf));\n\t\tret = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, iovbuf, sizeof(iovbuf), FALSE, 0);\n\t\t/* sup_wpa iovar returns NOTREADY status on some platforms using modularized\n\t\t * in-dongle supplicant.\n\t\t */\n\t\tif (ret >= 0 || ret == BCME_NOTREADY)\n\t\t\tdhd->fw_4way_handshake = TRUE;\n\t\tDHD_TRACE((\"4-way handshake mode is: %d\\n\", dhd->fw_4way_handshake));\n\t}\n#endif /* BCMSUP_4WAY_HANDSHAKE && WLAN_AKM_SUITE_FT_8021X */\n#ifdef SUPPORT_2G_VHT\n\tbcm_mkiovar(\"vht_features\", (char *)&vht_features, 4, iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s vht_features set failed %d\\n\", __FUNCTION__, ret));\n\t}\n#endif /* SUPPORT_2G_VHT */\n#ifdef CUSTOM_PSPRETEND_THR\n\t/* Turn off MPC in AP mode */\n\tbcm_mkiovar(\"pspretend_threshold\", (char *)&pspretend_thr, 4,\n\t\tiovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s pspretend_threshold for HostAPD failed  %d\\n\",\n\t\t\t__FUNCTION__, ret));\n\t}\n#endif\n\n\tbcm_mkiovar(\"buf_key_b4_m4\", (char *)&buf_key_b4_m4, 4, iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf,\n\t\tsizeof(iovbuf), TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s buf_key_b4_m4 set failed %d\\n\", __FUNCTION__, ret));\n\t}\n\n\t/* Read event_msgs mask */\n\tbcm_mkiovar(\"event_msgs\", eventmask, WL_EVENTING_MASK_LEN, iovbuf, sizeof(iovbuf));\n\tif ((ret  = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, iovbuf, sizeof(iovbuf), FALSE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s read Event mask failed %d\\n\", __FUNCTION__, ret));\n\t\tgoto done;\n\t}\n\tbcopy(iovbuf, eventmask, WL_EVENTING_MASK_LEN);\n\n\t/* Setup event_msgs */\n\tsetbit(eventmask, WLC_E_SET_SSID);\n\tsetbit(eventmask, WLC_E_PRUNE);\n\tsetbit(eventmask, WLC_E_AUTH);\n\tsetbit(eventmask, WLC_E_AUTH_IND);\n\tsetbit(eventmask, WLC_E_ASSOC);\n\tsetbit(eventmask, WLC_E_REASSOC);\n\tsetbit(eventmask, WLC_E_REASSOC_IND);\n\tsetbit(eventmask, WLC_E_DEAUTH);\n\tsetbit(eventmask, WLC_E_DEAUTH_IND);\n\tsetbit(eventmask, WLC_E_DISASSOC_IND);\n\tsetbit(eventmask, WLC_E_DISASSOC);\n\tsetbit(eventmask, WLC_E_JOIN);\n\tsetbit(eventmask, WLC_E_START);\n\tsetbit(eventmask, WLC_E_ASSOC_IND);\n\tsetbit(eventmask, WLC_E_PSK_SUP);\n\tsetbit(eventmask, WLC_E_LINK);\n\tsetbit(eventmask, WLC_E_NDIS_LINK);\n\tsetbit(eventmask, WLC_E_MIC_ERROR);\n\tsetbit(eventmask, WLC_E_ASSOC_REQ_IE);\n\tsetbit(eventmask, WLC_E_ASSOC_RESP_IE);\n#ifndef WL_CFG80211\n\tsetbit(eventmask, WLC_E_PMKID_CACHE);\n\tsetbit(eventmask, WLC_E_TXFAIL);\n#endif\n\tsetbit(eventmask, WLC_E_JOIN_START);\n//\tsetbit(eventmask, WLC_E_SCAN_COMPLETE); // terence 20150628: remove redundant event\n#ifdef WLMEDIA_HTSF\n\tsetbit(eventmask, WLC_E_HTSFSYNC);\n#endif /* WLMEDIA_HTSF */\n#ifdef PNO_SUPPORT\n\tsetbit(eventmask, WLC_E_PFN_NET_FOUND);\n\tsetbit(eventmask, WLC_E_PFN_BEST_BATCHING);\n\tsetbit(eventmask, WLC_E_PFN_BSSID_NET_FOUND);\n\tsetbit(eventmask, WLC_E_PFN_BSSID_NET_LOST);\n#endif /* PNO_SUPPORT */\n\t/* enable dongle roaming event */\n\tsetbit(eventmask, WLC_E_ROAM);\n\tsetbit(eventmask, WLC_E_BSSID);\n#ifdef BCMCCX\n\tsetbit(eventmask, WLC_E_ADDTS_IND);\n\tsetbit(eventmask, WLC_E_DELTS_IND);\n#endif /* BCMCCX */\n#ifdef WLTDLS\n\tsetbit(eventmask, WLC_E_TDLS_PEER_EVENT);\n#endif /* WLTDLS */\n#ifdef WL_ESCAN\n\tsetbit(eventmask, WLC_E_ESCAN_RESULT);\n#endif\n#ifdef WL_CFG80211\n\tsetbit(eventmask, WLC_E_ESCAN_RESULT);\n\tif (dhd->op_mode & DHD_FLAG_P2P_MODE) {\n\t\tsetbit(eventmask, WLC_E_ACTION_FRAME_RX);\n\t\tsetbit(eventmask, WLC_E_P2P_DISC_LISTEN_COMPLETE);\n\t}\n#endif /* WL_CFG80211 */\n#ifdef WLAIBSS\n\tsetbit(eventmask, WLC_E_AIBSS_TXFAIL);\n#endif /* WLAIBSS */\n#ifdef CUSTOMER_HW10\n\tclrbit(eventmask, WLC_E_TRACE);\n#else\n\tsetbit(eventmask, WLC_E_TRACE);\n#endif\n\t/* Write updated Event mask */\n\tbcm_mkiovar(\"event_msgs\", eventmask, WL_EVENTING_MASK_LEN, iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s Set Event mask failed %d\\n\", __FUNCTION__, ret));\n\t\tgoto done;\n\t}\n\n\t/* make up event mask ext message iovar for event larger than 128 */\n\tmsglen = ROUNDUP(WLC_E_LAST, NBBY)/NBBY + EVENTMSGS_EXT_STRUCT_SIZE;\n\teventmask_msg = (eventmsgs_ext_t*)kmalloc(msglen, GFP_KERNEL);\n\tif (eventmask_msg == NULL) {\n\t\tDHD_ERROR((\"failed to allocate %d bytes for event_msg_ext\\n\", msglen));\n\t\tret = BCME_NOMEM;\n\t\tgoto done;\n\t}\n\tbzero(eventmask_msg, msglen);\n\teventmask_msg->ver = EVENTMSGS_VER;\n\teventmask_msg->len = ROUNDUP(WLC_E_LAST, NBBY)/NBBY;\n\n\t/* Read event_msgs_ext mask */\n\tbcm_mkiovar(\"event_msgs_ext\", (char *)eventmask_msg, msglen, iov_buf, WLC_IOCTL_SMLEN);\n\tret2  = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, iov_buf, WLC_IOCTL_SMLEN, FALSE, 0);\n\tif (ret2 != BCME_UNSUPPORTED)\n\t\tret = ret2;\n\tif (ret2 == 0) { /* event_msgs_ext must be supported */\n\t\tbcopy(iov_buf, eventmask_msg, msglen);\n\n#ifdef BT_WIFI_HANDOVER\n\t\tsetbit(eventmask_msg->mask, WLC_E_BT_WIFI_HANDOVER_REQ);\n#endif /* BT_WIFI_HANDOVER */\n\n\t\t/* Write updated Event mask */\n\t\teventmask_msg->ver = EVENTMSGS_VER;\n\t\teventmask_msg->command = EVENTMSGS_SET_MASK;\n\t\teventmask_msg->len = ROUNDUP(WLC_E_LAST, NBBY)/NBBY;\n\t\tbcm_mkiovar(\"event_msgs_ext\", (char *)eventmask_msg,\n\t\t\tmsglen, iov_buf, WLC_IOCTL_SMLEN);\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR,\n\t\t\tiov_buf, WLC_IOCTL_SMLEN, TRUE, 0)) < 0) {\n\t\t\tDHD_ERROR((\"%s write event mask ext failed %d\\n\", __FUNCTION__, ret));\n\t\t\tgoto done;\n\t\t}\n\t} else if (ret2 < 0 && ret2 != BCME_UNSUPPORTED) {\n\t\tDHD_ERROR((\"%s read event mask ext failed %d\\n\", __FUNCTION__, ret2));\n\t\tgoto done;\n\t} /* unsupported is ok */\n\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_SCAN_CHANNEL_TIME, (char *)&scan_assoc_time,\n\t\tsizeof(scan_assoc_time), TRUE, 0);\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_SCAN_UNASSOC_TIME, (char *)&scan_unassoc_time,\n\t\tsizeof(scan_unassoc_time), TRUE, 0);\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_SCAN_PASSIVE_TIME, (char *)&scan_passive_time,\n\t\tsizeof(scan_passive_time), TRUE, 0);\n\n#ifdef ARP_OFFLOAD_SUPPORT\n\t/* Set and enable ARP offload feature for STA only  */\n#if defined(SOFTAP)\n\tif (arpoe && !ap_fw_loaded)\n#else\n\tif (arpoe)\n#endif\n\t{\n\t\tdhd_arp_offload_enable(dhd, TRUE);\n\t\tdhd_arp_offload_set(dhd, dhd_arp_mode);\n\t} else {\n\t\tdhd_arp_offload_enable(dhd, FALSE);\n\t\tdhd_arp_offload_set(dhd, 0);\n\t}\n\tdhd_arp_enable = arpoe;\n#endif /* ARP_OFFLOAD_SUPPORT */\n\n#ifdef PKT_FILTER_SUPPORT\n\t/* Setup default defintions for pktfilter , enable in suspend */\n\tdhd->pktfilter_count = 6;\n\t/* Setup filter to allow only unicast */\n\tif (dhd_master_mode) {\n\t\tdhd->pktfilter[DHD_UNICAST_FILTER_NUM] = \"100 0 0 0 0x01 0x00\";\n\t\tdhd->pktfilter[DHD_BROADCAST_FILTER_NUM] = NULL;\n\t\tdhd->pktfilter[DHD_MULTICAST4_FILTER_NUM] = NULL;\n\t\tdhd->pktfilter[DHD_MULTICAST6_FILTER_NUM] = NULL;\n\t\t/* Add filter to pass multicastDNS packet and NOT filter out as Broadcast */\n\t\tdhd->pktfilter[DHD_MDNS_FILTER_NUM] = \"104 0 0 0 0xFFFFFFFFFFFF 0x01005E0000FB\";\n\t\t/* apply APP pktfilter */\n\t\tdhd->pktfilter[DHD_ARP_FILTER_NUM] = \"105 0 0 12 0xFFFF 0x0806\";\n\t} else\n\t\tdhd_conf_discard_pkt_filter(dhd);\n\tdhd_conf_add_pkt_filter(dhd);\n\n#if defined(SOFTAP)\n\tif (ap_fw_loaded) {\n\t\tdhd_enable_packet_filter(0, dhd);\n\t}\n#endif /* defined(SOFTAP) */\n\tdhd_set_packet_filter(dhd);\n#endif /* PKT_FILTER_SUPPORT */\n#ifdef DISABLE_11N\n\tbcm_mkiovar(\"nmode\", (char *)&nmode, 4, iovbuf, sizeof(iovbuf));\n\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)\n\t\tDHD_ERROR((\"%s wl nmode 0 failed %d\\n\", __FUNCTION__, ret));\n#endif /* DISABLE_11N */\n\n#ifdef AMPDU_VO_ENABLE\n\ttid.tid = PRIO_8021D_VO; /* Enable TID(6) for voice */\n\ttid.enable = TRUE;\n\tbcm_mkiovar(\"ampdu_tid\", (char *)&tid, sizeof(tid), iovbuf, sizeof(iovbuf));\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\n\ttid.tid = PRIO_8021D_NC; /* Enable TID(7) for voice */\n\ttid.enable = TRUE;\n\tbcm_mkiovar(\"ampdu_tid\", (char *)&tid, sizeof(tid), iovbuf, sizeof(iovbuf));\n\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n#endif\n#if defined(SOFTAP_TPUT_ENHANCE)\n\tif (dhd->op_mode & DHD_FLAG_HOSTAP_MODE) {\n\t\tdhd_bus_setidletime(dhd, (int)100);\n#ifdef DHDTCPACK_SUPPRESS\n\t\tdhd->tcpack_sup_enabled = FALSE;\n#endif\n#if defined(DHD_TCP_WINSIZE_ADJUST)\n\t\tdhd_use_tcp_window_size_adjust = TRUE;\n#endif\n\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tbcm_mkiovar(\"bus:txglom_auto_control\", 0, 0, buf, sizeof(buf));\n\t\tif ((ret  = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, buf, sizeof(buf), FALSE, 0)) < 0) {\n\t\t\tglom = 0;\n\t\t\tbcm_mkiovar(\"bus:txglom\", (char *)&glom, 4, iovbuf, sizeof(iovbuf));\n\t\t\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\t\t}\n\t\telse {\n\t\t\tif (buf[0] == 0) {\n\t\t\t\tglom = 1;\n\t\t\t\tbcm_mkiovar(\"bus:txglom_auto_control\", (char *)&glom, 4, iovbuf,\n\t\t\t\tsizeof(iovbuf));\n\t\t\t\tdhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\t\t\t}\n\t\t}\n\t}\n#endif /* SOFTAP_TPUT_ENHANCE */\n\n\t/* query for 'ver' to get version info from firmware */\n\tmemset(buf, 0, sizeof(buf));\n\tptr = buf;\n\tbcm_mkiovar(\"ver\", (char *)&buf, 4, buf, sizeof(buf));\n\tif ((ret  = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, buf, sizeof(buf), FALSE, 0)) < 0)\n\t\tDHD_ERROR((\"%s failed %d\\n\", __FUNCTION__, ret));\n\telse {\n\t\tbcmstrtok(&ptr, \"\\n\", 0);\n\t\t/* Print fw version info */\n\t\tDHD_ERROR((\"Firmware version = %s\\n\", buf));\n\t\tdhd_set_version_info(dhd, buf);\n\t}\n\n#if defined(BCMSDIO)\n\tdhd_txglom_enable(dhd, dhd->conf->bus_rxglom);\n\t// terence 20151210: set bus:txglom after dhd_txglom_enable since it's possible changed in dhd_conf_set_txglom_params\n\tdhd_conf_set_fw_string_cmd(dhd, \"bus:txglom\", dhd->conf->bus_txglom, 0, FALSE);\n#endif /* defined(BCMSDIO) */\n\n\tdhd_conf_set_disable_proptx(dhd);\n#if defined(BCMSDIO)\n#ifdef PROP_TXSTATUS\n\tif (disable_proptx ||\n#ifdef PROP_TXSTATUS_VSDB\n\t\t/* enable WLFC only if the firmware is VSDB when it is in STA mode */\n\t\t(dhd->op_mode != DHD_FLAG_HOSTAP_MODE &&\n\t\t dhd->op_mode != DHD_FLAG_IBSS_MODE) ||\n#endif /* PROP_TXSTATUS_VSDB */\n\t\tFALSE) {\n\t\twlfc_enable = FALSE;\n\t}\n\n#ifndef DISABLE_11N\n\tret = dhd_wl_ioctl_cmd(dhd, WLC_DOWN, (char *)&wl_down, sizeof(wl_down), TRUE, 0);\n\tbcm_mkiovar(\"ampdu_hostreorder\", (char *)&hostreorder, 4, iovbuf, sizeof(iovbuf));\n\tif ((ret2 = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0) {\n\t\tDHD_ERROR((\"%s wl ampdu_hostreorder failed %d\\n\", __FUNCTION__, ret2));\n\t\tif (ret2 != BCME_UNSUPPORTED)\n\t\t\tret = ret2;\n\t\tif (ret2 != BCME_OK)\n\t\t\thostreorder = 0;\n\t}\n#endif /* DISABLE_11N */\n\n#ifdef READ_CONFIG_FROM_FILE\n\tdhd_preinit_config(dhd, 0);\n#endif /* READ_CONFIG_FROM_FILE */\n\n\tif (wlfc_enable)\n\t\tdhd_wlfc_init(dhd);\n#ifndef DISABLE_11N\n\telse if (hostreorder)\n\t\tdhd_wlfc_hostreorder_init(dhd);\n#endif /* DISABLE_11N */\n\n#endif /* PROP_TXSTATUS */\n#endif /* BCMSDIO || BCMBUS */\n#ifdef PCIE_FULL_DONGLE\n\t/* For FD we need all the packets at DHD to handle intra-BSS forwarding */\n\tif (FW_SUPPORTED(dhd, ap)) {\n\t\twl_ap_isolate = AP_ISOLATE_SENDUP_ALL;\n\t\tbcm_mkiovar(\"ap_isolate\", (char *)&wl_ap_isolate, 4, iovbuf, sizeof(iovbuf));\n\t\tif ((ret = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)\n\t\t\tDHD_ERROR((\"%s failed %d\\n\", __FUNCTION__, ret));\n\t}\n#endif /* PCIE_FULL_DONGLE */\n#ifdef PNO_SUPPORT\n\tif (!dhd->pno_state) {\n\t\tdhd_pno_init(dhd);\n\t}\n#endif\n#ifdef WL11U\n\tdhd_interworking_enable(dhd);\n#endif /* WL11U */\n#ifndef WL_CFG80211\n\tdhd_wl_ioctl_cmd(dhd, WLC_UP, (char *)&up, sizeof(up), TRUE, 0);\n#endif\n\ndone:\n\n\tif (eventmask_msg)\n\t\tkfree(eventmask_msg);\n\tif (iov_buf)\n\t\tkfree(iov_buf);\n\n\treturn ret;\n}\n\n\nint\ndhd_iovar(dhd_pub_t *pub, int ifidx, char *name, char *cmd_buf, uint cmd_len, int set)\n{\n\tchar buf[strlen(name) + 1 + cmd_len];\n\tint len = sizeof(buf);\n\twl_ioctl_t ioc;\n\tint ret;\n\n\tlen = bcm_mkiovar(name, cmd_buf, cmd_len, buf, len);\n\n\tmemset(&ioc, 0, sizeof(ioc));\n\n\tioc.cmd = set? WLC_SET_VAR : WLC_GET_VAR;\n\tioc.buf = buf;\n\tioc.len = len;\n\tioc.set = set;\n\n\tret = dhd_wl_ioctl(pub, ifidx, &ioc, ioc.buf, ioc.len);\n\tif (!set && ret >= 0)\n\t\tmemcpy(cmd_buf, buf, cmd_len);\n\n\treturn ret;\n}\n\nint dhd_change_mtu(dhd_pub_t *dhdp, int new_mtu, int ifidx)\n{\n\tstruct dhd_info *dhd = dhdp->info;\n\tstruct net_device *dev = NULL;\n\n\tASSERT(dhd && dhd->iflist[ifidx]);\n\tdev = dhd->iflist[ifidx]->net;\n\tASSERT(dev);\n\n\tif (netif_running(dev)) {\n\t\tDHD_ERROR((\"%s: Must be down to change its MTU\\n\", dev->name));\n\t\treturn BCME_NOTDOWN;\n\t}\n\n#define DHD_MIN_MTU 1500\n#define DHD_MAX_MTU 1752\n\n\tif ((new_mtu < DHD_MIN_MTU) || (new_mtu > DHD_MAX_MTU)) {\n\t\tDHD_ERROR((\"%s: MTU size %d is invalid.\\n\", __FUNCTION__, new_mtu));\n\t\treturn BCME_BADARG;\n\t}\n\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\n#ifdef ARP_OFFLOAD_SUPPORT\n/* add or remove AOE host ip(s) (up to 8 IPs on the interface)  */\nvoid\naoe_update_host_ipv4_table(dhd_pub_t *dhd_pub, u32 ipa, bool add, int idx)\n{\n\tu32 ipv4_buf[MAX_IPV4_ENTRIES]; /* temp save for AOE host_ip table */\n\tint i;\n\tint ret;\n\n\tbzero(ipv4_buf, sizeof(ipv4_buf));\n\n\t/* display what we've got */\n\tret = dhd_arp_get_arp_hostip_table(dhd_pub, ipv4_buf, sizeof(ipv4_buf), idx);\n\tDHD_ARPOE((\"%s: hostip table read from Dongle:\\n\", __FUNCTION__));\n#ifdef AOE_DBG\n\tdhd_print_buf(ipv4_buf, 32, 4); /* max 8 IPs 4b each */\n#endif\n\t/* now we saved hoste_ip table, clr it in the dongle AOE */\n\tdhd_aoe_hostip_clr(dhd_pub, idx);\n\n\tif (ret) {\n\t\tDHD_ERROR((\"%s failed\\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < MAX_IPV4_ENTRIES; i++) {\n\t\tif (add && (ipv4_buf[i] == 0)) {\n\t\t\t\tipv4_buf[i] = ipa;\n\t\t\t\tadd = FALSE; /* added ipa to local table  */\n\t\t\t\tDHD_ARPOE((\"%s: Saved new IP in temp arp_hostip[%d]\\n\",\n\t\t\t\t__FUNCTION__, i));\n\t\t} else if (ipv4_buf[i] == ipa) {\n\t\t\tipv4_buf[i]\t= 0;\n\t\t\tDHD_ARPOE((\"%s: removed IP:%x from temp table %d\\n\",\n\t\t\t\t__FUNCTION__, ipa, i));\n\t\t}\n\n\t\tif (ipv4_buf[i] != 0) {\n\t\t\t/* add back host_ip entries from our local cache */\n\t\t\tdhd_arp_offload_add_ip(dhd_pub, ipv4_buf[i], idx);\n\t\t\tDHD_ARPOE((\"%s: added IP:%x to dongle arp_hostip[%d]\\n\\n\",\n\t\t\t\t__FUNCTION__, ipv4_buf[i], i));\n\t\t}\n\t}\n#ifdef AOE_DBG\n\t/* see the resulting hostip table */\n\tdhd_arp_get_arp_hostip_table(dhd_pub, ipv4_buf, sizeof(ipv4_buf), idx);\n\tDHD_ARPOE((\"%s: read back arp_hostip table:\\n\", __FUNCTION__));\n\tdhd_print_buf(ipv4_buf, 32, 4); /* max 8 IPs 4b each */\n#endif\n}\n\n/*\n * Notification mechanism from kernel to our driver. This function is called by the Linux kernel\n * whenever there is an event related to an IP address.\n * ptr : kernel provided pointer to IP address that has changed\n */\nstatic int dhd_inetaddr_notifier_call(struct notifier_block *this,\n\tunsigned long event,\n\tvoid *ptr)\n{\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\n\tdhd_info_t *dhd;\n\tdhd_pub_t *dhd_pub;\n\tint idx;\n\n\tif (!dhd_arp_enable)\n\t\treturn NOTIFY_DONE;\n\tif (!ifa || !(ifa->ifa_dev->dev))\n\t\treturn NOTIFY_DONE;\n\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31))\n\t/* Filter notifications meant for non Broadcom devices */\n\tif ((ifa->ifa_dev->dev->netdev_ops != &dhd_ops_pri) &&\n\t    (ifa->ifa_dev->dev->netdev_ops != &dhd_ops_virt)) {\n#if defined(WL_ENABLE_P2P_IF)\n\t\tif (!wl_cfgp2p_is_ifops(ifa->ifa_dev->dev->netdev_ops))\n#endif /* WL_ENABLE_P2P_IF */\n\t\t\treturn NOTIFY_DONE;\n\t}\n#endif /* LINUX_VERSION_CODE */\n\n\tdhd = DHD_DEV_INFO(ifa->ifa_dev->dev);\n\tif (!dhd)\n\t\treturn NOTIFY_DONE;\n\n\tdhd_pub = &dhd->pub;\n\n\tif (dhd_pub->arp_version == 1) {\n\t\tidx = 0;\n\t}\n\telse {\n\t\tfor (idx = 0; idx < DHD_MAX_IFS; idx++) {\n\t\t\tif (dhd->iflist[idx] && dhd->iflist[idx]->net == ifa->ifa_dev->dev)\n\t\t\tbreak;\n\t\t}\n\t\tif (idx < DHD_MAX_IFS)\n\t\t\tDHD_TRACE((\"ifidx : %p %s %d\\n\", dhd->iflist[idx]->net,\n\t\t\t\tdhd->iflist[idx]->name, dhd->iflist[idx]->idx));\n\t\telse {\n\t\t\tDHD_ERROR((\"Cannot find ifidx for(%s) set to 0\\n\", ifa->ifa_label));\n\t\t\tidx = 0;\n\t\t}\n\t}\n\n\tswitch (event) {\n\t\tcase NETDEV_UP:\n\t\t\tDHD_ARPOE((\"%s: [%s] Up IP: 0x%x\\n\",\n\t\t\t\t__FUNCTION__, ifa->ifa_label, ifa->ifa_address));\n\n\t\t\tif (dhd->pub.busstate != DHD_BUS_DATA) {\n\t\t\t\tDHD_ERROR((\"%s: bus not ready, exit\\n\", __FUNCTION__));\n\t\t\t\tif (dhd->pend_ipaddr) {\n\t\t\t\t\tDHD_ERROR((\"%s: overwrite pending ipaddr: 0x%x\\n\",\n\t\t\t\t\t\t__FUNCTION__, dhd->pend_ipaddr));\n\t\t\t\t}\n\t\t\t\tdhd->pend_ipaddr = ifa->ifa_address;\n\t\t\t\tbreak;\n\t\t\t}\n\n#ifdef AOE_IP_ALIAS_SUPPORT\n\t\t\tDHD_ARPOE((\"%s:add aliased IP to AOE hostip cache\\n\",\n\t\t\t\t__FUNCTION__));\n\t\t\taoe_update_host_ipv4_table(dhd_pub, ifa->ifa_address, TRUE, idx);\n#endif /* AOE_IP_ALIAS_SUPPORT */\n\t\t\tbreak;\n\n\t\tcase NETDEV_DOWN:\n\t\t\tDHD_ARPOE((\"%s: [%s] Down IP: 0x%x\\n\",\n\t\t\t\t__FUNCTION__, ifa->ifa_label, ifa->ifa_address));\n\t\t\tdhd->pend_ipaddr = 0;\n#ifdef AOE_IP_ALIAS_SUPPORT\n\t\t\tDHD_ARPOE((\"%s:interface is down, AOE clr all for this if\\n\",\n\t\t\t\t__FUNCTION__));\n\t\t\taoe_update_host_ipv4_table(dhd_pub, ifa->ifa_address, FALSE, idx);\n#else\n\t\t\tdhd_aoe_hostip_clr(&dhd->pub, idx);\n\t\t\tdhd_aoe_arp_clr(&dhd->pub, idx);\n#endif /* AOE_IP_ALIAS_SUPPORT */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tDHD_ARPOE((\"%s: do noting for [%s] Event: %lu\\n\",\n\t\t\t\t__func__, ifa->ifa_label, event));\n\t\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n#endif /* ARP_OFFLOAD_SUPPORT */\n\n#ifdef CONFIG_IPV6\n/* Neighbor Discovery Offload: defered handler */\nstatic void\ndhd_inet6_work_handler(void *dhd_info, void *event_data, u8 event)\n{\n\tstruct ipv6_work_info_t *ndo_work = (struct ipv6_work_info_t *)event_data;\n\tdhd_pub_t\t*pub = &((dhd_info_t *)dhd_info)->pub;\n\tint\t\tret;\n\n\tif (event != DHD_WQ_WORK_IPV6_NDO) {\n\t\tDHD_ERROR((\"%s: unexpected event \\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tif (!ndo_work) {\n\t\tDHD_ERROR((\"%s: ipv6 work info is not initialized \\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tif (!pub) {\n\t\tDHD_ERROR((\"%s: dhd pub is not initialized \\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tif (ndo_work->if_idx) {\n\t\tDHD_ERROR((\"%s: idx %d \\n\", __FUNCTION__, ndo_work->if_idx));\n\t\treturn;\n\t}\n\n\tswitch (ndo_work->event) {\n\t\tcase NETDEV_UP:\n\t\t\tDHD_TRACE((\"%s: Enable NDO and add ipv6 into table \\n\", __FUNCTION__));\n\t\t\tret = dhd_ndo_enable(pub, TRUE);\n\t\t\tif (ret < 0) {\n\t\t\t\tDHD_ERROR((\"%s: Enabling NDO Failed %d\\n\", __FUNCTION__, ret));\n\t\t\t}\n\n\t\t\tret = dhd_ndo_add_ip(pub, &ndo_work->ipv6_addr[0], ndo_work->if_idx);\n\t\t\tif (ret < 0) {\n\t\t\t\tDHD_ERROR((\"%s: Adding host ip for NDO failed %d\\n\",\n\t\t\t\t\t__FUNCTION__, ret));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NETDEV_DOWN:\n\t\t\tDHD_TRACE((\"%s: clear ipv6 table \\n\", __FUNCTION__));\n\t\t\tret = dhd_ndo_remove_ip(pub, ndo_work->if_idx);\n\t\t\tif (ret < 0) {\n\t\t\t\tDHD_ERROR((\"%s: Removing host ip for NDO failed %d\\n\",\n\t\t\t\t\t__FUNCTION__, ret));\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tret = dhd_ndo_enable(pub, FALSE);\n\t\t\tif (ret < 0) {\n\t\t\t\tDHD_ERROR((\"%s: disabling NDO Failed %d\\n\", __FUNCTION__, ret));\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDHD_ERROR((\"%s: unknown notifier event \\n\", __FUNCTION__));\n\t\t\tbreak;\n\t}\ndone:\n\t/* free ndo_work. alloced while scheduling the work */\n\tkfree(ndo_work);\n\n\treturn;\n}\n\n/*\n * Neighbor Discovery Offload: Called when an interface\n * is assigned with ipv6 address.\n * Handles only primary interface\n */\nstatic int dhd_inet6addr_notifier_call(struct notifier_block *this,\n\tunsigned long event,\n\tvoid *ptr)\n{\n\tdhd_info_t *dhd;\n\tdhd_pub_t *dhd_pub;\n\tstruct inet6_ifaddr *inet6_ifa = ptr;\n\tstruct in6_addr *ipv6_addr = &inet6_ifa->addr;\n\tstruct ipv6_work_info_t *ndo_info;\n\tint idx = 0; /* REVISIT */\n\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 31))\n\t/* Filter notifications meant for non Broadcom devices */\n\tif (inet6_ifa->idev->dev->netdev_ops != &dhd_ops_pri) {\n\t\t\treturn NOTIFY_DONE;\n\t}\n#endif /* LINUX_VERSION_CODE */\n\n\tdhd = DHD_DEV_INFO(inet6_ifa->idev->dev);\n\tif (!dhd)\n\t\treturn NOTIFY_DONE;\n\n\tif (dhd->iflist[idx] && dhd->iflist[idx]->net != inet6_ifa->idev->dev)\n\t\treturn NOTIFY_DONE;\n\tdhd_pub = &dhd->pub;\n\tif (!FW_SUPPORTED(dhd_pub, ndoe))\n\t\treturn NOTIFY_DONE;\n\n\tndo_info = (struct ipv6_work_info_t *)kzalloc(sizeof(struct ipv6_work_info_t), GFP_ATOMIC);\n\tif (!ndo_info) {\n\t\tDHD_ERROR((\"%s: ipv6 work alloc failed\\n\", __FUNCTION__));\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tndo_info->event = event;\n\tndo_info->if_idx = idx;\n\tmemcpy(&ndo_info->ipv6_addr[0], ipv6_addr, IPV6_ADDR_LEN);\n\n\t/* defer the work to thread as it may block kernel */\n\tdhd_deferred_schedule_work(dhd->dhd_deferred_wq, (void *)ndo_info, DHD_WQ_WORK_IPV6_NDO,\n\t\tdhd_inet6_work_handler, DHD_WORK_PRIORITY_LOW);\n\treturn NOTIFY_DONE;\n}\n#endif /* #ifdef CONFIG_IPV6 */\n\nint\ndhd_register_if(dhd_pub_t *dhdp, int ifidx, bool need_rtnl_lock)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)dhdp->info;\n\tdhd_if_t *ifp;\n\tstruct net_device *net = NULL;\n\tint err = 0;\n\tuint8 temp_addr[ETHER_ADDR_LEN] = { 0x00, 0x90, 0x4c, 0x11, 0x22, 0x33 };\n\n\tDHD_TRACE((\"%s: ifidx %d\\n\", __FUNCTION__, ifidx));\n\n\tASSERT(dhd && dhd->iflist[ifidx]);\n\tifp = dhd->iflist[ifidx];\n\tnet = ifp->net;\n\tASSERT(net && (ifp->idx == ifidx));\n\n#ifndef  P2PONEINT\n#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31))\n\tASSERT(!net->open);\n\tnet->get_stats = dhd_get_stats;\n\tnet->do_ioctl = dhd_ioctl_entry;\n\tnet->hard_start_xmit = dhd_start_xmit;\n\tnet->set_mac_address = dhd_set_mac_address;\n\tnet->set_multicast_list = dhd_set_multicast_list;\n\tnet->open = net->stop = NULL;\n#else\n\tASSERT(!net->netdev_ops);\n\tnet->netdev_ops = &dhd_ops_virt;\n#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31) */\n#else\n\tnet->netdev_ops = &dhd_cfgp2p_ops_virt;\n#endif /* P2PONEINT */\n\n\t/* Ok, link into the network layer... */\n\tif (ifidx == 0) {\n\t\t/*\n\t\t * device functions for the primary interface only\n\t\t */\n#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31))\n\t\tnet->open = dhd_open;\n\t\tnet->stop = dhd_stop;\n#else\n\t\tnet->netdev_ops = &dhd_ops_pri;\n#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31) */\n\t\tif (!ETHER_ISNULLADDR(dhd->pub.mac.octet))\n\t\t\tmemcpy(temp_addr, dhd->pub.mac.octet, ETHER_ADDR_LEN);\n\t} else {\n\t\t/*\n\t\t * We have to use the primary MAC for virtual interfaces\n\t\t */\n\t\tmemcpy(temp_addr, ifp->mac_addr, ETHER_ADDR_LEN);\n\t\t/*\n\t\t * Android sets the locally administered bit to indicate that this is a\n\t\t * portable hotspot.  This will not work in simultaneous AP/STA mode,\n\t\t * nor with P2P.  Need to set the Donlge's MAC address, and then use that.\n\t\t */\n\t\tif (!memcmp(temp_addr, dhd->iflist[0]->mac_addr,\n\t\t\tETHER_ADDR_LEN)) {\n\t\t\tDHD_ERROR((\"%s interface [%s]: set locally administered bit in MAC\\n\",\n\t\t\t__func__, net->name));\n\t\t\ttemp_addr[0] |= 0x02;\n\t\t}\n\t}\n\n\tnet->hard_header_len = ETH_HLEN + dhd->pub.hdrlen;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)\n\tnet->ethtool_ops = &dhd_ethtool_ops;\n#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24) */\n\n#if defined(WL_WIRELESS_EXT)\n#if WIRELESS_EXT < 19\n\tnet->get_wireless_stats = dhd_get_wireless_stats;\n#endif /* WIRELESS_EXT < 19 */\n#if WIRELESS_EXT > 12\n\tnet->wireless_handlers = (struct iw_handler_def *)&wl_iw_handler_def;\n#endif /* WIRELESS_EXT > 12 */\n#endif /* defined(WL_WIRELESS_EXT) */\n\n\tdhd->pub.rxsz = DBUS_RX_BUFFER_SIZE_DHD(net);\n\n\tmemcpy(net->dev_addr, temp_addr, ETHER_ADDR_LEN);\n\n\tif (ifidx == 0)\n\t\tprintf(\"%s\\n\", dhd_version);\n#ifdef WL_EXT_APSTA\n\telse if (!strncmp(net->name, \"wl0.\", strlen(\"wl0.\"))) {\n\t\twl_android_ext_attach_netdev(net, ifidx);\n\t}\n#endif\n\n\tif (need_rtnl_lock)\n\t\terr = register_netdev(net);\n\telse\n\t\terr = register_netdevice(net);\n\n\tif (err != 0) {\n\t\tDHD_ERROR((\"couldn't register the net device [%s], err %d\\n\", net->name, err));\n\t\tgoto fail;\n\t}\n\n#ifdef SET_RPS_CPUS\n\terr = custom_rps_map_set(net->_rx, RPS_CPUS_MASK, strlen(RPS_CPUS_MASK));\n\tif (err < 0)\n\t\tDHD_ERROR((\"%s : custom_rps_map_set done. error : %d\\n\", __FUNCTION__, err));\n#endif /* SET_RPS_CPUS */\n\n\n\n\tprintf(\"Register interface [%s]  MAC: \"MACDBG\"\\n\\n\", net->name,\n\t\tMAC2STRDBG(net->dev_addr));\n\n#if defined(SOFTAP) && defined(WL_WIRELESS_EXT) && !defined(WL_CFG80211)\n//\t\twl_iw_iscan_set_scan_broadcast_prep(net, 1);\n#endif\n\n#if 1 && (defined(BCMPCIE) || (defined(BCMLXSDMMC) && (LINUX_VERSION_CODE >= \\\n\tKERNEL_VERSION(2, 6, 27))))\n\tif (ifidx == 0) {\n#if defined(BCMLXSDMMC) && !defined(DHD_PRELOAD)\n\t\tup(&dhd_registration_sem);\n#endif\n\t\tif (!dhd_download_fw_on_driverload) {\n\t\t\tdhd_net_bus_devreset(net, TRUE);\n#ifdef BCMLXSDMMC\n\t\t\tdhd_net_bus_suspend(net);\n#endif /* BCMLXSDMMC */\n\t\t\twifi_platform_set_power(dhdp->info->adapter, FALSE, WIFI_TURNOFF_DELAY);\n\t\t}\n\t}\n#endif /* OEM_ANDROID && (BCMPCIE || (BCMLXSDMMC && KERNEL_VERSION >= 2.6.27)) */\n\treturn 0;\n\nfail:\n#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)\n\tnet->open = NULL;\n#else\n\tnet->netdev_ops = NULL;\n#endif\n\treturn err;\n}\n\nvoid\ndhd_bus_detach(dhd_pub_t *dhdp)\n{\n\tdhd_info_t *dhd;\n\n\tDHD_TRACE((\"%s: Enter\\n\", __FUNCTION__));\n\n\tif (dhdp) {\n\t\tdhd = (dhd_info_t *)dhdp->info;\n\t\tif (dhd) {\n\n\t\t\t/*\n\t\t\t * In case of Android cfg80211 driver, the bus is down in dhd_stop,\n\t\t\t *  calling stop again will cuase SD read/write errors.\n\t\t\t */\n\t\t\tif (dhd->pub.busstate != DHD_BUS_DOWN) {\n\t\t\t\t/* Stop the protocol module */\n\t\t\t\tdhd_prot_stop(&dhd->pub);\n\n\t\t\t\t/* Stop the bus module */\n\t\t\t\tdhd_bus_stop(dhd->pub.bus, TRUE);\n\t\t\t}\n\n#if defined(OOB_INTR_ONLY) || defined(BCMPCIE_OOB_HOST_WAKE)\n\t\t\tdhd_bus_oob_intr_unregister(dhdp);\n#endif \n\t\t}\n\t}\n}\n\n\nvoid dhd_detach(dhd_pub_t *dhdp)\n{\n\tdhd_info_t *dhd;\n\tunsigned long flags;\n\tint timer_valid = FALSE;\n\n\tif (!dhdp)\n\t\treturn;\n\n\tdhd = (dhd_info_t *)dhdp->info;\n\tif (!dhd)\n\t\treturn;\n\n#if defined(CUSTOMER_HW20) && defined(WLANAUDIO)\n\tdhd_global = NULL;\n#endif /* CUSTOMER_HW20 && WLANAUDIO */\n\n\tDHD_TRACE((\"%s: Enter state 0x%x\\n\", __FUNCTION__, dhd->dhd_state));\n\n\tdhd->pub.up = 0;\n\tif (!(dhd->dhd_state & DHD_ATTACH_STATE_DONE)) {\n\t\t/* Give sufficient time for threads to start running in case\n\t\t * dhd_attach() has failed\n\t\t */\n\t\tOSL_SLEEP(100);\n\t}\n\n\tif (dhd->dhd_state & DHD_ATTACH_STATE_PROT_ATTACH) {\n\t\tdhd_bus_detach(dhdp);\n#ifdef PCIE_FULL_DONGLE\n\t\tdhd_flow_rings_deinit(dhdp);\n#endif\n\n\t\tif (dhdp->prot)\n\t\t\tdhd_prot_detach(dhdp);\n\t}\n\n#ifdef ARP_OFFLOAD_SUPPORT\n\tif (dhd_inetaddr_notifier_registered) {\n\t\tdhd_inetaddr_notifier_registered = FALSE;\n\t\tunregister_inetaddr_notifier(&dhd_inetaddr_notifier);\n\t}\n#endif /* ARP_OFFLOAD_SUPPORT */\n#ifdef CONFIG_IPV6\n\tif (dhd_inet6addr_notifier_registered) {\n\t\tdhd_inet6addr_notifier_registered = FALSE;\n\t\tunregister_inet6addr_notifier(&dhd_inet6addr_notifier);\n\t}\n#endif\n\n#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)\n\tif (dhd->dhd_state & DHD_ATTACH_STATE_EARLYSUSPEND_DONE) {\n\t\tif (dhd->early_suspend.suspend)\n\t\t\tunregister_early_suspend(&dhd->early_suspend);\n\t}\n#endif /* CONFIG_HAS_EARLYSUSPEND && DHD_USE_EARLYSUSPEND */\n\n#if defined(WL_WIRELESS_EXT)\n\tif (dhd->dhd_state & DHD_ATTACH_STATE_WL_ATTACH) {\n\t\t/* Detatch and unlink in the iw */\n\t\twl_iw_detach();\n\t}\n#ifdef WL_ESCAN\n\twl_escan_detach();\n#endif\n#endif /* defined(WL_WIRELESS_EXT) */\n\n\t/* delete all interfaces, start with virtual  */\n\tif (dhd->dhd_state & DHD_ATTACH_STATE_ADD_IF) {\n\t\tint i = 1;\n\t\tdhd_if_t *ifp;\n\n\t\t/* Cleanup virtual interfaces */\n\t\tdhd_net_if_lock_local(dhd);\n\t\tfor (i = 1; i < DHD_MAX_IFS; i++) {\n\t\t\tif (dhd->iflist[i])\n\t\t\t\tdhd_remove_if(&dhd->pub, i, TRUE);\n\t\t}\n\t\tdhd_net_if_unlock_local(dhd);\n\n\t\t/*  delete primary interface 0 */\n\t\tifp = dhd->iflist[0];\n\t\tASSERT(ifp);\n\t\tASSERT(ifp->net);\n\t\tif (ifp && ifp->net) {\n\n\n\n\t\t\t/* in unregister_netdev case, the interface gets freed by net->destructor\n\t\t\t * (which is set to free_netdev)\n\t\t\t */\n\t\t\tif (ifp->net->reg_state == NETREG_UNINITIALIZED)\n\t\t\t\tfree_netdev(ifp->net);\n\t\t\telse {\n#ifdef SET_RPS_CPUS\n\t\t\t\tcustom_rps_map_clear(ifp->net->_rx);\n#endif /* SET_RPS_CPUS */\n\t\t\t\tunregister_netdev(ifp->net);\n\t\t\t}\n\t\t\tifp->net = NULL;\n#ifdef DHD_WMF\n\t\t\tdhd_wmf_cleanup(dhdp, 0);\n#endif /* DHD_WMF */\n\n\t\t\tdhd_if_del_sta_list(ifp);\n\n\t\t\tMFREE(dhd->pub.osh, ifp, sizeof(*ifp));\n\t\t\tdhd->iflist[0] = NULL;\n\t\t}\n\t}\n\n\t/* Clear the watchdog timer */\n\tDHD_GENERAL_LOCK(&dhd->pub, flags);\n\ttimer_valid = dhd->wd_timer_valid;\n\tdhd->wd_timer_valid = FALSE;\n\tDHD_GENERAL_UNLOCK(&dhd->pub, flags);\n\tif (timer_valid)\n\t\tdel_timer_sync(&dhd->timer);\n\n\tif (dhd->dhd_state & DHD_ATTACH_STATE_THREADS_CREATED) {\n\t\tif (dhd->thr_wdt_ctl.thr_pid >= 0) {\n\t\t\tPROC_STOP(&dhd->thr_wdt_ctl);\n\t\t}\n\n\t\tif (dhd->rxthread_enabled && dhd->thr_rxf_ctl.thr_pid >= 0) {\n\t\t\tPROC_STOP(&dhd->thr_rxf_ctl);\n\t\t}\n\n\t\tif (dhd->thr_dpc_ctl.thr_pid >= 0) {\n\t\t\tPROC_STOP(&dhd->thr_dpc_ctl);\n\t\t} else\n\t\t\ttasklet_kill(&dhd->tasklet);\n\t}\n#ifdef WL_CFG80211\n\tif (dhd->dhd_state & DHD_ATTACH_STATE_CFG80211) {\n\t\twl_cfg80211_detach(NULL);\n\t\tdhd_monitor_uninit();\n\t}\n#endif\n\t/* free deferred work queue */\n\tdhd_deferred_work_deinit(dhd->dhd_deferred_wq);\n\tdhd->dhd_deferred_wq = NULL;\n\n#ifdef SHOW_LOGTRACE\n\tif (dhd->event_data.fmts)\n\t\tkfree(dhd->event_data.fmts);\n\tif (dhd->event_data.raw_fmts)\n\t\tkfree(dhd->event_data.raw_fmts);\n#endif /* SHOW_LOGTRACE */\n\n#ifdef PNO_SUPPORT\n\tif (dhdp->pno_state)\n\t\tdhd_pno_deinit(dhdp);\n#endif\n#if defined(CONFIG_PM_SLEEP)\n\tif (dhd_pm_notifier_registered) {\n\t\tunregister_pm_notifier(&dhd_pm_notifier);\n\t\tdhd_pm_notifier_registered = FALSE;\n\t}\n#endif /* CONFIG_PM_SLEEP */\n#ifdef DEBUG_CPU_FREQ\n\t\tif (dhd->new_freq)\n\t\t\tfree_percpu(dhd->new_freq);\n\t\tdhd->new_freq = NULL;\n\t\tcpufreq_unregister_notifier(&dhd->freq_trans, CPUFREQ_TRANSITION_NOTIFIER);\n#endif\n\tif (dhd->dhd_state & DHD_ATTACH_STATE_WAKELOCKS_INIT) {\n\t\tDHD_TRACE((\"wd wakelock count:%d\\n\", dhd->wakelock_wd_counter));\n#ifdef CONFIG_HAS_WAKELOCK\n\t\tdhd->wakelock_counter = 0;\n\t\tdhd->wakelock_wd_counter = 0;\n\t\tdhd->wakelock_rx_timeout_enable = 0;\n\t\tdhd->wakelock_ctrl_timeout_enable = 0;\n\t\twake_lock_destroy(&dhd->wl_wifi);\n\t\twake_lock_destroy(&dhd->wl_rxwake);\n\t\twake_lock_destroy(&dhd->wl_ctrlwake);\n\t\twake_lock_destroy(&dhd->wl_wdwake);\n#ifdef BCMPCIE_OOB_HOST_WAKE\n\t\twake_lock_destroy(&dhd->wl_intrwake);\n#endif /* BCMPCIE_OOB_HOST_WAKE */\n#endif /* CONFIG_HAS_WAKELOCK */\n\t}\n\n\n\n\n#ifdef DHDTCPACK_SUPPRESS\n\t/* This will free all MEM allocated for TCPACK SUPPRESS */\n\tdhd_tcpack_suppress_set(&dhd->pub, TCPACK_SUP_OFF);\n#endif /* DHDTCPACK_SUPPRESS */\n\tdhd_conf_detach(dhdp);\n}\n\n\nvoid\ndhd_free(dhd_pub_t *dhdp)\n{\n\tdhd_info_t *dhd;\n\tDHD_TRACE((\"%s: Enter\\n\", __FUNCTION__));\n\n\tif (dhdp) {\n\t\tint i;\n\t\tfor (i = 0; i < ARRAYSIZE(dhdp->reorder_bufs); i++) {\n\t\t\tif (dhdp->reorder_bufs[i]) {\n\t\t\t\treorder_info_t *ptr;\n\t\t\t\tuint32 buf_size = sizeof(struct reorder_info);\n\n\t\t\t\tptr = dhdp->reorder_bufs[i];\n\n\t\t\t\tbuf_size += ((ptr->max_idx + 1) * sizeof(void*));\n\t\t\t\tDHD_REORDER((\"free flow id buf %d, maxidx is %d, buf_size %d\\n\",\n\t\t\t\t\ti, ptr->max_idx, buf_size));\n\n\t\t\t\tMFREE(dhdp->osh, dhdp->reorder_bufs[i], buf_size);\n\t\t\t\tdhdp->reorder_bufs[i] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tdhd_sta_pool_fini(dhdp, DHD_MAX_STA);\n\n\t\tdhd = (dhd_info_t *)dhdp->info;\n\t\t/* If pointer is allocated by dhd_os_prealloc then avoid MFREE */\n\t\tif (dhd &&\n\t\t\tdhd != (dhd_info_t *)dhd_os_prealloc(dhdp, DHD_PREALLOC_DHD_INFO, 0, FALSE))\n\t\t\tMFREE(dhd->pub.osh, dhd, sizeof(*dhd));\n\t\tdhd = NULL;\n\t}\n}\n\nvoid\ndhd_clear(dhd_pub_t *dhdp)\n{\n\tDHD_TRACE((\"%s: Enter\\n\", __FUNCTION__));\n\n\tif (dhdp) {\n\t\tint i;\n\t\tfor (i = 0; i < ARRAYSIZE(dhdp->reorder_bufs); i++) {\n\t\t\tif (dhdp->reorder_bufs[i]) {\n\t\t\t\treorder_info_t *ptr;\n\t\t\t\tuint32 buf_size = sizeof(struct reorder_info);\n\n\t\t\t\tptr = dhdp->reorder_bufs[i];\n\n\t\t\t\tbuf_size += ((ptr->max_idx + 1) * sizeof(void*));\n\t\t\t\tDHD_REORDER((\"free flow id buf %d, maxidx is %d, buf_size %d\\n\",\n\t\t\t\t\ti, ptr->max_idx, buf_size));\n\n\t\t\t\tMFREE(dhdp->osh, dhdp->reorder_bufs[i], buf_size);\n\t\t\t\tdhdp->reorder_bufs[i] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tdhd_sta_pool_clear(dhdp, DHD_MAX_STA);\n\t}\n}\n\nstatic void\ndhd_module_cleanup(void)\n{\n\tprintf(\"%s: Enter\\n\", __FUNCTION__);\n\n\tdhd_bus_unregister();\n\n\twl_android_exit();\n\n\tdhd_wifi_platform_unregister_drv();\n\tprintf(\"%s: Exit\\n\", __FUNCTION__);\n}\n\nstatic void __exit\ndhd_module_exit(void)\n{\n\tdhd_module_cleanup();\n\tunregister_reboot_notifier(&dhd_reboot_notifier);\n}\n\nstatic int __init\ndhd_module_init(void)\n{\n\tint err;\n\tint retry = POWERUP_MAX_RETRY;\n\n\tprintf(\"%s: in\\n\", __FUNCTION__);\n\n\tDHD_PERIM_RADIO_INIT();\n\n\tif (firmware_path[0] != '\\0') {\n\t\tstrncpy(fw_bak_path, firmware_path, MOD_PARAM_PATHLEN);\n\t\tfw_bak_path[MOD_PARAM_PATHLEN-1] = '\\0';\n\t}\n\n\tif (nvram_path[0] != '\\0') {\n\t\tstrncpy(nv_bak_path, nvram_path, MOD_PARAM_PATHLEN);\n\t\tnv_bak_path[MOD_PARAM_PATHLEN-1] = '\\0';\n\t}\n\n\tdo {\n\t\terr = dhd_wifi_platform_register_drv();\n\t\tif (!err) {\n\t\t\tregister_reboot_notifier(&dhd_reboot_notifier);\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tDHD_ERROR((\"%s: Failed to load the driver, try cnt %d\\n\",\n\t\t\t\t__FUNCTION__, retry));\n\t\t\tstrncpy(firmware_path, fw_bak_path, MOD_PARAM_PATHLEN);\n\t\t\tfirmware_path[MOD_PARAM_PATHLEN-1] = '\\0';\n\t\t\tstrncpy(nvram_path, nv_bak_path, MOD_PARAM_PATHLEN);\n\t\t\tnvram_path[MOD_PARAM_PATHLEN-1] = '\\0';\n\t\t}\n\t} while (retry--);\n\n\tif (err)\n\t\tDHD_ERROR((\"%s: Failed to load driver max retry reached**\\n\", __FUNCTION__));\n\n\tprintf(\"%s: Exit err=%d\\n\", __FUNCTION__, err);\n\treturn err;\n}\n\nstatic int\ndhd_reboot_callback(struct notifier_block *this, unsigned long code, void *unused)\n{\n\tDHD_TRACE((\"%s: code = %ld\\n\", __FUNCTION__, code));\n\tif (code == SYS_RESTART) {\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)\n#if defined(CONFIG_DEFERRED_INITCALLS)\ndeferred_module_init(dhd_module_init);\n#elif defined(USE_LATE_INITCALL_SYNC)\nlate_initcall_sync(dhd_module_init);\n#else\nlate_initcall(dhd_module_init);\n#endif /* USE_LATE_INITCALL_SYNC */\n#else\nmodule_init(dhd_module_init);\n#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0) */\n\nmodule_exit(dhd_module_exit);\n\n/*\n * OS specific functions required to implement DHD driver in OS independent way\n */\nint\ndhd_os_proto_block(dhd_pub_t *pub)\n{\n\tdhd_info_t * dhd = (dhd_info_t *)(pub->info);\n\n\tif (dhd) {\n\t\tDHD_PERIM_UNLOCK(pub);\n\n\t\tdown(&dhd->proto_sem);\n\n\t\tDHD_PERIM_LOCK(pub);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint\ndhd_os_proto_unblock(dhd_pub_t *pub)\n{\n\tdhd_info_t * dhd = (dhd_info_t *)(pub->info);\n\n\tif (dhd) {\n\t\tup(&dhd->proto_sem);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nunsigned int\ndhd_os_get_ioctl_resp_timeout(void)\n{\n\treturn ((unsigned int)dhd_ioctl_timeout_msec);\n}\n\nvoid\ndhd_os_set_ioctl_resp_timeout(unsigned int timeout_msec)\n{\n\tdhd_ioctl_timeout_msec = (int)timeout_msec;\n}\n\nint\ndhd_os_ioctl_resp_wait(dhd_pub_t *pub, uint *condition, bool *pending)\n{\n\tdhd_info_t * dhd = (dhd_info_t *)(pub->info);\n\tint timeout;\n\n\t/* Convert timeout in millsecond to jiffies */\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))\n\ttimeout = msecs_to_jiffies(dhd_ioctl_timeout_msec);\n#else\n\ttimeout = dhd_ioctl_timeout_msec * HZ / 1000;\n#endif\n\n\tDHD_PERIM_UNLOCK(pub);\n\n\ttimeout = wait_event_timeout(dhd->ioctl_resp_wait, (*condition), timeout);\n\n\tDHD_PERIM_LOCK(pub);\n\n\treturn timeout;\n}\n\nint\ndhd_os_ioctl_resp_wake(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\n\twake_up(&dhd->ioctl_resp_wait);\n\treturn 0;\n}\n\nvoid\ndhd_os_wd_timer_extend(void *bus, bool extend)\n{\n\tdhd_pub_t *pub = bus;\n\tdhd_info_t *dhd = (dhd_info_t *)pub->info;\n\n\tif (extend)\n\t\tdhd_os_wd_timer(bus, WATCHDOG_EXTEND_INTERVAL);\n\telse\n\t\tdhd_os_wd_timer(bus, dhd->default_wd_interval);\n}\n\n\nvoid\ndhd_os_wd_timer(void *bus, uint wdtick)\n{\n\tdhd_pub_t *pub = bus;\n\tdhd_info_t *dhd = (dhd_info_t *)pub->info;\n\tunsigned long flags;\n\n\tDHD_TRACE((\"%s: Enter\\n\", __FUNCTION__));\n\n\tif (!dhd) {\n\t\tDHD_ERROR((\"%s: dhd NULL\\n\", __FUNCTION__));\n\t\treturn;\n\t}\n\n\tDHD_GENERAL_LOCK(pub, flags);\n\n\t/* don't start the wd until fw is loaded */\n\tif (pub->busstate == DHD_BUS_DOWN) {\n\t\tDHD_GENERAL_UNLOCK(pub, flags);\n\t\tif (!wdtick)\n\t\t\tDHD_OS_WD_WAKE_UNLOCK(pub);\n\t\treturn;\n\t}\n\n\t/* Totally stop the timer */\n\tif (!wdtick && dhd->wd_timer_valid == TRUE) {\n\t\tdhd->wd_timer_valid = FALSE;\n\t\tDHD_GENERAL_UNLOCK(pub, flags);\n\t\tdel_timer_sync(&dhd->timer);\n\t\tDHD_OS_WD_WAKE_UNLOCK(pub);\n\t\treturn;\n\t}\n\n\tif (wdtick) {\n\t\tDHD_OS_WD_WAKE_LOCK(pub);\n\t\tdhd_watchdog_ms = (uint)wdtick;\n\t\t/* Re arm the timer, at last watchdog period */\n\t\tmod_timer(&dhd->timer, jiffies + msecs_to_jiffies(dhd_watchdog_ms));\n\t\tdhd->wd_timer_valid = TRUE;\n\t}\n\tDHD_GENERAL_UNLOCK(pub, flags);\n}\n\nvoid *\ndhd_os_open_image(char *filename)\n{\n\tstruct file *fp;\n\n\tfp = filp_open(filename, O_RDONLY, 0);\n\t/*\n\t * 2.6.11 (FC4) supports filp_open() but later revs don't?\n\t * Alternative:\n\t * fp = open_namei(AT_FDCWD, filename, O_RD, 0);\n\t * ???\n\t */\n\t if (IS_ERR(fp))\n\t\t fp = NULL;\n\n\t return fp;\n}\n\nint\ndhd_os_get_image_block(char *buf, int len, void *image)\n{\n\tstruct file *fp = (struct file *)image;\n\tint rdlen;\n\n\tif (!image)\n\t\treturn 0;\n\n\trdlen = kernel_read(fp, fp->f_pos, buf, len);\n\tif (rdlen > 0)\n\t\tfp->f_pos += rdlen;\n\n\treturn rdlen;\n}\n\nvoid\ndhd_os_close_image(void *image)\n{\n\tif (image)\n\t\tfilp_close((struct file *)image, NULL);\n}\n\nvoid\ndhd_os_sdlock(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd;\n\n\tdhd = (dhd_info_t *)(pub->info);\n\n\tif (dhd_dpc_prio >= 0)\n\t\tdown(&dhd->sdsem);\n\telse\n\t\tspin_lock_bh(&dhd->sdlock);\n}\n\nvoid\ndhd_os_sdunlock(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd;\n\n\tdhd = (dhd_info_t *)(pub->info);\n\n\tif (dhd_dpc_prio >= 0)\n\t\tup(&dhd->sdsem);\n\telse\n\t\tspin_unlock_bh(&dhd->sdlock);\n}\n\nvoid\ndhd_os_sdlock_txq(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd;\n\n\tdhd = (dhd_info_t *)(pub->info);\n\tspin_lock_bh(&dhd->txqlock);\n}\n\nvoid\ndhd_os_sdunlock_txq(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd;\n\n\tdhd = (dhd_info_t *)(pub->info);\n\tspin_unlock_bh(&dhd->txqlock);\n}\n\nvoid\ndhd_os_sdlock_rxq(dhd_pub_t *pub)\n{\n}\n\nvoid\ndhd_os_sdunlock_rxq(dhd_pub_t *pub)\n{\n}\n\nstatic void\ndhd_os_rxflock(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd;\n\n\tdhd = (dhd_info_t *)(pub->info);\n\tspin_lock_bh(&dhd->rxf_lock);\n\n}\n\nstatic void\ndhd_os_rxfunlock(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd;\n\n\tdhd = (dhd_info_t *)(pub->info);\n\tspin_unlock_bh(&dhd->rxf_lock);\n}\n\n#ifdef DHDTCPACK_SUPPRESS\nvoid\ndhd_os_tcpacklock(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd;\n\n\tdhd = (dhd_info_t *)(pub->info);\n\tspin_lock_bh(&dhd->tcpack_lock);\n\n}\n\nvoid\ndhd_os_tcpackunlock(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd;\n\n\tdhd = (dhd_info_t *)(pub->info);\n\tspin_unlock_bh(&dhd->tcpack_lock);\n}\n#endif /* DHDTCPACK_SUPPRESS */\n\nuint8* dhd_os_prealloc(dhd_pub_t *dhdpub, int section, uint size, bool kmalloc_if_fail)\n{\n\tuint8* buf;\n\tgfp_t flags = CAN_SLEEP() ? GFP_KERNEL: GFP_ATOMIC;\n\n\tbuf = (uint8*)wifi_platform_prealloc(dhdpub->info->adapter, section, size);\n\tif (buf == NULL) {\n\t\tDHD_ERROR((\"%s: failed to alloc memory, section: %d,\"\n\t\t\t\" size: %dbytes\\n\", __FUNCTION__, section, size));\n\t\tif (kmalloc_if_fail)\n\t\t\tbuf = kmalloc(size, flags);\n\t}\n\n\treturn buf;\n}\n\nvoid dhd_os_prefree(dhd_pub_t *dhdpub, void *addr, uint size)\n{\n}\n\n#if defined(WL_WIRELESS_EXT)\nstruct iw_statistics *\ndhd_get_wireless_stats(struct net_device *dev)\n{\n\tint res = 0;\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\n\tif (!dhd->pub.up) {\n\t\treturn NULL;\n\t}\n\n\tres = wl_iw_get_wireless_stats(dev, &dhd->iw.wstats);\n\n\tif (res == 0)\n\t\treturn &dhd->iw.wstats;\n\telse\n\t\treturn NULL;\n}\n#endif /* defined(WL_WIRELESS_EXT) */\n\n#if defined(CUSTOMER_HW20) && defined(WLANAUDIO)\nstatic int\ndhd_wlanaudio_event(dhd_info_t *dhd, int *ifidx, void *pktdata,\n                    wl_event_msg_t *event, void **data)\n{\n\tint cnt;\n\tchar eabuf[ETHER_ADDR_STR_LEN];\n\tstruct ether_addr *addr = &event->addr;\n\tuint32 type = ntoh32_ua((void *)&event->event_type);\n\n\tswitch (type) {\n\tcase WLC_E_TXFAIL:\n\t\tif (addr != NULL)\n\t\t\tbcm_ether_ntoa(addr, eabuf);\n\t\telse\n\t\t\treturn (BCME_ERROR);\n\n\t\tfor (cnt = 0; cnt < MAX_WLANAUDIO_BLACKLIST; cnt++) {\n\t\t\tif (dhd->wlanaudio_blist[cnt].is_blacklist)\n\t\t\t\tbreak;\n\n\t\t\tif (!bcmp(&dhd->wlanaudio_blist[cnt].blacklist_addr,\n\t\t\t          addr, ETHER_ADDR_LEN)) {\n\t\t\t\t/* Mac address is Same */\n\t\t\t\tdhd->wlanaudio_blist[cnt].cnt++;\n\n\t\t\t\tif (dhd->wlanaudio_blist[cnt].cnt < 15) {\n\t\t\t\t\t/* black list is false */\n\t\t\t\t\tif ((dhd->wlanaudio_blist[cnt].cnt > 10) &&\n\t\t\t\t\t    (jiffies - dhd->wlanaudio_blist[cnt].txfail_jiffies\n\t\t\t\t\t     < 100)) {\n\t\t\t\t\t\tdhd->wlanaudio_blist[cnt].is_blacklist = true;\n\t\t\t\t\t\tdhd->is_wlanaudio_blist = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((!dhd->wlanaudio_blist[cnt].is_blacklist) &&\n\t\t\t\t\t   (jiffies - dhd->wlanaudio_blist[cnt].txfail_jiffies\n\t\t\t\t\t    > 100)) {\n\n\t\t\t\t\t\tbzero(&dhd->wlanaudio_blist[cnt],\n\t\t\t\t\t\t      sizeof(struct wlanaudio_blacklist));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if ((!dhd->wlanaudio_blist[cnt].is_blacklist) &&\n\t\t\t           (!dhd->wlanaudio_blist[cnt].cnt)) {\n\t\t\t\tbcopy(addr,\n\t\t\t\t      (char*)&dhd->wlanaudio_blist[cnt].blacklist_addr,\n\t\t\t\t      ETHER_ADDR_LEN);\n\t\t\t\tdhd->wlanaudio_blist[cnt].cnt++;\n\t\t\t\tdhd->wlanaudio_blist[cnt].txfail_jiffies = jiffies;\n\n\t\t\t\tbcm_ether_ntoa(&dhd->wlanaudio_blist[cnt].blacklist_addr, eabuf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WLC_E_AUTH\t :\n\tcase WLC_E_AUTH_IND :\n\tcase WLC_E_DEAUTH :\n\tcase WLC_E_DEAUTH_IND :\n\tcase WLC_E_ASSOC:\n\tcase WLC_E_ASSOC_IND:\n\tcase WLC_E_REASSOC:\n\tcase WLC_E_REASSOC_IND:\n\tcase WLC_E_DISASSOC:\n\tcase WLC_E_DISASSOC_IND:\n\t\t{\n\t\t\tint bl_cnt = 0;\n\n\t\t\tif (addr != NULL)\n\t\t\t\tbcm_ether_ntoa(addr, eabuf);\n\t\t\telse\n\t\t\t\treturn (BCME_ERROR);\n\n\t\t\tfor (cnt = 0; cnt < MAX_WLANAUDIO_BLACKLIST; cnt++) {\n\t\t\t\tif (!bcmp(&dhd->wlanaudio_blist[cnt].blacklist_addr,\n\t\t\t\t          addr, ETHER_ADDR_LEN)) {\n\t\t\t\t\t/* Mac address is Same */\n\t\t\t\t\tif (dhd->wlanaudio_blist[cnt].is_blacklist) {\n\t\t\t\t\t\t/* black list is true */\n\t\t\t\t\t\tbzero(&dhd->wlanaudio_blist[cnt],\n\t\t\t\t\t\t      sizeof(struct wlanaudio_blacklist));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (cnt = 0; cnt < MAX_WLANAUDIO_BLACKLIST; cnt++) {\n\t\t\t\tif (dhd->wlanaudio_blist[cnt].is_blacklist)\n\t\t\t\t\tbl_cnt++;\n\t\t\t}\n\n\t\t\tif (!bl_cnt)\n\t\t\t{\n\t\t\t\tdhd->is_wlanaudio_blist = false;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn BCME_OK;\n}\n#endif /* CUSTOMER_HW20 && WLANAUDIO */\nstatic int\ndhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,\n\twl_event_msg_t *event, void **data)\n{\n\tint bcmerror = 0;\n\n\tASSERT(dhd != NULL);\n\n#if defined(CUSTOMER_HW20) && defined(WLANAUDIO)\n\tbcmerror = dhd_wlanaudio_event(dhd, ifidx, pktdata, event, data);\n\n\tif (bcmerror != BCME_OK)\n\t\treturn (bcmerror);\n#endif /* CUSTOMER_HW20 && WLANAUDIO */\n\n#ifdef SHOW_LOGTRACE\n\tbcmerror = wl_host_event(&dhd->pub, ifidx, pktdata, event, data, &dhd->event_data);\n#else\n\tbcmerror = wl_host_event(&dhd->pub, ifidx, pktdata, event, data, NULL);\n#endif /* SHOW_LOGTRACE */\n\n\tif (bcmerror != BCME_OK)\n\t\treturn (bcmerror);\n\n#if defined(WL_WIRELESS_EXT)\n\tif (event->bsscfgidx == 0) {\n\t\t/*\n\t\t * Wireless ext is on primary interface only\n\t\t */\n\n\tASSERT(dhd->iflist[*ifidx] != NULL);\n\tASSERT(dhd->iflist[*ifidx]->net != NULL);\n\n\t\tif (dhd->iflist[*ifidx]->net) {\n\t\twl_iw_event(dhd->iflist[*ifidx]->net, event, *data);\n\t\t}\n\t}\n#endif /* defined(WL_WIRELESS_EXT)  */\n\n#ifdef WL_CFG80211\n\tASSERT(dhd->iflist[*ifidx] != NULL);\n\tASSERT(dhd->iflist[*ifidx]->net != NULL);\n\tif (dhd->iflist[*ifidx]->net)\n\t\twl_cfg80211_event(dhd->iflist[*ifidx]->net, event, *data);\n#endif /* defined(WL_CFG80211) */\n\n\treturn (bcmerror);\n}\n\n/* send up locally generated event */\nvoid\ndhd_sendup_event(dhd_pub_t *dhdp, wl_event_msg_t *event, void *data)\n{\n\tswitch (ntoh32(event->event_type)) {\n#ifdef WLBTAMP\n\t/* Send up locally generated AMP HCI Events */\n\tcase WLC_E_BTA_HCI_EVENT: {\n\t\tstruct sk_buff *p, *skb;\n\t\tbcm_event_t *msg;\n\t\twl_event_msg_t *p_bcm_event;\n\t\tchar *ptr;\n\t\tuint32 len;\n\t\tuint32 pktlen;\n\t\tdhd_if_t *ifp;\n\t\tdhd_info_t *dhd;\n\t\tuchar *eth;\n\t\tint ifidx;\n\n\t\tlen = ntoh32(event->datalen);\n\t\tpktlen = sizeof(bcm_event_t) + len + 2;\n\t\tdhd = dhdp->info;\n\t\tifidx = dhd_ifname2idx(dhd, event->ifname);\n\n\t\tif ((p = PKTGET(dhdp->osh, pktlen, FALSE))) {\n\t\t\tASSERT(ISALIGNED((uintptr)PKTDATA(dhdp->osh, p), sizeof(uint32)));\n\n\t\t\tmsg = (bcm_event_t *) PKTDATA(dhdp->osh, p);\n\n\t\t\tbcopy(&dhdp->mac, &msg->eth.ether_dhost, ETHER_ADDR_LEN);\n\t\t\tbcopy(&dhdp->mac, &msg->eth.ether_shost, ETHER_ADDR_LEN);\n\t\t\tETHER_TOGGLE_LOCALADDR(&msg->eth.ether_shost);\n\n\t\t\tmsg->eth.ether_type = hton16(ETHER_TYPE_BRCM);\n\n\t\t\t/* BCM Vendor specific header... */\n\t\t\tmsg->bcm_hdr.subtype = hton16(BCMILCP_SUBTYPE_VENDOR_LONG);\n\t\t\tmsg->bcm_hdr.version = BCMILCP_BCM_SUBTYPEHDR_VERSION;\n\t\t\tbcopy(BRCM_OUI, &msg->bcm_hdr.oui[0], DOT11_OUI_LEN);\n\n\t\t\t/* vendor spec header length + pvt data length (private indication\n\t\t\t *  hdr + actual message itself)\n\t\t\t */\n\t\t\tmsg->bcm_hdr.length = hton16(BCMILCP_BCM_SUBTYPEHDR_MINLENGTH +\n\t\t\t\tBCM_MSG_LEN + sizeof(wl_event_msg_t) + (uint16)len);\n\t\t\tmsg->bcm_hdr.usr_subtype = hton16(BCMILCP_BCM_SUBTYPE_EVENT);\n\n\t\t\tPKTSETLEN(dhdp->osh, p, (sizeof(bcm_event_t) + len + 2));\n\n\t\t\t/* copy  wl_event_msg_t into sk_buf */\n\n\t\t\t/* pointer to wl_event_msg_t in sk_buf */\n\t\t\tp_bcm_event = &msg->event;\n\t\t\tbcopy(event, p_bcm_event, sizeof(wl_event_msg_t));\n\n\t\t\t/* copy hci event into sk_buf */\n\t\t\tbcopy(data, (p_bcm_event + 1), len);\n\n\t\t\tmsg->bcm_hdr.length  = hton16(sizeof(wl_event_msg_t) +\n\t\t\t\tntoh16(msg->bcm_hdr.length));\n\t\t\tPKTSETLEN(dhdp->osh, p, (sizeof(bcm_event_t) + len + 2));\n\n\t\t\tptr = (char *)(msg + 1);\n\t\t\t/* Last 2 bytes of the message are 0x00 0x00 to signal that there\n\t\t\t * are no ethertypes which are following this\n\t\t\t */\n\t\t\tptr[len+0] = 0x00;\n\t\t\tptr[len+1] = 0x00;\n\n\t\t\tskb = PKTTONATIVE(dhdp->osh, p);\n\t\t\teth = skb->data;\n\t\t\tlen = skb->len;\n\n\t\t\tifp = dhd->iflist[ifidx];\n\t\t\tif (ifp == NULL)\n\t\t\t     ifp = dhd->iflist[0];\n\n\t\t\tASSERT(ifp);\n\t\t\tskb->dev = ifp->net;\n\t\t\tskb->protocol = eth_type_trans(skb, skb->dev);\n\n\t\t\tskb->data = eth;\n\t\t\tskb->len = len;\n\n\t\t\t/* Strip header, count, deliver upward */\n\t\t\tskb_pull(skb, ETH_HLEN);\n\n\t\t\t/* Send the packet */\n\t\t\tif (in_interrupt()) {\n\t\t\t\tnetif_rx(skb);\n\t\t\t} else {\n\t\t\t\tnetif_rx_ni(skb);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* Could not allocate a sk_buf */\n\t\t\tDHD_ERROR((\"%s: unable to alloc sk_buf\\n\", __FUNCTION__));\n\t\t}\n\t\tbreak;\n\t} /* case WLC_E_BTA_HCI_EVENT */\n#endif /* WLBTAMP */\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#ifdef LOG_INTO_TCPDUMP\nvoid\ndhd_sendup_log(dhd_pub_t *dhdp, void *data, int data_len)\n{\n\tstruct sk_buff *p, *skb;\n\tuint32 pktlen;\n\tint len;\n\tdhd_if_t *ifp;\n\tdhd_info_t *dhd;\n\tuchar *skb_data;\n\tint ifidx = 0;\n\tstruct ether_header eth;\n\n\tpktlen = sizeof(eth) + data_len;\n\tdhd = dhdp->info;\n\n\tif ((p = PKTGET(dhdp->osh, pktlen, FALSE))) {\n\t\tASSERT(ISALIGNED((uintptr)PKTDATA(dhdp->osh, p), sizeof(uint32)));\n\n\t\tbcopy(&dhdp->mac, &eth.ether_dhost, ETHER_ADDR_LEN);\n\t\tbcopy(&dhdp->mac, &eth.ether_shost, ETHER_ADDR_LEN);\n\t\tETHER_TOGGLE_LOCALADDR(&eth.ether_shost);\n\t\teth.ether_type = hton16(ETHER_TYPE_BRCM);\n\n\t\tbcopy((void *)&eth, PKTDATA(dhdp->osh, p), sizeof(eth));\n\t\tbcopy(data, PKTDATA(dhdp->osh, p) + sizeof(eth), data_len);\n\t\tskb = PKTTONATIVE(dhdp->osh, p);\n\t\tskb_data = skb->data;\n\t\tlen = skb->len;\n\n\t\tifidx = dhd_ifname2idx(dhd, \"wlan0\");\n\t\tifp = dhd->iflist[ifidx];\n\t\tif (ifp == NULL)\n\t\t\t ifp = dhd->iflist[0];\n\n\t\tASSERT(ifp);\n\t\tskb->dev = ifp->net;\n\t\tskb->protocol = eth_type_trans(skb, skb->dev);\n\t\tskb->data = skb_data;\n\t\tskb->len = len;\n\n\t\t/* Strip header, count, deliver upward */\n\t\tskb_pull(skb, ETH_HLEN);\n\n\t\t/* Send the packet */\n\t\tif (in_interrupt()) {\n\t\t\tnetif_rx(skb);\n\t\t} else {\n\t\t\tnetif_rx_ni(skb);\n\t\t}\n\t}\n\telse {\n\t\t/* Could not allocate a sk_buf */\n\t\tDHD_ERROR((\"%s: unable to alloc sk_buf\\n\", __FUNCTION__));\n\t}\n}\n#endif /* LOG_INTO_TCPDUMP */\n\nvoid dhd_wait_for_event(dhd_pub_t *dhd, bool *lockvar)\n{\n#if defined(BCMSDIO) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))\n\tstruct dhd_info *dhdinfo =  dhd->info;\n\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))\n\tint timeout = msecs_to_jiffies(IOCTL_RESP_TIMEOUT);\n#else\n\tint timeout = (IOCTL_RESP_TIMEOUT / 1000) * HZ;\n#endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) */\n\n\tdhd_os_sdunlock(dhd);\n\twait_event_timeout(dhdinfo->ctrl_wait, (*lockvar == FALSE), timeout);\n\tdhd_os_sdlock(dhd);\n#endif /* defined(BCMSDIO) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)) */\n\treturn;\n}\n\nvoid dhd_wait_event_wakeup(dhd_pub_t *dhd)\n{\n#if defined(BCMSDIO) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))\n\tstruct dhd_info *dhdinfo =  dhd->info;\n\tif (waitqueue_active(&dhdinfo->ctrl_wait))\n\t\twake_up(&dhdinfo->ctrl_wait);\n#endif\n\treturn;\n}\n\n#if defined(BCMSDIO) || defined(BCMPCIE)\nint\ndhd_net_bus_devreset(struct net_device *dev, uint8 flag)\n{\n\tint ret = 0;\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\n\tif (flag == TRUE) {\n\t\t/* Issue wl down command before resetting the chip */\n\t\tif (dhd_wl_ioctl_cmd(&dhd->pub, WLC_DOWN, NULL, 0, TRUE, 0) < 0) {\n\t\t\tDHD_TRACE((\"%s: wl down failed\\n\", __FUNCTION__));\n\t\t}\n#ifdef PROP_TXSTATUS\n\t\tif (dhd->pub.wlfc_enabled)\n\t\t\tdhd_wlfc_deinit(&dhd->pub);\n#endif /* PROP_TXSTATUS */\n#ifdef PNO_SUPPORT\n\tif (dhd->pub.pno_state)\n\t\tdhd_pno_deinit(&dhd->pub);\n#endif\n\t}\n\n#ifdef BCMSDIO\n\tif (!flag) {\n\t\tdhd_update_fw_nv_path(dhd);\n\t\t/* update firmware and nvram path to sdio bus */\n\t\tdhd_bus_update_fw_nv_path(dhd->pub.bus,\n\t\t\tdhd->fw_path, dhd->nv_path, dhd->conf_path);\n\t}\n#endif /* BCMSDIO */\n\n\tret = dhd_bus_devreset(&dhd->pub, flag);\n\tif (ret) {\n\t\tDHD_ERROR((\"%s: dhd_bus_devreset: %d\\n\", __FUNCTION__, ret));\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n#ifdef BCMSDIO\nint\ndhd_net_bus_suspend(struct net_device *dev)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\treturn dhd_bus_suspend(&dhd->pub);\n}\n\nint\ndhd_net_bus_resume(struct net_device *dev, uint8 stage)\n{\n\t\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tPM_DBGOUT(\"88888888------------------------------------------------7\\r\\n\");\n\treturn dhd_bus_resume(&dhd->pub, stage);\n}\n\n#endif /* BCMSDIO */\n#endif /* BCMSDIO || BCMPCIE */\n\nint net_os_set_suspend_disable(struct net_device *dev, int val)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tint ret = 0;\n\n\tif (dhd) {\n\t\tret = dhd->pub.suspend_disable_flag;\n\t\tdhd->pub.suspend_disable_flag = val;\n\t}\n\treturn ret;\n}\n\nint net_os_set_suspend(struct net_device *dev, int val, int force)\n{\n\tint ret = 0;\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\n\tif (dhd) {\n#if defined(CONFIG_HAS_EARLYSUSPEND) && defined(DHD_USE_EARLYSUSPEND)\n\t\tret = dhd_set_suspend(val, &dhd->pub);\n#else\n\t\tret = dhd_suspend_resume_helper(dhd, val, force);\n#endif\n#ifdef WL_CFG80211\n\t\twl_cfg80211_update_power_mode(dev);\n#endif\n\t}\n\treturn ret;\n}\n\nint net_os_set_suspend_bcn_li_dtim(struct net_device *dev, int val)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\n\tif (dhd)\n\t\tdhd->pub.suspend_bcn_li_dtim = val;\n\n\treturn 0;\n}\n\n#ifdef PKT_FILTER_SUPPORT\nint net_os_rxfilter_add_remove(struct net_device *dev, int add_remove, int num)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tchar *filterp = NULL;\n\tint filter_id = 0;\n\tint ret = 0;\n\n\tif (!dhd_master_mode)\n\t\tadd_remove = !add_remove;\n\n\tif (!dhd || (num == DHD_UNICAST_FILTER_NUM) ||\n\t\t(num == DHD_MDNS_FILTER_NUM))\n\t\treturn ret;\n\tif (num >= dhd->pub.pktfilter_count)\n\t\treturn -EINVAL;\n\tswitch (num) {\n\t\tcase DHD_BROADCAST_FILTER_NUM:\n\t\t\tfilterp = \"101 0 0 0 0xFFFFFFFFFFFF 0xFFFFFFFFFFFF\";\n\t\t\tfilter_id = 101;\n\t\t\tbreak;\n\t\tcase DHD_MULTICAST4_FILTER_NUM:\n\t\t\tfilterp = \"102 0 0 0 0xFFFFFF 0x01005E\";\n\t\t\tfilter_id = 102;\n\t\t\tbreak;\n\t\tcase DHD_MULTICAST6_FILTER_NUM:\n\t\t\tfilterp = \"103 0 0 0 0xFFFF 0x3333\";\n\t\t\tfilter_id = 103;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Add filter */\n\tif (add_remove) {\n\t\tdhd->pub.pktfilter[num] = filterp;\n\t\tdhd_pktfilter_offload_set(&dhd->pub, dhd->pub.pktfilter[num]);\n\t} else { /* Delete filter */\n\t\tif (dhd->pub.pktfilter[num] != NULL) {\n\t\t\tdhd_pktfilter_offload_delete(&dhd->pub, filter_id);\n\t\t\tdhd->pub.pktfilter[num] = NULL;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint dhd_os_enable_packet_filter(dhd_pub_t *dhdp, int val)\n\n{\n\tint ret = 0;\n\n\t/* Packet filtering is set only if we still in early-suspend and\n\t * we need either to turn it ON or turn it OFF\n\t * We can always turn it OFF in case of early-suspend, but we turn it\n\t * back ON only if suspend_disable_flag was not set\n\t*/\n\tif (dhdp && dhdp->up) {\n\t\tif (dhdp->in_suspend) {\n\t\t\tif (!val || (val && !dhdp->suspend_disable_flag))\n\t\t\t\tdhd_enable_packet_filter(val, dhdp);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/* function to enable/disable packet for Network device */\nint net_os_enable_packet_filter(struct net_device *dev, int val)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\n\treturn dhd_os_enable_packet_filter(&dhd->pub, val);\n}\n#endif /* PKT_FILTER_SUPPORT */\n\nint\ndhd_dev_init_ioctl(struct net_device *dev)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tint ret;\n\n\tif ((ret = dhd_sync_with_dongle(&dhd->pub)) < 0)\n\t\tgoto done;\n\ndone:\n\treturn ret;\n}\n\n#ifdef PNO_SUPPORT\n/* Linux wrapper to call common dhd_pno_stop_for_ssid */\nint\ndhd_dev_pno_stop_for_ssid(struct net_device *dev)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\n\treturn (dhd_pno_stop_for_ssid(&dhd->pub));\n}\n/* Linux wrapper to call common dhd_pno_set_for_ssid */\nint\ndhd_dev_pno_set_for_ssid(struct net_device *dev, wlc_ssid_t* ssids_local, int nssid,\n\tuint16  scan_fr, int pno_repeat, int pno_freq_expo_max, uint16 *channel_list, int nchan)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\n\treturn (dhd_pno_set_for_ssid(&dhd->pub, ssids_local, nssid, scan_fr,\n\t\tpno_repeat, pno_freq_expo_max, channel_list, nchan));\n}\n\n/* Linux wrapper to call common dhd_pno_enable */\nint\ndhd_dev_pno_enable(struct net_device *dev, int enable)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\n\treturn (dhd_pno_enable(&dhd->pub, enable));\n}\n\n/* Linux wrapper to call common dhd_pno_set_for_hotlist */\nint\ndhd_dev_pno_set_for_hotlist(struct net_device *dev, wl_pfn_bssid_t *p_pfn_bssid,\n\tstruct dhd_pno_hotlist_params *hotlist_params)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\treturn (dhd_pno_set_for_hotlist(&dhd->pub, p_pfn_bssid, hotlist_params));\n}\n/* Linux wrapper to call common dhd_dev_pno_stop_for_batch */\nint\ndhd_dev_pno_stop_for_batch(struct net_device *dev)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\treturn (dhd_pno_stop_for_batch(&dhd->pub));\n}\n/* Linux wrapper to call common dhd_dev_pno_set_for_batch */\nint\ndhd_dev_pno_set_for_batch(struct net_device *dev, struct dhd_pno_batch_params *batch_params)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\treturn (dhd_pno_set_for_batch(&dhd->pub, batch_params));\n}\n/* Linux wrapper to call common dhd_dev_pno_get_for_batch */\nint\ndhd_dev_pno_get_for_batch(struct net_device *dev, char *buf, int bufsize)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\treturn (dhd_pno_get_for_batch(&dhd->pub, buf, bufsize, PNO_STATUS_NORMAL));\n}\n#endif /* PNO_SUPPORT */\n\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && (1)\nstatic void dhd_hang_process(void *dhd_info, void *event_info, u8 event)\n{\n\tdhd_info_t *dhd;\n\tstruct net_device *dev;\n\n\tdhd = (dhd_info_t *)dhd_info;\n\tdev = dhd->iflist[0]->net;\n\n\tif (dev) {\n\t\trtnl_lock();\n\t\tdev_close(dev);\n\t\trtnl_unlock();\n#if defined(WL_WIRELESS_EXT)\n\t\twl_iw_send_priv_event(dev, \"HANG\");\n#endif\n#if defined(WL_CFG80211)\n\t\twl_cfg80211_hang(dev, WLAN_REASON_UNSPECIFIED);\n#endif\n\t}\n}\n\n\nint dhd_os_send_hang_message(dhd_pub_t *dhdp)\n{\n\tint ret = 0;\n\tif (dhdp) {\n\t\tif (!dhdp->hang_was_sent) {\n\t\t\tdhdp->hang_was_sent = 1;\n\t\t\tdhd_deferred_schedule_work(dhdp->info->dhd_deferred_wq, (void *)dhdp,\n\t\t\t\tDHD_WQ_WORK_HANG_MSG, dhd_hang_process, DHD_WORK_PRIORITY_HIGH);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint net_os_send_hang_message(struct net_device *dev)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tint ret = 0;\n\n\tif (dhd) {\n\t\t/* Report FW problem when enabled */\n\t\tif (dhd->pub.hang_report) {\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))\n\t\t\tret = dhd_os_send_hang_message(&dhd->pub);\n#else\n\t\t\tret = wl_cfg80211_hang(dev, WLAN_REASON_UNSPECIFIED);\n#endif\n\t\t} else {\n\t\t\tDHD_ERROR((\"%s: FW HANG ignored (for testing purpose) and not sent up\\n\",\n\t\t\t\t__FUNCTION__));\n\t\t\t/* Enforce bus down to stop any future traffic */\n\t\t\tdhd->pub.busstate = DHD_BUS_DOWN;\n\t\t}\n\t}\n\treturn ret;\n}\n#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27) && OEM_ANDROID */\n\n\nint dhd_net_wifi_platform_set_power(struct net_device *dev, bool on, unsigned long delay_msec)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\treturn wifi_platform_set_power(dhd->adapter, on, delay_msec);\n}\n\nvoid dhd_get_customized_country_code(struct net_device *dev, char *country_iso_code,\n\twl_country_t *cspec)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tget_customized_country_code(dhd->adapter, country_iso_code, cspec);\n}\nvoid dhd_bus_country_set(struct net_device *dev, wl_country_t *cspec, bool notify)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tif (dhd && dhd->pub.up) {\n\t\tmemcpy(&dhd->pub.dhd_cspec, cspec, sizeof(wl_country_t));\n#ifdef WL_CFG80211\n\t\twl_update_wiphybands(NULL, notify);\n#endif\n\t}\n}\n\nvoid dhd_bus_band_set(struct net_device *dev, uint band)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tif (dhd && dhd->pub.up) {\n#ifdef WL_CFG80211\n\t\twl_update_wiphybands(NULL, true);\n#endif\n\t}\n}\n\nint dhd_net_set_fw_path(struct net_device *dev, char *fw)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\n\tif (!fw || fw[0] == '\\0')\n\t\treturn -EINVAL;\n\n\tstrncpy(dhd->fw_path, fw, sizeof(dhd->fw_path) - 1);\n\tdhd->fw_path[sizeof(dhd->fw_path)-1] = '\\0';\n\n#if defined(SOFTAP)\n\tif (strstr(fw, \"apsta\") != NULL) {\n\t\tDHD_INFO((\"GOT APSTA FIRMWARE\\n\"));\n\t\tap_fw_loaded = TRUE;\n\t} else {\n\t\tDHD_INFO((\"GOT STA FIRMWARE\\n\"));\n\t\tap_fw_loaded = FALSE;\n\t}\n#endif \n\treturn 0;\n}\n\nvoid dhd_net_if_lock(struct net_device *dev)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tdhd_net_if_lock_local(dhd);\n}\n\nvoid dhd_net_if_unlock(struct net_device *dev)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tdhd_net_if_unlock_local(dhd);\n}\n\nstatic void dhd_net_if_lock_local(dhd_info_t *dhd)\n{\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1\n\tif (dhd)\n\t\tmutex_lock(&dhd->dhd_net_if_mutex);\n#endif\n}\n\nstatic void dhd_net_if_unlock_local(dhd_info_t *dhd)\n{\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1\n\tif (dhd)\n\t\tmutex_unlock(&dhd->dhd_net_if_mutex);\n#endif\n}\n\nstatic void dhd_suspend_lock(dhd_pub_t *pub)\n{\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tif (dhd)\n\t\tmutex_lock(&dhd->dhd_suspend_mutex);\n#endif\n}\n\nstatic void dhd_suspend_unlock(dhd_pub_t *pub)\n{\n#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)) && 1\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tif (dhd)\n\t\tmutex_unlock(&dhd->dhd_suspend_mutex);\n#endif\n}\n\nunsigned long dhd_os_general_spin_lock(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tunsigned long flags = 0;\n\n\tif (dhd)\n\t\tspin_lock_irqsave(&dhd->dhd_lock, flags);\n\n\treturn flags;\n}\n\nvoid dhd_os_general_spin_unlock(dhd_pub_t *pub, unsigned long flags)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\n\tif (dhd)\n\t\tspin_unlock_irqrestore(&dhd->dhd_lock, flags);\n}\n\n/* Linux specific multipurpose spinlock API */\nvoid *\ndhd_os_spin_lock_init(osl_t *osh)\n{\n\t/* Adding 4 bytes since the sizeof(spinlock_t) could be 0 */\n\t/* if CONFIG_SMP and CONFIG_DEBUG_SPINLOCK are not defined */\n\t/* and this results in kernel asserts in internal builds */\n\tspinlock_t * lock = MALLOC(osh, sizeof(spinlock_t) + 4);\n\tif (lock)\n\t\tspin_lock_init(lock);\n\treturn ((void *)lock);\n}\nvoid\ndhd_os_spin_lock_deinit(osl_t *osh, void *lock)\n{\n\tMFREE(osh, lock, sizeof(spinlock_t) + 4);\n}\nunsigned long\ndhd_os_spin_lock(void *lock)\n{\n\tunsigned long flags = 0;\n\n\tif (lock)\n\t\tspin_lock_irqsave((spinlock_t *)lock, flags);\n\n\treturn flags;\n}\nvoid\ndhd_os_spin_unlock(void *lock, unsigned long flags)\n{\n\tif (lock)\n\t\tspin_unlock_irqrestore((spinlock_t *)lock, flags);\n}\n\nstatic int\ndhd_get_pend_8021x_cnt(dhd_info_t *dhd)\n{\n\treturn (atomic_read(&dhd->pend_8021x_cnt));\n}\n\n#define MAX_WAIT_FOR_8021X_TX\t100\n\nint\ndhd_wait_pend8021x(struct net_device *dev)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tint timeout = msecs_to_jiffies(10);\n\tint ntimes = MAX_WAIT_FOR_8021X_TX;\n\tint pend = dhd_get_pend_8021x_cnt(dhd);\n\n\twhile (ntimes && pend) {\n\t\tif (pend) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tDHD_PERIM_UNLOCK(&dhd->pub);\n\t\t\tschedule_timeout(timeout);\n\t\t\tDHD_PERIM_LOCK(&dhd->pub);\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tntimes--;\n\t\t}\n\t\tpend = dhd_get_pend_8021x_cnt(dhd);\n\t}\n\tif (ntimes == 0)\n\t{\n\t\tatomic_set(&dhd->pend_8021x_cnt, 0);\n\t\tDHD_ERROR((\"%s: TIMEOUT\\n\", __FUNCTION__));\n\t}\n\treturn pend;\n}\n\n#ifdef DHD_DEBUG\nint\nwrite_to_file(dhd_pub_t *dhd, uint8 *buf, int size)\n{\n\tint ret = 0;\n\tstruct file *fp;\n\tmm_segment_t old_fs;\n\tloff_t pos = 0;\n\n\t/* change to KERNEL_DS address limit */\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\t/* open file to write */\n\tfp = filp_open(\"/tmp/mem_dump\", O_WRONLY|O_CREAT, 0640);\n\tif (!fp) {\n\t\tprintf(\"%s: open file error\\n\", __FUNCTION__);\n\t\tret = -1;\n\t\tgoto exit;\n\t}\n\n\t/* Write buf to file */\n\tfp->f_op->write(fp, buf, size, &pos);\n\nexit:\n\t/* free buf before return */\n\tMFREE(dhd->osh, buf, size);\n\t/* close file before return */\n\tif (fp)\n\t\tfilp_close(fp, current->files);\n\t/* restore previous address limit */\n\tset_fs(old_fs);\n\n\treturn ret;\n}\n#endif /* DHD_DEBUG */\n\nint dhd_os_wake_lock_timeout(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (dhd) {\n\t\tspin_lock_irqsave(&dhd->wakelock_spinlock, flags);\n\t\tret = dhd->wakelock_rx_timeout_enable > dhd->wakelock_ctrl_timeout_enable ?\n\t\t\tdhd->wakelock_rx_timeout_enable : dhd->wakelock_ctrl_timeout_enable;\n#ifdef CONFIG_HAS_WAKELOCK\n\t\tif (dhd->wakelock_rx_timeout_enable)\n\t\t\twake_lock_timeout(&dhd->wl_rxwake,\n\t\t\t\tmsecs_to_jiffies(dhd->wakelock_rx_timeout_enable));\n\t\tif (dhd->wakelock_ctrl_timeout_enable)\n\t\t\twake_lock_timeout(&dhd->wl_ctrlwake,\n\t\t\t\tmsecs_to_jiffies(dhd->wakelock_ctrl_timeout_enable));\n#endif\n\t\tdhd->wakelock_rx_timeout_enable = 0;\n\t\tdhd->wakelock_ctrl_timeout_enable = 0;\n\t\tspin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);\n\t}\n\treturn ret;\n}\n\nint net_os_wake_lock_timeout(struct net_device *dev)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tint ret = 0;\n\n\tif (dhd)\n\t\tret = dhd_os_wake_lock_timeout(&dhd->pub);\n\treturn ret;\n}\n\nint dhd_os_wake_lock_rx_timeout_enable(dhd_pub_t *pub, int val)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tunsigned long flags;\n\n\tif (dhd) {\n\t\tspin_lock_irqsave(&dhd->wakelock_spinlock, flags);\n\t\tif (val > dhd->wakelock_rx_timeout_enable)\n\t\t\tdhd->wakelock_rx_timeout_enable = val;\n\t\tspin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);\n\t}\n\treturn 0;\n}\n\nint dhd_os_wake_lock_ctrl_timeout_enable(dhd_pub_t *pub, int val)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tunsigned long flags;\n\n\tif (dhd) {\n\t\tspin_lock_irqsave(&dhd->wakelock_spinlock, flags);\n\t\tif (val > dhd->wakelock_ctrl_timeout_enable)\n\t\t\tdhd->wakelock_ctrl_timeout_enable = val;\n\t\tspin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);\n\t}\n\treturn 0;\n}\n\nint dhd_os_wake_lock_ctrl_timeout_cancel(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tunsigned long flags;\n\n\tif (dhd) {\n\t\tspin_lock_irqsave(&dhd->wakelock_spinlock, flags);\n\t\tdhd->wakelock_ctrl_timeout_enable = 0;\n#ifdef CONFIG_HAS_WAKELOCK\n\t\tif (wake_lock_active(&dhd->wl_ctrlwake))\n\t\t\twake_unlock(&dhd->wl_ctrlwake);\n#endif\n\t\tspin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);\n\t}\n\treturn 0;\n}\n\nint net_os_wake_lock_rx_timeout_enable(struct net_device *dev, int val)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tint ret = 0;\n\n\tif (dhd)\n\t\tret = dhd_os_wake_lock_rx_timeout_enable(&dhd->pub, val);\n\treturn ret;\n}\n\nint net_os_wake_lock_ctrl_timeout_enable(struct net_device *dev, int val)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tint ret = 0;\n\n\tif (dhd)\n\t\tret = dhd_os_wake_lock_ctrl_timeout_enable(&dhd->pub, val);\n\treturn ret;\n}\n\nint dhd_os_wake_lock(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (dhd) {\n\t\tspin_lock_irqsave(&dhd->wakelock_spinlock, flags);\n\n\t\tif (dhd->wakelock_counter == 0 && !dhd->waive_wakelock) {\n#ifdef CONFIG_HAS_WAKELOCK\n\t\t\twake_lock(&dhd->wl_wifi);\n#elif defined(BCMSDIO) && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))\n\t\t\tdhd_bus_dev_pm_stay_awake(pub);\n#endif\n\t\t}\n\t\tdhd->wakelock_counter++;\n\t\tret = dhd->wakelock_counter;\n\t\tspin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);\n\t}\n\treturn ret;\n}\n\nint net_os_wake_lock(struct net_device *dev)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tint ret = 0;\n\n\tif (dhd)\n\t\tret = dhd_os_wake_lock(&dhd->pub);\n\treturn ret;\n}\n\nint dhd_os_wake_unlock(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tdhd_os_wake_lock_timeout(pub);\n\tif (dhd) {\n\t\tspin_lock_irqsave(&dhd->wakelock_spinlock, flags);\n\t\tif (dhd->wakelock_counter > 0) {\n\t\t\tdhd->wakelock_counter--;\n\t\t\tif (dhd->wakelock_counter == 0 && !dhd->waive_wakelock) {\n#ifdef CONFIG_HAS_WAKELOCK\n\t\t\t\twake_unlock(&dhd->wl_wifi);\n#elif defined(BCMSDIO) && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))\n\t\t\t\tdhd_bus_dev_pm_relax(pub);\n#endif\n\t\t\t}\n\t\t\tret = dhd->wakelock_counter;\n\t\t}\n\t\tspin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);\n\t}\n\treturn ret;\n}\n\nint dhd_os_check_wakelock(dhd_pub_t *pub)\n{\n#if defined(CONFIG_HAS_WAKELOCK) || (defined(BCMSDIO) && (LINUX_VERSION_CODE > \\\n\tKERNEL_VERSION(2, 6, 36)))\n\tdhd_info_t *dhd;\n\n\tif (!pub)\n\t\treturn 0;\n\tdhd = (dhd_info_t *)(pub->info);\n#endif /* CONFIG_HAS_WAKELOCK || BCMSDIO */\n\n#ifdef CONFIG_HAS_WAKELOCK\n\t/* Indicate to the SD Host to avoid going to suspend if internal locks are up */\n\tif (dhd && (wake_lock_active(&dhd->wl_wifi) ||\n\t\t(wake_lock_active(&dhd->wl_wdwake))))\n\t\treturn 1;\n#elif defined(BCMSDIO) && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))\n\tif (dhd && (dhd->wakelock_counter > 0) && dhd_bus_dev_pm_enabled(pub))\n\t\treturn 1;\n#endif\n\treturn 0;\n}\n\nint dhd_os_check_wakelock_all(dhd_pub_t *pub)\n{\n#if defined(CONFIG_HAS_WAKELOCK) || (defined(BCMSDIO) && (LINUX_VERSION_CODE > \\\n\tKERNEL_VERSION(2, 6, 36)))\n\tdhd_info_t *dhd;\n\n\tif (!pub)\n\t\treturn 0;\n\tdhd = (dhd_info_t *)(pub->info);\n#endif /* CONFIG_HAS_WAKELOCK || BCMSDIO */\n\n#ifdef CONFIG_HAS_WAKELOCK\n\t/* Indicate to the SD Host to avoid going to suspend if internal locks are up */\n\tif (dhd && (wake_lock_active(&dhd->wl_wifi) ||\n\t\twake_lock_active(&dhd->wl_wdwake) ||\n\t\twake_lock_active(&dhd->wl_rxwake) ||\n\t\twake_lock_active(&dhd->wl_ctrlwake))) {\n\t\treturn 1;\n\t}\n#elif defined(BCMSDIO) && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))\n\tif (dhd && (dhd->wakelock_counter > 0) && dhd_bus_dev_pm_enabled(pub))\n\t\treturn 1;\n#endif\n\treturn 0;\n}\n\nint net_os_wake_unlock(struct net_device *dev)\n{\n\tdhd_info_t *dhd = DHD_DEV_INFO(dev);\n\tint ret = 0;\n\n\tif (dhd)\n\t\tret = dhd_os_wake_unlock(&dhd->pub);\n\treturn ret;\n}\n\nint dhd_os_wd_wake_lock(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (dhd) {\n\t\tspin_lock_irqsave(&dhd->wakelock_spinlock, flags);\n#ifdef CONFIG_HAS_WAKELOCK\n\t\t/* if wakelock_wd_counter was never used : lock it at once */\n\t\tif (!dhd->wakelock_wd_counter)\n\t\t\twake_lock(&dhd->wl_wdwake);\n#endif\n\t\tdhd->wakelock_wd_counter++;\n\t\tret = dhd->wakelock_wd_counter;\n\t\tspin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);\n\t}\n\treturn ret;\n}\n\nint dhd_os_wd_wake_unlock(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (dhd) {\n\t\tspin_lock_irqsave(&dhd->wakelock_spinlock, flags);\n\t\tif (dhd->wakelock_wd_counter) {\n\t\t\tdhd->wakelock_wd_counter = 0;\n#ifdef CONFIG_HAS_WAKELOCK\n\t\t\twake_unlock(&dhd->wl_wdwake);\n#endif\n\t\t}\n\t\tspin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);\n\t}\n\treturn ret;\n}\n\n#ifdef BCMPCIE_OOB_HOST_WAKE\nint dhd_os_oob_irq_wake_lock_timeout(dhd_pub_t *pub, int val)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tint ret = 0;\n\n\tif (dhd) {\n#ifdef CONFIG_HAS_WAKELOCK\n\t\twake_lock_timeout(&dhd->wl_intrwake, msecs_to_jiffies(val));\n#endif\n\t}\n\treturn ret;\n}\n\nint dhd_os_oob_irq_wake_unlock(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tint ret = 0;\n\n\tif (dhd) {\n#ifdef CONFIG_HAS_WAKELOCK\n\t\t/* if wl_intrwake is active, unlock it */\n\t\tif (wake_lock_active(&dhd->wl_intrwake)) {\n\t\t\twake_unlock(&dhd->wl_intrwake);\n\t\t}\n#endif\n\t}\n\treturn ret;\n}\n#endif /* BCMPCIE_OOB_HOST_WAKE */\n\n/* waive wakelocks for operations such as IOVARs in suspend function, must be closed\n * by a paired function call to dhd_wakelock_restore. returns current wakelock counter\n */\nint dhd_os_wake_lock_waive(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (dhd) {\n\t\tspin_lock_irqsave(&dhd->wakelock_spinlock, flags);\n\t\t/* dhd_wakelock_waive/dhd_wakelock_restore must be paired */\n\t\tif (dhd->waive_wakelock == FALSE) {\n\t\t\t/* record current lock status */\n\t\t\tdhd->wakelock_before_waive = dhd->wakelock_counter;\n\t\t\tdhd->waive_wakelock = TRUE;\n\t\t}\n\t\tret = dhd->wakelock_wd_counter;\n\t\tspin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);\n\t}\n\treturn ret;\n}\n\nint dhd_os_wake_lock_restore(dhd_pub_t *pub)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(pub->info);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!dhd)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dhd->wakelock_spinlock, flags);\n\t/* dhd_wakelock_waive/dhd_wakelock_restore must be paired */\n\tif (!dhd->waive_wakelock)\n\t\tgoto exit;\n\n\tdhd->waive_wakelock = FALSE;\n\t/* if somebody else acquires wakelock between dhd_wakelock_waive/dhd_wakelock_restore,\n\t * we need to make it up by calling wake_lock or pm_stay_awake. or if somebody releases\n\t * the lock in between, do the same by calling wake_unlock or pm_relax\n\t */\n\tif (dhd->wakelock_before_waive == 0 && dhd->wakelock_counter > 0) {\n#ifdef CONFIG_HAS_WAKELOCK\n\t\twake_lock(&dhd->wl_wifi);\n#elif defined(BCMSDIO) && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))\n\t\tdhd_bus_dev_pm_stay_awake(&dhd->pub);\n#endif\n\t} else if (dhd->wakelock_before_waive > 0 && dhd->wakelock_counter == 0) {\n#ifdef CONFIG_HAS_WAKELOCK\n\t\twake_unlock(&dhd->wl_wifi);\n#elif defined(BCMSDIO) && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))\n\t\tdhd_bus_dev_pm_relax(&dhd->pub);\n#endif\n\t}\n\tdhd->wakelock_before_waive = 0;\nexit:\n\tret = dhd->wakelock_wd_counter;\n\tspin_unlock_irqrestore(&dhd->wakelock_spinlock, flags);\n\treturn ret;\n}\n\nbool dhd_os_check_if_up(dhd_pub_t *pub)\n{\n\tif (!pub)\n\t\treturn FALSE;\n\treturn pub->up;\n}\n\n/* function to collect firmware, chip id and chip version info */\nvoid dhd_set_version_info(dhd_pub_t *dhdp, char *fw)\n{\n\tint i;\n\n\ti = snprintf(info_string, sizeof(info_string),\n\t\t\"  Driver: %s\\n  Firmware: %s \", EPI_VERSION_STR, fw);\n\tprintf(\"%s\\n\", info_string);\n\n\tif (!dhdp)\n\t\treturn;\n\n\ti = snprintf(&info_string[i], sizeof(info_string) - i,\n\t\t\"\\n  Chip: %x Rev %x Pkg %x\", dhd_bus_chip_id(dhdp),\n\t\tdhd_bus_chiprev_id(dhdp), dhd_bus_chippkg_id(dhdp));\n}\n\nint dhd_ioctl_entry_local(struct net_device *net, wl_ioctl_t *ioc, int cmd)\n{\n\tint ifidx;\n\tint ret = 0;\n\tdhd_info_t *dhd = NULL;\n\n\tif (!net || !DEV_PRIV(net)) {\n\t\tDHD_ERROR((\"%s invalid parameter\\n\", __FUNCTION__));\n\t\treturn -EINVAL;\n\t}\n\n\tdhd = DHD_DEV_INFO(net);\n\tif (!dhd)\n\t\treturn -EINVAL;\n\n\tifidx = dhd_net2idx(dhd, net);\n\tif (ifidx == DHD_BAD_IF) {\n\t\tDHD_ERROR((\"%s bad ifidx\\n\", __FUNCTION__));\n\t\treturn -ENODEV;\n\t}\n\n\tDHD_OS_WAKE_LOCK(&dhd->pub);\n\tDHD_PERIM_LOCK(&dhd->pub);\n\n\tret = dhd_wl_ioctl(&dhd->pub, ifidx, ioc, ioc->buf, ioc->len);\n\tdhd_check_hang(net, &dhd->pub, ret);\n\n\tDHD_PERIM_UNLOCK(&dhd->pub);\n\tDHD_OS_WAKE_UNLOCK(&dhd->pub);\n\n\treturn ret;\n}\n\nbool dhd_os_check_hang(dhd_pub_t *dhdp, int ifidx, int ret)\n{\n\tstruct net_device *net;\n\n\tnet = dhd_idx2net(dhdp, ifidx);\n\tif (!net) {\n\t\tDHD_ERROR((\"%s : Invalid index : %d\\n\", __FUNCTION__, ifidx));\n\t\treturn -EINVAL;\n\t}\n\n\treturn dhd_check_hang(net, dhdp, ret);\n}\n\n/* Return instance */\nint dhd_get_instance(dhd_pub_t *dhdp)\n{\n\treturn dhdp->info->unit;\n}\n\n\n#ifdef PROP_TXSTATUS\n\nvoid dhd_wlfc_plat_init(void *dhd)\n{\n\treturn;\n}\n\nvoid dhd_wlfc_plat_deinit(void *dhd)\n{\n\treturn;\n}\n\nbool dhd_wlfc_skip_fc(void)\n{\n\treturn FALSE;\n}\n#endif /* PROP_TXSTATUS */\n\n#ifdef BCMDBGFS\n\n#include <linux/debugfs.h>\n\nextern uint32 dhd_readregl(void *bp, uint32 addr);\nextern uint32 dhd_writeregl(void *bp, uint32 addr, uint32 data);\n\ntypedef struct dhd_dbgfs {\n\tstruct dentry\t*debugfs_dir;\n\tstruct dentry\t*debugfs_mem;\n\tdhd_pub_t \t*dhdp;\n\tuint32 \t\tsize;\n} dhd_dbgfs_t;\n\ndhd_dbgfs_t g_dbgfs;\n\nstatic int\ndhd_dbg_state_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = inode->i_private;\n\treturn 0;\n}\n\nstatic ssize_t\ndhd_dbg_state_read(struct file *file, char __user *ubuf,\n                       size_t count, loff_t *ppos)\n{\n\tssize_t rval;\n\tuint32 tmp;\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= g_dbgfs.size || !count)\n\t\treturn 0;\n\tif (count > g_dbgfs.size - pos)\n\t\tcount = g_dbgfs.size - pos;\n\n\t/* Basically enforce aligned 4 byte reads. It's up to the user to work out the details */\n\ttmp = dhd_readregl(g_dbgfs.dhdp->bus, file->f_pos & (~3));\n\n\tret = copy_to_user(ubuf, &tmp, 4);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\n\tcount -= ret;\n\t*ppos = pos + count;\n\trval = count;\n\n\treturn rval;\n}\n\n\nstatic ssize_t\ndhd_debugfs_write(struct file *file, const char __user *ubuf, size_t count, loff_t *ppos)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\tuint32 buf;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= g_dbgfs.size || !count)\n\t\treturn 0;\n\tif (count > g_dbgfs.size - pos)\n\t\tcount = g_dbgfs.size - pos;\n\n\tret = copy_from_user(&buf, ubuf, sizeof(uint32));\n\tif (ret == count)\n\t\treturn -EFAULT;\n\n\t/* Basically enforce aligned 4 byte writes. It's up to the user to work out the details */\n\tdhd_writeregl(g_dbgfs.dhdp->bus, file->f_pos & (~3), buf);\n\n\treturn count;\n}\n\n\nloff_t\ndhd_debugfs_lseek(struct file *file, loff_t off, int whence)\n{\n\tloff_t pos = -1;\n\n\tswitch (whence) {\n\t\tcase 0:\n\t\t\tpos = off;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpos = file->f_pos + off;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpos = g_dbgfs.size - off;\n\t}\n\treturn (pos < 0 || pos > g_dbgfs.size) ? -EINVAL : (file->f_pos = pos);\n}\n\nstatic const struct file_operations dhd_dbg_state_ops = {\n\t.read   = dhd_dbg_state_read,\n\t.write\t= dhd_debugfs_write,\n\t.open   = dhd_dbg_state_open,\n\t.llseek\t= dhd_debugfs_lseek\n};\n\nstatic void dhd_dbg_create(void)\n{\n\tif (g_dbgfs.debugfs_dir) {\n\t\tg_dbgfs.debugfs_mem = debugfs_create_file(\"mem\", 0644, g_dbgfs.debugfs_dir,\n\t\t\tNULL, &dhd_dbg_state_ops);\n\t}\n}\n\nvoid dhd_dbg_init(dhd_pub_t *dhdp)\n{\n\tint err;\n\n\tg_dbgfs.dhdp = dhdp;\n\tg_dbgfs.size = 0x20000000; /* Allow access to various cores regs */\n\n\tg_dbgfs.debugfs_dir = debugfs_create_dir(\"dhd\", 0);\n\tif (IS_ERR(g_dbgfs.debugfs_dir)) {\n\t\terr = PTR_ERR(g_dbgfs.debugfs_dir);\n\t\tg_dbgfs.debugfs_dir = NULL;\n\t\treturn;\n\t}\n\n\tdhd_dbg_create();\n\n\treturn;\n}\n\nvoid dhd_dbg_remove(void)\n{\n\tdebugfs_remove(g_dbgfs.debugfs_mem);\n\tdebugfs_remove(g_dbgfs.debugfs_dir);\n\n\tbzero((unsigned char *) &g_dbgfs, sizeof(g_dbgfs));\n\n}\n#endif /* ifdef BCMDBGFS */\n\n#ifdef WLMEDIA_HTSF\n\nstatic\nvoid dhd_htsf_addtxts(dhd_pub_t *dhdp, void *pktbuf)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)(dhdp->info);\n\tstruct sk_buff *skb;\n\tuint32 htsf = 0;\n\tuint16 dport = 0, oldmagic = 0xACAC;\n\tchar *p1;\n\thtsfts_t ts;\n\n\t/*  timestamp packet  */\n\n\tp1 = (char*) PKTDATA(dhdp->osh, pktbuf);\n\n\tif (PKTLEN(dhdp->osh, pktbuf) > HTSF_MINLEN) {\n/*\t\tmemcpy(&proto, p1+26, 4);  \t*/\n\t\tmemcpy(&dport, p1+40, 2);\n/* \tproto = ((ntoh32(proto))>> 16) & 0xFF;  */\n\t\tdport = ntoh16(dport);\n\t}\n\n\t/* timestamp only if  icmp or udb iperf with port 5555 */\n/*\tif (proto == 17 && dport == tsport) { */\n\tif (dport >= tsport && dport <= tsport + 20) {\n\n\t\tskb = (struct sk_buff *) pktbuf;\n\n\t\thtsf = dhd_get_htsf(dhd, 0);\n\t\tmemset(skb->data + 44, 0, 2); /* clear checksum */\n\t\tmemcpy(skb->data+82, &oldmagic, 2);\n\t\tmemcpy(skb->data+84, &htsf, 4);\n\n\t\tmemset(&ts, 0, sizeof(htsfts_t));\n\t\tts.magic  = HTSFMAGIC;\n\t\tts.prio   = PKTPRIO(pktbuf);\n\t\tts.seqnum = htsf_seqnum++;\n\t\tts.c10    = get_cycles();\n\t\tts.t10    = htsf;\n\t\tts.endmagic = HTSFENDMAGIC;\n\n\t\tmemcpy(skb->data + HTSF_HOSTOFFSET, &ts, sizeof(ts));\n\t}\n}\n\nstatic void dhd_dump_htsfhisto(histo_t *his, char *s)\n{\n\tint pktcnt = 0, curval = 0, i;\n\tfor (i = 0; i < (NUMBIN-2); i++) {\n\t\tcurval += 500;\n\t\tprintf(\"%d \",  his->bin[i]);\n\t\tpktcnt += his->bin[i];\n\t}\n\tprintf(\" max: %d TotPkt: %d neg: %d [%s]\\n\", his->bin[NUMBIN-2], pktcnt,\n\t\this->bin[NUMBIN-1], s);\n}\n\nstatic\nvoid sorttobin(int value, histo_t *histo)\n{\n\tint i, binval = 0;\n\n\tif (value < 0) {\n\t\thisto->bin[NUMBIN-1]++;\n\t\treturn;\n\t}\n\tif (value > histo->bin[NUMBIN-2])  /* store the max value  */\n\t\thisto->bin[NUMBIN-2] = value;\n\n\tfor (i = 0; i < (NUMBIN-2); i++) {\n\t\tbinval += 500; /* 500m s bins */\n\t\tif (value <= binval) {\n\t\t\thisto->bin[i]++;\n\t\t\treturn;\n\t\t}\n\t}\n\thisto->bin[NUMBIN-3]++;\n}\n\nstatic\nvoid dhd_htsf_addrxts(dhd_pub_t *dhdp, void *pktbuf)\n{\n\tdhd_info_t *dhd = (dhd_info_t *)dhdp->info;\n\tstruct sk_buff *skb;\n\tchar *p1;\n\tuint16 old_magic;\n\tint d1, d2, d3, end2end;\n\thtsfts_t *htsf_ts;\n\tuint32 htsf;\n\n\tskb = PKTTONATIVE(dhdp->osh, pktbuf);\n\tp1 = (char*)PKTDATA(dhdp->osh, pktbuf);\n\n\tif (PKTLEN(osh, pktbuf) > HTSF_MINLEN) {\n\t\tmemcpy(&old_magic, p1+78, 2);\n\t\thtsf_ts = (htsfts_t*) (p1 + HTSF_HOSTOFFSET - 4);\n\t}\n\telse\n\t\treturn;\n\n\tif (htsf_ts->magic == HTSFMAGIC) {\n\t\thtsf_ts->tE0 = dhd_get_htsf(dhd, 0);\n\t\thtsf_ts->cE0 = get_cycles();\n\t}\n\n\tif (old_magic == 0xACAC) {\n\n\t\ttspktcnt++;\n\t\thtsf = dhd_get_htsf(dhd, 0);\n\t\tmemcpy(skb->data+92, &htsf, sizeof(uint32));\n\n\t\tmemcpy(&ts[tsidx].t1, skb->data+80, 16);\n\n\t\td1 = ts[tsidx].t2 - ts[tsidx].t1;\n\t\td2 = ts[tsidx].t3 - ts[tsidx].t2;\n\t\td3 = ts[tsidx].t4 - ts[tsidx].t3;\n\t\tend2end = ts[tsidx].t4 - ts[tsidx].t1;\n\n\t\tsorttobin(d1, &vi_d1);\n\t\tsorttobin(d2, &vi_d2);\n\t\tsorttobin(d3, &vi_d3);\n\t\tsorttobin(end2end, &vi_d4);\n\n\t\tif (end2end > 0 && end2end >  maxdelay) {\n\t\t\tmaxdelay = end2end;\n\t\t\tmaxdelaypktno = tspktcnt;\n\t\t\tmemcpy(&maxdelayts, &ts[tsidx], 16);\n\t\t}\n\t\tif (++tsidx >= TSMAX)\n\t\t\ttsidx = 0;\n\t}\n}\n\nuint32 dhd_get_htsf(dhd_info_t *dhd, int ifidx)\n{\n\tuint32 htsf = 0, cur_cycle, delta, delta_us;\n\tuint32    factor, baseval, baseval2;\n\tcycles_t t;\n\n\tt = get_cycles();\n\tcur_cycle = t;\n\n\tif (cur_cycle >  dhd->htsf.last_cycle)\n\t\tdelta = cur_cycle -  dhd->htsf.last_cycle;\n\telse {\n\t\tdelta = cur_cycle + (0xFFFFFFFF -  dhd->htsf.last_cycle);\n\t}\n\n\tdelta = delta >> 4;\n\n\tif (dhd->htsf.coef) {\n\t\t/* times ten to get the first digit */\n\t        factor = (dhd->htsf.coef*10 + dhd->htsf.coefdec1);\n\t\tbaseval  = (delta*10)/factor;\n\t\tbaseval2 = (delta*10)/(factor+1);\n\t\tdelta_us  = (baseval -  (((baseval - baseval2) * dhd->htsf.coefdec2)) / 10);\n\t\thtsf = (delta_us << 4) +  dhd->htsf.last_tsf + HTSF_BUS_DELAY;\n\t}\n\telse {\n\t\tDHD_ERROR((\"-------dhd->htsf.coef = 0 -------\\n\"));\n\t}\n\n\treturn htsf;\n}\n\nstatic void dhd_dump_latency(void)\n{\n\tint i, max = 0;\n\tint d1, d2, d3, d4, d5;\n\n\tprintf(\"T1       T2       T3       T4           d1  d2   t4-t1     i    \\n\");\n\tfor (i = 0; i < TSMAX; i++) {\n\t\td1 = ts[i].t2 - ts[i].t1;\n\t\td2 = ts[i].t3 - ts[i].t2;\n\t\td3 = ts[i].t4 - ts[i].t3;\n\t\td4 = ts[i].t4 - ts[i].t1;\n\t\td5 = ts[max].t4-ts[max].t1;\n\t\tif (d4 > d5 && d4 > 0)  {\n\t\t\tmax = i;\n\t\t}\n\t\tprintf(\"%08X %08X %08X %08X \\t%d %d %d   %d i=%d\\n\",\n\t\t\tts[i].t1, ts[i].t2, ts[i].t3, ts[i].t4,\n\t\t\td1, d2, d3, d4, i);\n\t}\n\n\tprintf(\"current idx = %d \\n\", tsidx);\n\n\tprintf(\"Highest latency %d pkt no.%d total=%d\\n\", maxdelay, maxdelaypktno, tspktcnt);\n\tprintf(\"%08X %08X %08X %08X \\t%d %d %d   %d\\n\",\n\tmaxdelayts.t1, maxdelayts.t2, maxdelayts.t3, maxdelayts.t4,\n\tmaxdelayts.t2 - maxdelayts.t1,\n\tmaxdelayts.t3 - maxdelayts.t2,\n\tmaxdelayts.t4 - maxdelayts.t3,\n\tmaxdelayts.t4 - maxdelayts.t1);\n}\n\n\nstatic int\ndhd_ioctl_htsf_get(dhd_info_t *dhd, int ifidx)\n{\n\twl_ioctl_t ioc;\n\tchar buf[32];\n\tint ret;\n\tuint32 s1, s2;\n\n\tstruct tsf {\n\t\tuint32 low;\n\t\tuint32 high;\n\t} tsf_buf;\n\n\tmemset(&ioc, 0, sizeof(ioc));\n\tmemset(&tsf_buf, 0, sizeof(tsf_buf));\n\n\tioc.cmd = WLC_GET_VAR;\n\tioc.buf = buf;\n\tioc.len = (uint)sizeof(buf);\n\tioc.set = FALSE;\n\n\tstrncpy(buf, \"tsf\", sizeof(buf) - 1);\n\tbuf[sizeof(buf) - 1] = '\\0';\n\ts1 = dhd_get_htsf(dhd, 0);\n\tif ((ret = dhd_wl_ioctl(&dhd->pub, ifidx, &ioc, ioc.buf, ioc.len)) < 0) {\n\t\tif (ret == -EIO) {\n\t\t\tDHD_ERROR((\"%s: tsf is not supported by device\\n\",\n\t\t\t\tdhd_ifname(&dhd->pub, ifidx)));\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\treturn ret;\n\t}\n\ts2 = dhd_get_htsf(dhd, 0);\n\n\tmemcpy(&tsf_buf, buf, sizeof(tsf_buf));\n\tprintf(\" TSF_h=%04X lo=%08X Calc:htsf=%08X, coef=%d.%d%d delta=%d \",\n\t\ttsf_buf.high, tsf_buf.low, s2, dhd->htsf.coef, dhd->htsf.coefdec1,\n\t\tdhd->htsf.coefdec2, s2-tsf_buf.low);\n\tprintf(\"lasttsf=%08X lastcycle=%08X\\n\", dhd->htsf.last_tsf, dhd->htsf.last_cycle);\n\treturn 0;\n}\n\nvoid htsf_update(dhd_info_t *dhd, void *data)\n{\n\tstatic ulong  cur_cycle = 0, prev_cycle = 0;\n\tuint32 htsf, tsf_delta = 0;\n\tuint32 hfactor = 0, cyc_delta, dec1 = 0, dec2, dec3, tmp;\n\tulong b, a;\n\tcycles_t t;\n\n\t/* cycles_t in inlcude/mips/timex.h */\n\n\tt = get_cycles();\n\n\tprev_cycle = cur_cycle;\n\tcur_cycle = t;\n\n\tif (cur_cycle > prev_cycle)\n\t\tcyc_delta = cur_cycle - prev_cycle;\n\telse {\n\t\tb = cur_cycle;\n\t\ta = prev_cycle;\n\t\tcyc_delta = cur_cycle + (0xFFFFFFFF - prev_cycle);\n\t}\n\n\tif (data == NULL)\n\t\tprintf(\" tsf update ata point er is null \\n\");\n\n\tmemcpy(&prev_tsf, &cur_tsf, sizeof(tsf_t));\n\tmemcpy(&cur_tsf, data, sizeof(tsf_t));\n\n\tif (cur_tsf.low == 0) {\n\t\tDHD_INFO((\" ---- 0 TSF, do not update, return\\n\"));\n\t\treturn;\n\t}\n\n\tif (cur_tsf.low > prev_tsf.low)\n\t\ttsf_delta = (cur_tsf.low - prev_tsf.low);\n\telse {\n\t\tDHD_INFO((\" ---- tsf low is smaller cur_tsf= %08X, prev_tsf=%08X, \\n\",\n\t\t cur_tsf.low, prev_tsf.low));\n\t\tif (cur_tsf.high > prev_tsf.high) {\n\t\t\ttsf_delta = cur_tsf.low + (0xFFFFFFFF - prev_tsf.low);\n\t\t\tDHD_INFO((\" ---- Wrap around tsf coutner  adjusted TSF=%08X\\n\", tsf_delta));\n\t\t}\n\t\telse\n\t\t\treturn; /* do not update */\n\t}\n\n\tif (tsf_delta)  {\n\t\thfactor = cyc_delta / tsf_delta;\n\t\ttmp  = \t(cyc_delta - (hfactor * tsf_delta))*10;\n\t\tdec1 =  tmp/tsf_delta;\n\t\tdec2 =  ((tmp - dec1*tsf_delta)*10) / tsf_delta;\n\t\ttmp  = \t(tmp   - (dec1*tsf_delta))*10;\n\t\tdec3 =  ((tmp - dec2*tsf_delta)*10) / tsf_delta;\n\n\t\tif (dec3 > 4) {\n\t\t\tif (dec2 == 9) {\n\t\t\t\tdec2 = 0;\n\t\t\t\tif (dec1 == 9) {\n\t\t\t\t\tdec1 = 0;\n\t\t\t\t\thfactor++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdec1++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tdec2++;\n\t\t}\n\t}\n\n\tif (hfactor) {\n\t\thtsf = ((cyc_delta * 10)  / (hfactor*10+dec1)) + prev_tsf.low;\n\t\tdhd->htsf.coef = hfactor;\n\t\tdhd->htsf.last_cycle = cur_cycle;\n\t\tdhd->htsf.last_tsf = cur_tsf.low;\n\t\tdhd->htsf.coefdec1 = dec1;\n\t\tdhd->htsf.coefdec2 = dec2;\n\t}\n\telse {\n\t\thtsf = prev_tsf.low;\n\t}\n}\n\n#endif /* WLMEDIA_HTSF */\n\n#ifdef CUSTOM_SET_CPUCORE\nvoid dhd_set_cpucore(dhd_pub_t *dhd, int set)\n{\n\tint e_dpc = 0, e_rxf = 0, retry_set = 0;\n\n\tif (!(dhd->chan_isvht80)) {\n\t\tDHD_ERROR((\"%s: chan_status(%d) cpucore!!!\\n\", __FUNCTION__, dhd->chan_isvht80));\n\t\treturn;\n\t}\n\n\tif (DPC_CPUCORE) {\n\t\tdo {\n\t\t\tif (set == TRUE) {\n\t\t\t\te_dpc = set_cpus_allowed_ptr(dhd->current_dpc,\n\t\t\t\t\tcpumask_of(DPC_CPUCORE));\n\t\t\t} else {\n\t\t\t\te_dpc = set_cpus_allowed_ptr(dhd->current_dpc,\n\t\t\t\t\tcpumask_of(PRIMARY_CPUCORE));\n\t\t\t}\n\t\t\tif (retry_set++ > MAX_RETRY_SET_CPUCORE) {\n\t\t\t\tDHD_ERROR((\"%s: dpc(%d) invalid cpu!\\n\", __FUNCTION__, e_dpc));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (e_dpc < 0)\n\t\t\t\tOSL_SLEEP(1);\n\t\t} while (e_dpc < 0);\n\t}\n\tif (RXF_CPUCORE) {\n\t\tdo {\n\t\t\tif (set == TRUE) {\n\t\t\t\te_rxf = set_cpus_allowed_ptr(dhd->current_rxf,\n\t\t\t\t\tcpumask_of(RXF_CPUCORE));\n\t\t\t} else {\n\t\t\t\te_rxf = set_cpus_allowed_ptr(dhd->current_rxf,\n\t\t\t\t\tcpumask_of(PRIMARY_CPUCORE));\n\t\t\t}\n\t\t\tif (retry_set++ > MAX_RETRY_SET_CPUCORE) {\n\t\t\t\tDHD_ERROR((\"%s: rxf(%d) invalid cpu!\\n\", __FUNCTION__, e_rxf));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (e_rxf < 0)\n\t\t\t\tOSL_SLEEP(1);\n\t\t} while (e_rxf < 0);\n\t}\n#ifdef DHD_OF_SUPPORT\n\tinterrupt_set_cpucore(set);\n#endif /* DHD_OF_SUPPORT */\n\tDHD_TRACE((\"%s: set(%d) cpucore success!\\n\", __FUNCTION__, set));\n\n\treturn;\n}\n#endif /* CUSTOM_SET_CPUCORE */\n#if defined(DHD_TCP_WINSIZE_ADJUST)\nstatic int dhd_port_list_match(int port)\n{\n\tint i;\n\tfor (i = 0; i < MAX_TARGET_PORTS; i++) {\n\t\tif (target_ports[i] == port)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\nstatic void dhd_adjust_tcp_winsize(int op_mode, struct sk_buff *skb)\n{\n\tstruct iphdr *ipheader;\n\tstruct tcphdr *tcpheader;\n\tuint16 win_size;\n\tint32 incremental_checksum;\n\n\tif (!(op_mode & DHD_FLAG_HOSTAP_MODE))\n\t\treturn;\n\tif (skb == NULL || skb->data == NULL)\n\t\treturn;\n\n\tipheader = (struct iphdr*)(skb->data);\n\n\tif (ipheader->protocol == IPPROTO_TCP) {\n\t\ttcpheader = (struct tcphdr*) skb_pull(skb, (ipheader->ihl)<<2);\n\t\tif (tcpheader) {\n\t\t\twin_size = ntoh16(tcpheader->window);\n\t\t\tif (win_size < MIN_TCP_WIN_SIZE &&\n\t\t\t\tdhd_port_list_match(ntoh16(tcpheader->dest))) {\n\t\t\t\tincremental_checksum = ntoh16(tcpheader->check);\n\t\t\t\tincremental_checksum += win_size - win_size*WIN_SIZE_SCALE_FACTOR;\n\t\t\t\tif (incremental_checksum < 0)\n\t\t\t\t\t--incremental_checksum;\n\t\t\t\ttcpheader->window = hton16(win_size*WIN_SIZE_SCALE_FACTOR);\n\t\t\t\ttcpheader->check = hton16((unsigned short)incremental_checksum);\n\t\t\t}\n\t\t}\n\t\tskb_push(skb, (ipheader->ihl)<<2);\n\t}\n}\n#endif /* DHD_TCP_WINSIZE_ADJUST */\n\n/* Get interface specific ap_isolate configuration */\nint dhd_get_ap_isolate(dhd_pub_t *dhdp, uint32 idx)\n{\n\tdhd_info_t *dhd = dhdp->info;\n\tdhd_if_t *ifp;\n\n\tASSERT(idx < DHD_MAX_IFS);\n\n\tifp = dhd->iflist[idx];\n\n\treturn ifp->ap_isolate;\n}\n\n/* Set interface specific ap_isolate configuration */\nint dhd_set_ap_isolate(dhd_pub_t *dhdp, uint32 idx, int val)\n{\n\tdhd_info_t *dhd = dhdp->info;\n\tdhd_if_t *ifp;\n\n\tASSERT(idx < DHD_MAX_IFS);\n\n\tifp = dhd->iflist[idx];\n\n\tifp->ap_isolate = val;\n\n\treturn 0;\n}\n\n#ifdef DHD_WMF\n/* Returns interface specific WMF configuration */\ndhd_wmf_t* dhd_wmf_conf(dhd_pub_t *dhdp, uint32 idx)\n{\n\tdhd_info_t *dhd = dhdp->info;\n\tdhd_if_t *ifp;\n\n\tASSERT(idx < DHD_MAX_IFS);\n\n\tifp = dhd->iflist[idx];\n\treturn &ifp->wmf;\n}\n#endif /* DHD_WMF */\n\n\n#ifdef DHD_UNICAST_DHCP\nstatic int\ndhd_get_pkt_ether_type(dhd_pub_t *pub, void *pktbuf,\n\tuint8 **data_ptr, int *len_ptr, uint16 *et_ptr, bool *snap_ptr)\n{\n\tuint8 *frame = PKTDATA(pub->osh, pktbuf);\n\tint length = PKTLEN(pub->osh, pktbuf);\n\tuint8 *pt;\t\t\t/* Pointer to type field */\n\tuint16 ethertype;\n\tbool snap = FALSE;\n\t/* Process Ethernet II or SNAP-encapsulated 802.3 frames */\n\tif (length < ETHER_HDR_LEN) {\n\t\tDHD_ERROR((\"dhd: %s: short eth frame (%d)\\n\",\n\t\t           __FUNCTION__, length));\n\t\treturn BCME_ERROR;\n\t} else if (ntoh16_ua(frame + ETHER_TYPE_OFFSET) >= ETHER_TYPE_MIN) {\n\t\t/* Frame is Ethernet II */\n\t\tpt = frame + ETHER_TYPE_OFFSET;\n\t} else if (length >= ETHER_HDR_LEN + SNAP_HDR_LEN + ETHER_TYPE_LEN &&\n\t           !bcmp(llc_snap_hdr, frame + ETHER_HDR_LEN, SNAP_HDR_LEN)) {\n\t\tpt = frame + ETHER_HDR_LEN + SNAP_HDR_LEN;\n\t\tsnap = TRUE;\n\t} else {\n\t\tDHD_INFO((\"DHD: %s: non-SNAP 802.3 frame\\n\",\n\t\t           __FUNCTION__));\n\t\treturn BCME_ERROR;\n\t}\n\n\tethertype = ntoh16_ua(pt);\n\n\t/* Skip VLAN tag, if any */\n\tif (ethertype == ETHER_TYPE_8021Q) {\n\t\tpt += VLAN_TAG_LEN;\n\n\t\tif ((pt + ETHER_TYPE_LEN) > (frame + length)) {\n\t\t\tDHD_ERROR((\"dhd: %s: short VLAN frame (%d)\\n\",\n\t\t\t          __FUNCTION__, length));\n\t\t\treturn BCME_ERROR;\n\t\t}\n\n\t\tethertype = ntoh16_ua(pt);\n\t}\n\n\t*data_ptr = pt + ETHER_TYPE_LEN;\n\t*len_ptr = length - (pt + ETHER_TYPE_LEN - frame);\n\t*et_ptr = ethertype;\n\t*snap_ptr = snap;\n\treturn BCME_OK;\n}\n\nstatic int\ndhd_get_pkt_ip_type(dhd_pub_t *pub, void *pktbuf,\n\tuint8 **data_ptr, int *len_ptr, uint8 *prot_ptr)\n{\n\tstruct ipv4_hdr *iph;\t\t/* IP frame pointer */\n\tint iplen;\t\t\t/* IP frame length */\n\tuint16 ethertype, iphdrlen, ippktlen;\n\tuint16 iph_frag;\n\tuint8 prot;\n\tbool snap;\n\n\tif (dhd_get_pkt_ether_type(pub, pktbuf, (uint8 **)&iph,\n\t    &iplen, &ethertype, &snap) != 0)\n\t\treturn BCME_ERROR;\n\n\tif (ethertype != ETHER_TYPE_IP) {\n\t\treturn BCME_ERROR;\n\t}\n\n\t/* We support IPv4 only */\n\tif (iplen < IPV4_OPTIONS_OFFSET || (IP_VER(iph) != IP_VER_4)) {\n\t\treturn BCME_ERROR;\n\t}\n\n\t/* Header length sanity */\n\tiphdrlen = IPV4_HLEN(iph);\n\n\t/*\n\t * Packet length sanity; sometimes we receive eth-frame size bigger\n\t * than the IP content, which results in a bad tcp chksum\n\t */\n\tippktlen = ntoh16(iph->tot_len);\n\tif (ippktlen < iplen) {\n\n\t\tDHD_INFO((\"%s: extra frame length ignored\\n\",\n\t\t          __FUNCTION__));\n\t\tiplen = ippktlen;\n\t} else if (ippktlen > iplen) {\n\t\tDHD_ERROR((\"dhd: %s: truncated IP packet (%d)\\n\",\n\t\t           __FUNCTION__, ippktlen - iplen));\n\t\treturn BCME_ERROR;\n\t}\n\n\tif (iphdrlen < IPV4_OPTIONS_OFFSET || iphdrlen > iplen) {\n\t\tDHD_ERROR((\"DHD: %s: IP-header-len (%d) out of range (%d-%d)\\n\",\n\t\t           __FUNCTION__, iphdrlen, IPV4_OPTIONS_OFFSET, iplen));\n\t\treturn BCME_ERROR;\n\t}\n\n\t/*\n\t * We don't handle fragmented IP packets.  A first frag is indicated by the MF\n\t * (more frag) bit and a subsequent frag is indicated by a non-zero frag offset.\n\t */\n\tiph_frag = ntoh16(iph->frag);\n\n\tif ((iph_frag & IPV4_FRAG_MORE) || (iph_frag & IPV4_FRAG_OFFSET_MASK) != 0) {\n\t\tDHD_INFO((\"DHD:%s: IP fragment not handled\\n\",\n\t\t           __FUNCTION__));\n\t\treturn BCME_ERROR;\n\t}\n\n\tprot = IPV4_PROT(iph);\n\n\t*data_ptr = (((uint8 *)iph) + iphdrlen);\n\t*len_ptr = iplen - iphdrlen;\n\t*prot_ptr = prot;\n\treturn BCME_OK;\n}\n\n/** check the packet type, if it is DHCP ACK/REPLY, convert into unicast packet\t*/\nstatic\nint dhd_convert_dhcp_broadcast_ack_to_unicast(dhd_pub_t *pub, void *pktbuf, int ifidx)\n{\n\tdhd_sta_t* stainfo;\n\tuint8 *eh = PKTDATA(pub->osh, pktbuf);\n\tuint8 *udph;\n\tuint8 *dhcp;\n\tuint8 *chaddr;\n\tint udpl;\n\tint dhcpl;\n\tuint16 port;\n\tuint8 prot;\n\n\tif (!ETHER_ISMULTI(eh + ETHER_DEST_OFFSET))\n\t    return BCME_ERROR;\n\tif (dhd_get_pkt_ip_type(pub, pktbuf, &udph, &udpl, &prot) != 0)\n\t\treturn BCME_ERROR;\n\tif (prot != IP_PROT_UDP)\n\t\treturn BCME_ERROR;\n\t/* check frame length, at least UDP_HDR_LEN */\n\tif (udpl < UDP_HDR_LEN) {\n\t\tDHD_ERROR((\"DHD: %s: short UDP frame, ignored\\n\",\n\t\t    __FUNCTION__));\n\t\treturn BCME_ERROR;\n\t}\n\tport = ntoh16_ua(udph + UDP_DEST_PORT_OFFSET);\n\t/* only process DHCP packets from server to client */\n\tif (port != DHCP_PORT_CLIENT)\n\t\treturn BCME_ERROR;\n\n\tdhcp = udph + UDP_HDR_LEN;\n\tdhcpl = udpl - UDP_HDR_LEN;\n\n\tif (dhcpl < DHCP_CHADDR_OFFSET + ETHER_ADDR_LEN) {\n\t\tDHD_ERROR((\"DHD: %s: short DHCP frame, ignored\\n\",\n\t\t    __FUNCTION__));\n\t\treturn BCME_ERROR;\n\t}\n\t/* only process DHCP reply(offer/ack) packets */\n\tif (*(dhcp + DHCP_TYPE_OFFSET) != DHCP_TYPE_REPLY)\n\t\treturn BCME_ERROR;\n\tchaddr = dhcp + DHCP_CHADDR_OFFSET;\n\tstainfo = dhd_find_sta(pub, ifidx, chaddr);\n\tif (stainfo) {\n\t\tbcopy(chaddr, eh + ETHER_DEST_OFFSET, ETHER_ADDR_LEN);\n\t\treturn BCME_OK;\n\t}\n\treturn BCME_ERROR;\n}\n#endif /* DHD_UNICAST_DHD */\n#ifdef DHD_L2_FILTER\n/* Check if packet type is ICMP ECHO */\nstatic\nint dhd_l2_filter_block_ping(dhd_pub_t *pub, void *pktbuf, int ifidx)\n{\n\tstruct bcmicmp_hdr *icmph;\n\tint udpl;\n\tuint8 prot;\n\n\tif (dhd_get_pkt_ip_type(pub, pktbuf, (uint8 **)&icmph, &udpl, &prot) != 0)\n\t\treturn BCME_ERROR;\n\tif (prot == IP_PROT_ICMP) {\n\t\tif (icmph->type == ICMP_TYPE_ECHO_REQUEST)\n\t\t\treturn BCME_OK;\n\t}\n\treturn BCME_ERROR;\n}\n#endif /* DHD_L2_FILTER */\n\n#ifdef SET_RPS_CPUS\nint custom_rps_map_set(struct netdev_rx_queue *queue, char *buf, size_t len)\n{\n\tstruct rps_map *old_map, *map;\n\tcpumask_var_t mask;\n\tint err, cpu, i;\n\tstatic DEFINE_SPINLOCK(rps_map_lock);\n\n\tDHD_INFO((\"%s : Entered.\\n\", __FUNCTION__));\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL)) {\n\t\tDHD_ERROR((\"%s : alloc_cpumask_var fail.\\n\", __FUNCTION__));\n\t\treturn -ENOMEM;\n\t}\n\n\terr = bitmap_parse(buf, len, cpumask_bits(mask), nr_cpumask_bits);\n\tif (err) {\n\t\tfree_cpumask_var(mask);\n\t\tDHD_ERROR((\"%s : bitmap_parse fail.\\n\", __FUNCTION__));\n\t\treturn err;\n\t}\n\n\tmap = kzalloc(max_t(unsigned int,\n\t\tRPS_MAP_SIZE(cpumask_weight(mask)), L1_CACHE_BYTES),\n\t\tGFP_KERNEL);\n\tif (!map) {\n\t\tfree_cpumask_var(mask);\n\t\tDHD_ERROR((\"%s : map malloc fail.\\n\", __FUNCTION__));\n\t\treturn -ENOMEM;\n\t}\n\n\ti = 0;\n\tfor_each_cpu(cpu, mask)\n\t\tmap->cpus[i++] = cpu;\n\n\tif (i)\n\t\tmap->len = i;\n\telse {\n\t\tkfree(map);\n\t\tDHD_ERROR((\"%s : mapping cpu fail.\\n\", __FUNCTION__));\n\t\tmap = NULL;\n\t}\n\n\tspin_lock(&rps_map_lock);\n\told_map = rcu_dereference_protected(queue->rps_map,\n\t\tlockdep_is_held(&rps_map_lock));\n\trcu_assign_pointer(queue->rps_map, map);\n\tspin_unlock(&rps_map_lock);\n\n\tif (map)\n\t\tstatic_key_slow_inc(&rps_needed);\n\tif (old_map) {\n\t\tkfree_rcu(old_map, rcu);\n\t\tstatic_key_slow_dec(&rps_needed);\n\t}\n\tfree_cpumask_var(mask);\n\n\tDHD_INFO((\"%s : Done. mapping cpu nummber : %d\\n\", __FUNCTION__, map->len));\n\treturn map->len;\n}\n\nvoid custom_rps_map_clear(struct netdev_rx_queue *queue)\n{\n\tstruct rps_map *map;\n\n\tDHD_INFO((\"%s : Entered.\\n\", __FUNCTION__));\n\n\tmap = rcu_dereference_protected(queue->rps_map, 1);\n\tif (map) {\n\t\tRCU_INIT_POINTER(queue->rps_map, NULL);\n\t\tkfree_rcu(map, rcu);\n\t\tDHD_INFO((\"%s : rps_cpus map clear.\\n\", __FUNCTION__));\n\t}\n}\n#endif /* SET_RPS_CPUS */\n\n#if defined(CUSTOMER_HW20) && defined(WLANAUDIO)\nvoid\nSDA_setSharedMemory4Send(unsigned int buffer_id,\n                         unsigned char *buffer, unsigned int buffer_size,\n                         unsigned int packet_size, unsigned int headroom_size)\n{\n\tdhd_info_t *dhd = dhd_global;\n\n\tsda_packet_length = packet_size;\n\n\tASSERT(dhd);\n\tif (dhd == NULL)\n\t\treturn;\n}\n\nvoid\nSDA_registerCallback4SendDone(SDA_SendDoneCallBack packet_cb)\n{\n\tdhd_info_t *dhd = dhd_global;\n\n\tASSERT(dhd);\n\tif (dhd == NULL)\n\t\treturn;\n}\n\n\nunsigned long long\nSDA_getTsf(unsigned char vif_id)\n{\n\tdhd_info_t *dhd = dhd_global;\n\tuint64 tsf_val;\n\tchar buf[WLC_IOCTL_SMLEN];\n\tint ifidx = 0;\n\n\tstruct tsf {\n\t\tuint32 low;\n\t\tuint32 high;\n\t} tsf_buf;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tif (vif_id == 0) /* wlan0 tsf */\n\t\tifidx = dhd_ifname2idx(dhd, \"wlan0\");\n\telse if (vif_id == 1) /* p2p0 tsf */\n\t\tifidx = dhd_ifname2idx(dhd, \"p2p0\");\n\n\tbcm_mkiovar(\"tsf_bss\", 0, 0, buf, sizeof(buf));\n\n\tif (dhd_wl_ioctl_cmd(&dhd->pub, WLC_GET_VAR, buf, sizeof(buf), FALSE, ifidx) < 0) {\n\t\tDHD_ERROR((\"%s wl ioctl error\\n\", __FUNCTION__));\n\t\treturn 0;\n\t}\n\n\tmemcpy(&tsf_buf, buf, sizeof(tsf_buf));\n\ttsf_val = (uint64)tsf_buf.high;\n\tDHD_TRACE((\"%s tsf high 0x%08x, low 0x%08x\\n\",\n\t           __FUNCTION__, tsf_buf.high, tsf_buf.low));\n\n\treturn ((tsf_val << 32) | tsf_buf.low);\n}\nEXPORT_SYMBOL(SDA_getTsf);\n\nunsigned int\nSDA_syncTsf(void)\n{\n\tdhd_info_t *dhd = dhd_global;\n\tint tsf_sync = 1;\n\tchar iovbuf[WLC_IOCTL_SMLEN];\n\n\tbcm_mkiovar(\"wa_tsf_sync\", (char *)&tsf_sync, 4, iovbuf, sizeof(iovbuf));\n\tdhd_wl_ioctl_cmd(&dhd->pub, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);\n\n\tDHD_TRACE((\"%s\\n\", __FUNCTION__));\n\treturn 0;\n}\n\nextern struct net_device *wl0dot1_dev;\n\nvoid\nBCMFASTPATH SDA_function4Send(uint buffer_id, void *packet, uint packet_size)\n{\n\tstruct sk_buff *skb;\n\tsda_packet_t *shm_packet = packet;\n\tdhd_info_t *dhd = dhd_global;\n\tint cnt;\n\n\tstatic unsigned int cnt_t = 1;\n\n\tASSERT(dhd);\n\tif (dhd == NULL)\n\t\treturn;\n\n\tif (dhd->is_wlanaudio_blist) {\n\t\tfor (cnt = 0; cnt < MAX_WLANAUDIO_BLACKLIST; cnt++) {\n\t\t\tif (dhd->wlanaudio_blist[cnt].is_blacklist == true) {\n\t\t\t\tif (!bcmp(dhd->wlanaudio_blist[cnt].blacklist_addr.octet,\n\t\t\t\t          shm_packet->headroom.ether_dhost, ETHER_ADDR_LEN))\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((cnt_t % 10000) == 0)\n\t\tcnt_t = 0;\n\n\tcnt_t++;\n\n\t/* packet_size may be smaller than SDA_SHM_PKT_SIZE, remaining will be garbage */\n#define TXOFF 26\n\tskb = __dev_alloc_skb(TXOFF + sda_packet_length - SDA_PKT_HEADER_SIZE, GFP_ATOMIC);\n\n\tskb_reserve(skb, TXOFF - SDA_HEADROOM_SIZE);\n\tskb_put(skb, sda_packet_length - SDA_PKT_HEADER_SIZE + SDA_HEADROOM_SIZE);\n\tskb->priority = PRIO_8021D_VO; /* PRIO_8021D_VO or PRIO_8021D_VI */\n\n\t/* p2p_net  */\n\tskb->dev = wl0dot1_dev;\n\tshm_packet->txTsf = 0x0;\n\tshm_packet->rxTsf = 0x0;\n\tmemcpy(skb->data, &shm_packet->headroom,\n\t       sda_packet_length - OFFSETOF(sda_packet_t, headroom));\n\tshm_packet->desc.ready_to_copy = 0;\n\n\tdhd_start_xmit(skb, skb->dev);\n}\n\nvoid\nSDA_registerCallback4Recv(unsigned char *pBufferTotal,\n                          unsigned int BufferTotalSize)\n{\n\tdhd_info_t *dhd = dhd_global;\n\n\tASSERT(dhd);\n\tif (dhd == NULL)\n\t\treturn;\n}\n\n\nvoid\nSDA_setSharedMemory4Recv(unsigned char *pBufferTotal,\n                         unsigned int BufferTotalSize,\n                         unsigned int BufferUnitSize,\n                         unsigned int Headroomsize)\n{\n\tdhd_info_t *dhd = dhd_global;\n\n\tASSERT(dhd);\n\tif (dhd == NULL)\n\t\treturn;\n}\n\n\nvoid\nSDA_function4RecvDone(unsigned char * pBuffer, unsigned int BufferSize)\n{\n\tdhd_info_t *dhd = dhd_global;\n\n\tASSERT(dhd);\n\tif (dhd == NULL)\n\t\treturn;\n}\n\nEXPORT_SYMBOL(SDA_setSharedMemory4Send);\nEXPORT_SYMBOL(SDA_registerCallback4SendDone);\nEXPORT_SYMBOL(SDA_syncTsf);\nEXPORT_SYMBOL(SDA_function4Send);\nEXPORT_SYMBOL(SDA_registerCallback4Recv);\nEXPORT_SYMBOL(SDA_setSharedMemory4Recv);\nEXPORT_SYMBOL(SDA_function4RecvDone);\n\n#endif /* CUSTOMER_HW20 && WLANAUDIO */\n\nvoid *dhd_get_pub(struct net_device *dev)\n{\n\tdhd_info_t *dhdinfo = *(dhd_info_t **)netdev_priv(dev);\n\tif (dhdinfo)\n\t\treturn (void *)&dhdinfo->pub;\n\telse\n\t\treturn NULL;\n}\n\nbool dhd_os_wd_timer_enabled(void *bus)\n{\n\tdhd_pub_t *pub = bus;\n\tdhd_info_t *dhd = (dhd_info_t *)pub->info;\n\n\tDHD_TRACE((\"%s: Enter\\n\", __FUNCTION__));\n\tif (!dhd) {\n\t\tDHD_ERROR((\"%s: dhd NULL\\n\", __FUNCTION__));\n\t\treturn FALSE;\n\t}\n\treturn dhd->wd_timer_valid;\n}\n",
			"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_linux.c",
			"file_size": 278173,
			"file_write_time": 131458852127866078,
			"settings":
			{
				"buffer_size": 278172,
				"line_ending": "Unix"
			}
		},
		{
			"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c",
			"settings":
			{
				"buffer_size": 21940,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 490.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 490.0
	},
	"console":
	{
		"height": 162.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/Z/lepus_3rd_0412_0725/linux",
		"/Z/lepus_3rd_0412_0725/linux/kernel",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/arch",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/arch/arm",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/arch/arm/configs",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/arch/arm/plat-s5p4418",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/arch/arm/plat-s5p4418/lepus",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/net",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/net/wireless",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd",
		"/Z/lepus_3rd_0412_0725/linux/prototype",
		"/Z/lepus_3rd_0412_0725/linux/prototype/s5p4418"
	],
	"file_history":
	[
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/include/linux/mmc/sdio_func.h",
		"/D/ddanggzi/poring_data/WiFi/ap6255/bcmdhd_work/bcmsdh_sdmmc_linux.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/wl_android.c",
		"/C/Users/ddanggzi/Desktop/ft5x06.diff",
		"/Z/lepus_3rd_0412_0725/frameworks/base/packages/SystemUI/res/layout/system_icons.xml",
		"/Z/lepus_3rd_0412_0725/linux/bootloader/u-boot-2014.07/include/configs/s5p4418_lepus.h",
		"/Z/lepus_3rd_0412_0725/linux/bootloader/u-boot-2014.07/board/s5p4418/lepus/include/cfg_main.h",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/net/core/dev.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_common.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_linux.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/bcmsdh_linux.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_gpio.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/gt9xx.h",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/arch/arm/configs/s5p4418_lepus_android_lollipop_defconfig",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/arch/arm/plat-s5p4418/lepus/include/cfg_main.h",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/arch/arm/mach-s5p4418/dev-display.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/ft5x0x_ts.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/arch/arm/plat-s5p4418/lepus/include/cfg_gpio.h",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/ft5x06_ts.h",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/arch/arm/plat-s5p4418/lepus/device.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/gt9xx.c",
		"/Z/lepus_3rd_0412_0525_touch/kernel/arch/arm/plat-s5p4418/lepus/device.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/include/linux/input.h",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/Kconfig",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/net/rfkill/rfkill-nxp.c",
		"/Z/lepus_3rd_0412_0725/device/nexell/lepus/device.mk",
		"/Z/lepus_3rd_0412_0725/device/nexell/lepus/BoardConfig.mk",
		"/Z/lepus_3rd_0412_0725/device/nexell/lepus/init.lepus.rc",
		"/Z/lepus_3rd_0412_0725/hardware/broadcom/libbt/include/vnd_lepus.txt",
		"/Z/lepus_3rd_0412_0725/hardware/broadcom/libbt/conf/ap6210/Android.mk",
		"/Z/lepus_3rd_0412_0725/hardware/broadcom/libbt/conf/ap6210/bd_addr.txt",
		"/Z/lepus_3rd_0412_0725/hardware/broadcom/libbt/conf/ap6210/bt_vendor.conf",
		"/Z/lepus_3rd_0412_0725/hardware/broadcom/libbt/Android.mk",
		"/Z/lepus_3rd_0412_0725/hardware/broadcom/libbt/include/bt_vendor_brcm.h",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_config.c",
		"/Z/lepus_3rd_0412_0725/external/wpa_supplicant_8/wpa_supplicant/wpa_supplicant.conf",
		"/Z/lepus_3rd_0412_0725/hardware/broadcom/wlan/bcmdhd/config/wpa_supplicant_overlay.conf",
		"/Z/lepus_3rd_0412_0725/hardware/broadcom/wlan/bcmdhd/config/p2p_supplicant_overlay.conf",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/mmc/host/dw_mmc.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/mmc/host/dw_mmc.h",
		"/Z/lepus_3rd_0412_0525_old/linux/kernel/kernel-3.4.39/arch/arm/plat-s5p4418/lepus/device.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/bcmsdh.c",
		"/Z/lepus_3rd_0412_0725/linux/prototype/s5p4418/module/nx_mipi.h",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/arch/arm/mach-s5p4418/soc/display_mipi.c",
		"/Z/lepus_3rd_0412_0725/linux/prototype/s5p4418/module/nx_mipi.c",
		"/Z/lepus_3rd_0412_0525_old/linux/bootloader/u-boot-2014.07/board/s5p4418/lepus/include/cfg_main.h",
		"/Z/temp3/cfg_gpio.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/prototype/s5p4418/module/nx_mipi.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/arch/arm/mach-slsiap/hdmi/nxp-hdmi-context.c",
		"/Z/lepus_3rd_0412_0725/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/Makefile",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/plat-s5p4418/lepus/include/cfg_gpio.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/bootloader/u-boot-2014.07/board/s5p4418/lepus/display.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/devices/display_mipi.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/bootloader/u-boot-2014.07/include/configs/s5p4418_lepus.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/bootloader/u-boot-2014.07/arch/arm/cpu/slsiap/devices/display_dev.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/mach-s5p4418/soc/display.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/prototype/s5p4418/module/nx_mipi.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/mach-s5p4418/soc/display_mipi.c_work",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/configs/s5p4418_lepus_android_lollipop_defconfig",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/mach-s5p4418/soc/display_mipi.c",
		"/Z/lepus_3rd_0412_0525_old/linux/bootloader/u-boot-2014.07/board/s5p4418/lepus/display.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/bootloader/u-boot-2014.07/board/s5p4418/lepus/include/cfg_gpio.h",
		"/Z/lepus_3rd_0412_0525_old/kernel/arch/arm/mach-s5p4418/soc/display_mipi.c",
		"/Z/nxp4330_2bsp_image/cfg_main_boot.h",
		"/Z/nxp4330_2bsp_image/cfg_main.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/plat-s5p4418/lepus/include/cfg_main.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/bootloader/u-boot-2014.07/board/s5p4418/lepus/include/cfg_main.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/prototype/s5p4418/module/nx_displaytop.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/video/nxp-fb.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/include/generated/autoconf.h",
		"/D/ddanggzi/poring_data/Cemera/OV5640/ov5640 - 20160808.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/bootloader/u-boot-2014.07/arch/arm/include/asm/arch/s5p4418.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/mach-s5p4418/dev-display.c",
		"/Z/lepus_3rd_0412_0525_touch/kernel/arch/arm/mach-s5p4418/soc/display_mipi.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/bootloader/u-boot-2014.07/board/s5p4418/lepus/display.c_bak",
		"/Z/lepus_3rd_0412_0525_old/linux/kernel/kernel-3.4.39/arch/arm/mach-s5p4418/soc/display_mipi.c_work",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/mach-s5p4418/soc/display_mipi.c_ori",
		"/Z/lepus_3rd_0412_0525_old/linux/kernel/kernel-3.4.39/arch/arm/configs/s5p4418_lepus_android_lollipop_defconfig",
		"/Z/lepus_3rd_0412_0525_touch/linux/prototype/s5p4418/module/nx_displaytop.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/mach-slsiap/hdmi/nxp-hdmi-context.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/mach-s5p4418/soc/display_lvds.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/mach-slsiap/hdmi/nxp-hdmi-context.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/mach-s5p4418/soc/display_resc.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/media/video/nexell/out/hdmi-new/nxp-hdmi.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/prototype/s5p4418/module/nx_disptop_clkgen.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/prototype/s5p4418/base/nx_prototype.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/prototype/s5p4418/base/nx_debug.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/mach-s5p4418/soc/display_hdmi.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/prototype/s5p4418/module/nx_disptop_clkgen.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/mach-msm/board-trout-panel.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/gt9xx.h",
		"/D/ddanggzi/poring_data/Touch/5.0 inch CTP资料包/5.0 inch CTP资料包/5.0 inch CTP  GT9 MTK驱动/20170718_cfg.cfg",
		"/Z/temp5/touchscreen_4430/gt9xx.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/gt9xx.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/plat-s5p4418/lepus/device.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/media/video/nexell/out/nxp-mlc.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/synaptics_i2c_rmi.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/auo-pixcir-ts.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/da9034-ts.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/gt9xx_update.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/goodix_tool.c",
		"/Z/lepus_3rd_0412_0525_touch/device/nexell/lepus/device.mk",
		"/Z/lepus_3rd_0412_0525_touch/device/nexell/lepus/gslX680.idc",
		"/D/ddanggzi/poring_data/Touch/5.0 inch CTP资料包/5.0 inch CTP资料包/5.0 inch CTP  GT9 MTK驱动/reference driver/gt9xx_driver.c",
		"/D/ddanggzi/poring_data/Touch/5.0 inch CTP资料包/5.0 inch CTP资料包/5.0 inch CTP  GT9 MTK驱动/reference driver/tpd_custom_gt9xx.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/Makefile",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/gslX680.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/keyboard/atkbd.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/keyboard/adp5588-keys.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/gt9xx_firmware.h",
		"/Z/temp5/touchscreen_4430/gt9xx.h",
		"/Z/temp5/touchscreen_4430/gt9xx_firmware.h",
		"/D/ddanggzi/poring_data/Touch/GT9147_source/gt9xx_firmware.h",
		"/D/ddanggzi/poring_data/Touch/GT9147_source/tpd_custom_gt9xx.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/include/linux/input.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/gt9xx.c_work",
		"/D/ddanggzi/poring_data/Touch/5.0 inch CTP资料包/5.0 inch CTP资料包/5.0 inch CTP  GT9 MTK驱动/2reference driver/gt9xx_driver.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/tpd_custom_gt9xx.h",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/gt9xx.h_back",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/gt9xx_10_vw.c",
		"/Z/lepus_3rd_0412_0525_old/linux/kernel/kernel-3.4.39/drivers/media/video/thine/thp7212-nx-cam.c",
		"/Z/lepus_3rd_0412_0525_old/kernel/drivers/input/touchscreen/gt9xx.c",
		"/Z/lepus_3rd_0412_0525/kernel/drivers/input/touchscreen/gt9xx.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/arch/arm/mach-s5p4418/include/mach/devices.h",
		"/Z/lepus_3rd_0412_0525_old/linux/kernel/kernel-3.4.39/drivers/media/video/sp2518.c",
		"/Z/lepus_3rd_0412_0525_touch/linux/kernel/kernel-3.4.39/drivers/input/touchscreen/usb2514.c"
	],
	"find":
	{
		"height": 43.0
	},
	"find_in_files":
	{
		"height": 117.0,
		"where_history":
		[
			"Z:\\lepus_3rd_0412_0725\\linux\\kernel\\kernel-3.4.39\\drivers\\net\\wireless\\bcmdhd",
			"Z:\\lepus_3rd_0412_0725\\linux\\kernel\\kernel-3.4.39\\drivers\\net\\wireless",
			"Z:\\lepus_3rd_0412_0725\\linux\\kernel\\kernel-3.4.39\\drivers\\net\\wireless\\bcmdhd",
			"Z:\\lepus_3rd_0412_0725\\linux\\kernel\\kernel-3.4.39\\drivers\\net\\wireless",
			"Z:\\lepus_3rd_0412_0725\\linux\\kernel\\kernel-3.4.39\\drivers\\net\\wireless\\bcmdhd",
			"Z:\\lepus_3rd_0412_0725\\linux\\kernel\\kernel-3.4.39\\drivers\\net",
			"Z:\\lepus_3rd_0412_0725\\linux\\kernel\\kernel-3.4.39\\drivers\\net\\wireless\\bcmdhd",
			"Z:\\lepus_3rd_0412_0725\\linux\\kernel\\kernel-3.4.39\\drivers\\net\\wireless",
			"Z:\\lepus_3rd_0412_0725\\linux\\kernel\\kernel-3.4.39\\drivers\\net\\wireless\\bcmdhd",
			"Z:\\lepus_3rd_0412_0725\\linux\\kernel\\kernel-3.4.39\\drivers\\net\\wireless",
			"Z:\\lepus_3rd_0412_0725\\linux\\kernel\\kernel-3.4.39\\drivers\\net\\wireless\\bcmdhd",
			"Z:\\lepus_3rd_0412_0525_touch\\linux\\prototype\\s5p4418",
			"Z:\\lepus_3rd_0412_0525_touch\\linux\\kernel\\kernel-3.4.39\\arch\\arm\\mach-s5p4418",
			"Z:\\lepus_3rd_0412_0525_touch\\linux\\prototype\\s5p4418\\module",
			"Z:\\lepus_3rd_0412_0525_touch\\linux\\kernel\\kernel-3.4.39\\arch\\arm\\mach-slsiap\\hdmi",
			"Z:\\lepus_3rd_0412_0525_touch\\linux\\kernel\\kernel-3.4.39\\drivers\\input\\touchscreen",
			"Z:\\lepus_3rd_0412_0525_touch\\linux\\kernel\\kernel-3.4.39\\drivers\\input",
			"Z:\\lepus_3rd_0412_0525_touch\\linux\\kernel\\kernel-3.4.39\\drivers\\input\\touchscreen",
			"Z:\\lepus_0315\\hardware\\samsung_slsi\\slsiap\\camera",
			"Z:\\lepus_0315\\device",
			"Z:\\lepus_3rd_0412_0525_old\\linux\\kernel\\kernel-3.4.39\\drivers\\media\\video\\nexell",
			"Z:\\lepus_3rd_0412_0525_old\\linux\\kernel\\kernel-3.4.39\\drivers\\media\\video\\nexell\\capture",
			"Z:\\lepus_3rd_0412_0525_old\\linux\\kernel\\kernel-3.4.39\\drivers\\media\\video\\nexell\\capture,Z:\\lepus_3rd_0412_0525\\linux\\kernel\\kernel-3.4.39\\arch\\arm\\mach-s5p4418\\include\\mach",
			"Z:\\lepus_3rd_0412_0525_old\\linux\\kernel\\kernel-3.4.39\\drivers\\media\\video\\nexell\\capture",
			"Z:\\lepus_3rd_0412_0525_old\\linux\\kernel\\kernel-3.4.39\\drivers\\media\\video\\nexell",
			"Z:\\lepus_3rd_0412_0525_old\\linux\\kernel\\kernel-3.4.39\\drivers\\media\\video\\nexell\\capture",
			"Z:\\lepus_3rd_0412_0525_old\\linux\\kernel\\kernel-3.4.39\\drivers\\media\\video\\thine",
			"Z:\\lepus_3rd_0412_0525_old\\linux\\kernel\\kernel-3.4.39\\include",
			"Z:\\lepus_3rd_0412_0525_old\\linux\\kernel\\kernel-3.4.39\\drivers\\media\\video\\thine",
			"Z:\\lepus_3rd_0412_0525_old\\linux\\kernel\\kernel-3.4.39\\arch\\arm\\plat-s5p4418\\lepus\\include",
			"Z:\\lepus_3rd_0412_0525_old\\linux\\kernel\\kernel-3.4.39\\arch\\arm\\plat-s5p6818\\svt\\include",
			"Z:\\lepus_3rd_0412_0525\\linux\\kernel\\kernel-3.4.39",
			"Z:\\lepus_3rd_0412_0525\\linux\\kernel\\kernel-3.4.39\\drivers\\media\\video\\tw"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"CONFIG_PM",
			"dhd_open(struct",
			"dhd_open",
			"wl_android_wifi_on",
			"aaaaaaaaaa==2",
			"========2",
			"wl_run_escan",
			"wwwww",
			"g_wifi_on",
			"gNet",
			"========2",
			"----1",
			"mcp_lock",
			"mutex",
			"spin",
			"wl_cfg80211_get_station",
			"--------------1",
			"ccccccccccc",
			"DDDDDDD===",
			"D=============",
			"wl_cfg80211_resume",
			"_resume",
			"reg_on",
			"reg_",
			"bcmsdh_cfg_write",
			"sdioh_cfg_write",
			"sdioh_request_byte",
			"rw",
			"sdioh_request_byte",
			"SDIOH_WRITE",
			"sdioh_request_byte",
			"failed to",
			"g_wifi_on",
			"gNet",
			"wl_android_wifi_on",
			"dhd_open",
			"net_device",
			"ap_net_dev",
			"struct net_device *ap_net_dev",
			"ap_net_dev",
			"net_device",
			"dhd_info",
			"net_device",
			"dhd_open",
			"wl_android_wifi_on",
			"nxp",
			"bcmsdh_sdmmc_suspend",
			"bcmsdh_sdmmc_resume",
			"bcmsdh_sdmmc_pm_ops",
			"bcmsdh_sdmmc_suspend",
			".name",
			"dhd_set_scb_probe",
			"probe",
			"dhd_net_bus_resume",
			"resume",
			"dhd_wifi_platform_register_drv",
			"dhd_wifi_platform_load",
			"dhd_wifi_platform_register_drv",
			"dhd_wifi_platform_load",
			"wifi_plat_dev_drv_resume",
			"wifi_plat_dev_drv_probe",
			"dhd_wifi_platform_load",
			"resume",
			"dhd_net_bus_resume",
			"resume",
			"wl_android_wifi_on",
			"dhd_net_bus_resume",
			"resume",
			"wl_android_wifi_on",
			"KKS",
			"resume",
			"ndo_open",
			"dhd_ops_pri",
			"dhd_open",
			"wl_android_wifi_on",
			"KKS:",
			"===4",
			"dhd_version",
			"dhd_compiled",
			"Compiled in",
			"wifi_ctrlfunc_register_drv",
			"dhd_wlan_init_plat_data",
			"dhd_wlan_init_gpio",
			"dhd_event_ifadd",
			"dhd_ifadd_event_handler",
			"dhd_register_if",
			"dhd_ops_pri",
			"dhd_open",
			"dhd_ops_pri",
			"dhd_open",
			"dhd_do_driver_init",
			"dhd_open",
			"Compiled in drivers",
			"dhd_version",
			"Dongle Host",
			"firmware_path",
			"fw_bak_path",
			"dhd_module_init",
			"dhd_wifi_platform_register_drv",
			"wifi_ctrlfunc_register_drv",
			"dhd_wifi_platform_load",
			"probe",
			"dhd_wlan_init_plat_data",
			"CUSTOMER_HW",
			"wifi_plat_dev_drv_resume",
			"resume",
			"resum",
			"ddanggzi",
			"bcmsdh_resume",
			"gpio_wl_reg_on",
			"reg_on",
			"dhd_wifi_platform_load",
			"dhd_wifi_platform_load_sdio",
			"wifi_plat_dev_drv_resume",
			"wifi_platform_set_power",
			"->set_power",
			"dhd_wlan_control",
			"dhd_wlan_set_power",
			"set_power",
			"OOB_INTR_ONLY",
			"bcmsdh_sdmmc_resume",
			"bcmsdh_sdmmc_pm_ops",
			"bcmsdh_sdmmc_resume",
			"bcmsdh_resume",
			"resume",
			"dhd_wlan_set_power",
			"BUS_POWER_RESTORE",
			"dhd_wlan_set_power"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"u32",
			"u8",
			"uint8",
			"bool",
			"//cust_gpio_usage.h",
			"gt9xx.h",
			"//#include \"tpd.h\"",
			"CFG_IO_TOUCH_RESET_PIN",
			"CFG_IO_TOUCH_PENDOWN_DETECT",
			"bool",
			"\\r\\n\");",
			"THP7212",
			""
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 3,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12868,
						"regions":
						{
						},
						"selection":
						[
							[
								11649,
								11649
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 5878.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/wl_android.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 82846,
						"regions":
						{
						},
						"selection":
						[
							[
								9220,
								9220
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 4654.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 53970,
						"regions":
						{
						},
						"selection":
						[
							[
								19294,
								19294
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 11879.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "kernel/kernel-3.4.39/arch/arm/configs/s5p4418_lepus_android_lollipop_defconfig",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 83895,
						"regions":
						{
						},
						"selection":
						[
							[
								15128,
								15137
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 8870.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "kernel/kernel-3.4.39/drivers/net/can/mcp251x.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 32549,
						"regions":
						{
						},
						"selection":
						[
							[
								25499,
								25509
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 15500.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "kernel/kernel-3.4.39/net/core/dev.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 164046,
						"regions":
						{
						},
						"selection":
						[
							[
								32274,
								32274
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 18968.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/bcmsdh_linux.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 13305,
						"regions":
						{
						},
						"selection":
						[
							[
								5898,
								5898
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2580.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_pcie_linux.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 34145,
						"regions":
						{
						},
						"selection":
						[
							[
								3072,
								3072
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1237.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_sdio.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 275453,
						"regions":
						{
						},
						"selection":
						[
							[
								270848,
								270848
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 157569.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_wlfc.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 105914,
						"regions":
						{
						},
						"selection":
						[
							[
								67138,
								67138
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 43482.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/wl_cfg80211.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 442445,
						"regions":
						{
						},
						"selection":
						[
							[
								255527,
								255527
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 150650.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_gpio.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8451,
						"regions":
						{
						},
						"selection":
						[
							[
								1375,
								1375
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/bcmsdh.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17854,
						"regions":
						{
						},
						"selection":
						[
							[
								6212,
								6212
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 3379.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/wl_iw.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 100008,
						"regions":
						{
						},
						"selection":
						[
							[
								2870,
								2880
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 978.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_linux.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 278172,
						"regions":
						{
						},
						"selection":
						[
							[
								116272,
								116272
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 73572.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "kernel/kernel-3.4.39/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21940,
						"regions":
						{
						},
						"selection":
						[
							[
								14584,
								14614
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 11021.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 25.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "lepus_3rd_0412_0725.sublime-project",
	"replace":
	{
		"height": 80.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 625.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"C:\\temp\\pol1\\pro1-sublime.sublime-project"
			]
		],
		"width": 475.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 501.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
